{"title":"Code Walkthrough","markdown":{"headingText":"Code Walkthrough","containsRefs":false,"markdown":"\n### 1. Imports and Setup (Lines 1-14)\n\n```python\nimport torch\nimport torch.distributed as dist\nfrom accelerate import PartialState\n```\n\n**What's happening:**\n- `torch`: The main PyTorch library for deep learning\n- `torch.distributed (dist)`: PyTorch's library for distributed training across multiple devices\n- `PartialState`: A helper from the Accelerate library that manages which GPU each process should use\n\n```python\nstate = PartialState()\ndevice = state.device\nset_seed(42)\n```\n\n**What's happening:**\n- `PartialState()` automatically figures out which GPU this process should use\n- `device` stores the assigned GPU\n- `set_seed(42)` ensures reproducibility - all processes start with the same random state\n\n---\n\n### 2. The SimpleDistributedDataParallelism Class (Lines 16-42)\n\nThis is the heart of the code! It shows how DDP works under the hood.\n\n#### Initialization (__init__, Lines 17-27)\n\n```python\ndef __init__(self, model:torch.nn.Module):\n    self.model = model\n\n    for param in model.parameters():\n        rank0_param = param.data.clone()\n        dist.broadcast(rank0_param, src=0)\n        if not torch.equal(param.data, rank0_param):\n            raise ValueError(...)\n```\n\n**What's happening:**\n\n1. **Takes a model as input** and stores it\n2. **Broadcasts parameters from GPU 0 to all other GPUs**:\n   - In distributed training, each GPU (called a \"rank\") has its own copy of the model\n   - \"Broadcasting\" means copying data from one GPU to all others\n   - This ensures all GPUs start with identical model weights\n3. **Verification check**: If any GPU has different parameters, raise an error\n\n**Why this matters:** All GPUs must start with the exact same model, or they'll learn different things!\n\n#### Gradient Synchronization (Lines 29-33)\n\n```python\ndef sync_gradients(self):\n    for param in self.model.parameters():\n        if param.grad is not None:\n            dist.all_reduce(param.grad, op=dist.ReduceOp.SUM)\n            param.grad /= dist.get_world_size()\n```\n\n**What's happening:**\n\nThis is THE KEY operation in DDP! Let me explain with an example:\n\nImagine you have 2 GPUs:\n- GPU 0 processes batch A and calculates gradient = [1, 2, 3]\n- GPU 1 processes batch B and calculates gradient = [4, 5, 6]\n\nAfter `all_reduce` with SUM operation:\n- Both GPUs now have gradient = [5, 7, 9] (sum of both)\n\nAfter dividing by world_size (2):\n- Both GPUs have gradient = [2.5, 3.5, 4.5] (average)\n\n**Why averaging?** This is equivalent to processing both batches on a single GPU! The gradient is the average across all data processed by all GPUs.\n\n#### Helper Methods (Lines 35-42)\n\n```python\ndef __call__(self, *args, **kwargs):\n    return self.model(*args, **kwargs)\n\ndef train(self):\n    self.model.train()\n\ndef eval(self):\n    self.model.eval()\n```\n\n**What's happening:**\nThese methods allow our wrapper to behave like a regular PyTorch model.\n\n---\n\n### 3. Data Preparation (Lines 44-68)\n\n```python\ndataset = get_dataset()[\"train\"]\ntrain_ds = dataset.shuffle(seed=42)\n```\n\n**What's happening:**\n- Load the training dataset\n- Shuffle it with a fixed seed so all GPUs shuffle the same way\n\n```python\ndef collate_func(batch):\n    return tokenizer.pad(\n        batch,\n        padding=\"longest\",\n        pad_to_multiple_of=8,\n        return_tensors=\"pt\",\n    )\n```\n\n**What's happening:**\n- This function prepares batches of text data\n- It pads sequences to the same length (needed for batch processing)\n- Pads to multiples of 8 (optimization for GPU efficiency)\n\n---\n\n### 4. Data Sharding - The Critical Part! (Lines 87-98)\n\n```python\n# Shard data for first parallel dimension\nds_length = len(train_ds)\nds_length_per_rank = ds_length // get(\"ws\")  # ws = world_size\nrank = get(\"rank\")\nstart = rank * ds_length_per_rank\nend = start + ds_length_per_rank if rank != get(\"ws\") - 1 else ds_length\n\ntrain_shard = train_ds.select(list(range(start, end)))\n```\n\n**What's happening:**\n\nThis splits the dataset into separate chunks for each GPU!\n\n**Example with 1000 samples and 4 GPUs:**\n- Total samples: 1000\n- Samples per GPU: 1000 / 4 = 250\n- GPU 0 (rank 0): samples 0-249\n- GPU 1 (rank 1): samples 250-499\n- GPU 2 (rank 2): samples 500-749\n- GPU 3 (rank 3): samples 750-999\n\n**Why this matters:** Each GPU only loads and processes its own portion of data, so they work on different examples simultaneously!\n\n---\n\n### 5. Model Setup (Lines 109-112)\n\n```python\nmodel = get_smol_model()\nmodel.to(device)\noptimizer = torch.optim.SGD(model.model.parameters(), lr=1e-3)\nmodel = SimpleDistributedDataParallelism(model)\n```\n\n**What's happening:**\n1. Create the model\n2. Move it to the assigned GPU\n3. Create an optimizer (SGD with learning rate 0.001)\n4. Wrap the model with our DDP wrapper\n\n---\n\n### 6. Profiler Setup (Lines 114-136)\n\n```python\nif state.is_main_process:\n    profiler_context = profile(...)\n```\n\n**What's happening:**\n- Only the main process (GPU 0) runs the profiler\n- The profiler tracks performance metrics like memory usage and computation time\n- Results are saved to \"ddp_trace\" folder for analysis with TensorBoard\n\n**Why only main process?** To avoid multiple GPUs writing the same profiling data and causing conflicts.\n\n#### Understanding the Profiler Schedule\n\n```python\nprofiler_schedule = schedule(\n    skip_first=5,\n    wait=1,\n    warmup=2,\n    active=5,\n    repeat=1\n)\n```\n\n**What's happening:**\n\nThe profiler schedule controls WHEN the profiler collects data. It doesn't run on every iteration because profiling adds overhead and generates large trace files. The schedule has four phases that cycle through iterations:\n\n1. **skip_first=5**: Skip the first 5 iterations completely (no profiling)\n   - Why? The first few iterations are often slower due to initialization and GPU warm-up\n   - Skipping them gives more accurate performance measurements\n\n2. **wait=1**: Wait for 1 iteration without profiling\n   - This is a \"rest\" phase between profiling cycles\n   - Allows the system to stabilize before starting to profile again\n\n3. **warmup=2**: Run for 2 iterations collecting basic profiling data\n   - This is a \"warm-up\" phase where the profiler starts but doesn't record everything yet\n   - Helps the profiler itself initialize properly\n\n4. **active=5**: Actively profile for 5 iterations with full data collection\n   - This is when the profiler records detailed performance data\n   - Captures CPU usage, GPU usage, memory allocations, and operation timing\n\n5. **repeat=1**: Repeat the cycle (wait → warmup → active) 1 time\n   - After the first cycle completes, it runs one more cycle\n   - Total cycles = initial + repeat = 2 cycles\n\n**Timeline example for 20 iterations:**\n\n```\nIterations 0-4:   SKIP (skip_first=5)\nIteration 5:      WAIT (wait=1)\nIterations 6-7:   WARMUP (warmup=2)\nIterations 8-12:  ACTIVE - recording data! (active=5)\nIteration 13:     WAIT (wait=1)\nIterations 14-15: WARMUP (warmup=2)\nIterations 16-20: ACTIVE - recording data! (active=5)\n```\n\n#### Understanding the Profile Configuration\n\n```python\nprofiler_context = profile(\n    activities=[ProfilerActivity.CPU, ProfilerActivity.CUDA],\n    schedule=profiler_schedule,\n    on_trace_ready=torch.profiler.tensorboard_trace_handler(\"ddp_trace\"),\n    record_shapes=True,\n    profile_memory=True,\n    with_stack=True,\n    with_flops=True\n)\n```\n\n**What each parameter means:**\n\n- **activities=[ProfilerActivity.CPU, ProfilerActivity.CUDA]**\n  - Track both CPU and GPU (CUDA) operations\n  - Shows where time is spent on both devices\n\n- **schedule=profiler_schedule**\n  - Use the schedule defined above to control when profiling happens\n\n- **on_trace_ready=torch.profiler.tensorboard_trace_handler(\"ddp_trace\")**\n  - When profiling data is ready, save it to the \"ddp_trace\" folder\n  - Can be visualized with TensorBoard using: `tensorboard --logdir=ddp_trace`\n\n- **record_shapes=True**\n  - Record the shapes of tensors (e.g., [batch_size, sequence_length, hidden_size])\n  - Helps identify operations working on large tensors that might be slow\n\n- **profile_memory=True**\n  - Track memory allocations and deallocations\n  - Shows which operations use the most GPU memory\n  - Helps identify memory bottlenecks or leaks\n\n- **with_stack=True**\n  - Record the Python call stack for each operation\n  - Shows which line of code triggered each operation\n  - Makes it easier to find performance bottlenecks in your code\n\n- **with_flops=True**\n  - Estimate floating-point operations (FLOPs) for each operation\n  - Helps understand computational intensity\n  - Higher FLOPs = more computation work\n\n**Why this matters:** Profiling helps you understand where your training time is spent. You can identify if you're bottlenecked by data loading, forward pass, backward pass, or gradient synchronization!\n\n#### Visualizing Profiler Data with TensorBoard (Remote Setup)\n\nSince your code is running on **Lambda Labs** (remote GPU server) and you're accessing it from your **MacBook via VSCode**, here's how to visualize the profiler traces:\n\n**Step 1: Run the DDP Training Script on Lambda Labs**\n\nFirst, execute your training script on the Lambda Labs instance. This will generate the profiler trace files:\n\n```bash\n# On Lambda Labs (via VSCode terminal)\npython ddp.py\n```\n\nAfter the script completes, you should see a `ddp_trace` folder created with trace files inside.\n\n**Step 2: Install TensorBoard (if not already installed)**\n\nOn your Lambda Labs instance:\n\n```bash\npip install tensorboard\n```\n\n**Step 3: Launch TensorBoard on Lambda Labs**\n\nStart TensorBoard on the remote server:\n\n```bash\ntensorboard --logdir=ddp_trace --port=6006\n```\n\nThis will output something like:\n```\nTensorBoard 2.x.x at http://localhost:6006/\n```\n\n**Important:** Keep this terminal running! Don't close it.\n\n**Step 4: Port Forwarding via VSCode (Easy Method)**\n\nVSCode makes port forwarding super easy!\n\n**Option A: Automatic Port Forwarding (Recommended)**\n\n1. VSCode should automatically detect that port 6006 is being used\n2. Look for a notification in the bottom-right corner saying \"Port 6006 is available\"\n3. Click \"Open in Browser\" or \"Forward Port\"\n\n**Option B: Manual Port Forwarding**\n\n1. In VSCode, press `Cmd+Shift+P` (on Mac) to open the Command Palette\n2. Type \"Forward a Port\" and select it\n3. Enter port number: `6006`\n4. Press Enter\n\nYou should see the forwarded port appear in the \"PORTS\" panel at the bottom of VSCode.\n\n**Step 5: Open TensorBoard in Your MacBook Browser**\n\nOnce the port is forwarded, open your web browser on your MacBook and go to:\n\n```\nhttp://localhost:6006\n```\n\nYou should see the TensorBoard interface!\n\n**Step 6: Navigate to the Profiler Tab**\n\nIn TensorBoard:\n1. Click on the **\"PYTORCH_PROFILER\"** or **\"PROFILE\"** tab at the top\n2. You'll see a dropdown to select which trace file to view\n3. Select the trace file you want to analyze\n\n**What You'll See in TensorBoard:**\n\nThe profiler visualization shows several views:\n\n1. **Overview Page:**\n   - Performance summary\n   - GPU utilization over time\n   - Step time breakdown (how long each training iteration took)\n\n2. **Operator View:**\n   - Shows which PyTorch operations took the most time\n   - See operations like `matmul`, `conv2d`, `all_reduce`, etc.\n   - Sorted by execution time\n\n3. **Kernel View:**\n   - Low-level GPU kernel performance\n   - Shows actual CUDA kernels that ran on the GPU\n\n4. **Trace View:**\n   - Timeline visualization\n   - Shows when each operation executed\n   - You can zoom in to see individual operations\n   - **Look for the `sync_grads` section** - this shows the time spent on gradient synchronization!\n\n5. **Memory View:**\n   - Memory allocation over time\n   - Helps identify memory leaks or spikes\n\n**Tips for Analysis:**\n\n- **Look for the \"sync_grads\" operations** in the trace view - this is your DDP gradient synchronization time\n- **Compare \"forward\", \"backward\", and \"sync_grads\" times** - ideally, sync time should be small compared to computation\n- **Check GPU utilization** - you want this close to 100% during training\n- **Identify bottlenecks** - if data loading takes longer than forward/backward, you need faster data loading\n\n**Alternative: Using SSH Tunnel (Manual Method)**\n\nIf VSCode port forwarding doesn't work, you can use SSH tunneling:\n\n```bash\n# On your MacBook terminal (not VSCode)\nssh -L 6006:localhost:6006 username@lambda-labs-ip-address\n```\n\nThen access `http://localhost:6006` in your browser.\n\n**Troubleshooting:**\n\n- **Port already in use?** Change the port: `tensorboard --logdir=ddp_trace --port=6007`\n- **Can't see traces?** Make sure the `ddp_trace` folder exists and contains `.pt.trace.json` files\n- **Port forwarding not working?** Try restarting VSCode or manually set up SSH tunnel\n- **No data in TensorBoard?** The profiler only collects data during \"active\" iterations (8-12 and 16-20 in this code)\n\n---\n\n### 7. The Training Loop (Lines 138-161)\n\nThis is where everything comes together!\n\n```python\nfor (i, batch) in enumerate(train_dataloader):\n    if i > 20:\n        break\n```\n\n**What's happening:** Loop through batches, stopping after 20 iterations (for demonstration).\n\n#### Step 1: Move Data to GPU (Lines 143-144)\n\n```python\nwith record_function(\"data_movement\"):\n    batch = {k: v.to(device) for k, v in batch.items()}\n```\n\n**What's happening:** Transfer the batch from CPU memory to GPU memory.\n\n#### Step 2: Forward Pass (Lines 146-147)\n\n```python\nwith record_function(\"forward\"):\n    output = model(**batch)\n```\n\n**What's happening:**\n- Run the model on the input data\n- Each GPU processes its own batch independently\n- Calculate predictions and loss\n\n#### Step 3: Backward Pass (Lines 148-149)\n\n```python\nwith record_function(\"backward\"):\n    output.loss.backward()\n```\n\n**What's happening:**\n- Calculate gradients using backpropagation\n- Each GPU calculates gradients based on its own batch\n- At this point, gradients are still different on each GPU!\n\n#### Step 4: Synchronize Gradients (Lines 151-152)\n\n```python\nwith record_function(\"sync_grads\"):\n    model.sync_gradients()\n```\n\n**What's happening:**\n- **THIS IS THE MAGIC!**\n- All GPUs communicate and average their gradients\n- After this step, all GPUs have identical gradients\n- This makes it as if we processed all batches on a single GPU\n\n#### Step 5: Update Model (Lines 154-158)\n\n```python\nwith record_function(\"opt_step\"):\n    optimizer.step()\n    optimizer.zero_grad()\n```\n\n**What's happening:**\n1. Update model parameters using the averaged gradients\n2. Reset gradients to zero for the next iteration\n3. Since all GPUs have the same gradients, they all update identically\n4. Models stay synchronized!\n\n---\n\n### 8. Cleanup (Lines 160-163)\n\n```python\nif profiler_context:\n    profiler_context.__exit__(None, None, None)\n\ndist.destroy_process_group()\n```\n\n**What's happening:**\n- Close the profiler\n- Destroy the process group (disconnect GPUs from each other)\n\n---\n\n## The Big Picture: How DDP Works\n\n### The DDP Workflow\n\n1. **Initialization:** All GPUs start with identical model copies\n2. **Data Sharding:** Each GPU gets a different subset of the training data\n3. **Independent Forward/Backward:** Each GPU processes its own data independently\n4. **Gradient Synchronization:** GPUs communicate and average their gradients\n5. **Synchronized Update:** All GPUs update their models identically\n6. **Repeat:** Back to step 3 for the next batch\n\n### Why DDP is Powerful\n\n**Speed:** With N GPUs, you process N times more data per iteration!\n\n**Example:**\n- Single GPU: Process 8 samples per iteration\n- 4 GPUs with DDP: Process 32 samples per iteration (8 per GPU)\n- This is like having a batch size of 32, but the memory usage per GPU is only for batch size 8!\n\n**Equivalence to Single GPU:**\nDDP is mathematically equivalent to training on a single GPU with a larger batch size, because:\n- You process more samples total (N times more)\n- Gradients are averaged across all samples\n- Model updates are based on the averaged gradient\n\n### Key Concepts Recap\n\n- **Rank:** The ID of each GPU (0, 1, 2, ...)\n- **World Size:** Total number of GPUs\n- **Broadcast:** Copy data from one GPU to all others\n- **All-Reduce:** Combine data from all GPUs (sum, average, etc.)\n- **Data Sharding:** Split dataset so each GPU gets different samples\n- **Gradient Synchronization:** Average gradients across all GPUs\n\n---\n\n## Summary\n\nThis code demonstrates a simplified version of PyTorch's Distributed Data Parallelism. The key insight is:\n\n> Each GPU works on different data independently, but they synchronize their gradients after backpropagation, ensuring all GPUs learn the same model together.\n\nBy splitting the work across multiple GPUs, you can train models much faster without changing the final result!\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css"],"output-file":"report.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.25","theme":["cosmo","brand"],"title-block-banner":true},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}