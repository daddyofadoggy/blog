[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html",
    "href": "posts/LLM-From-Scratch/index.html",
    "title": "LLM From Scratch",
    "section": "",
    "text": "[Your existing introduction content here…]"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Blogs",
    "section": "",
    "text": "LLM From Scratch\n\n\n\n\n\n\n\n\nOct 29, 2025\n\n\nDipankar Baisya\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\n\nOct 25, 2025\n\n\nDipankar Baisya\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html#working-with-text-data",
    "href": "index.html#working-with-text-data",
    "title": "My Blogs",
    "section": "",
    "text": "Explore how to process and work with text data for language models in the Working with text data section."
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#understanding-word-embeddings",
    "href": "posts/LLM-From-Scratch/index.html#understanding-word-embeddings",
    "title": "LLM From Scratch",
    "section": "2.1 Understanding word embeddings",
    "text": "2.1 Understanding word embeddings\n\nNo code in this section\nThere are many forms of embeddings; we focus on text embeddings in this book\n\n\n\nLLMs work with embeddings in high-dimensional spaces (i.e., thousands of dimensions)\nSince we can’t visualize such high-dimensional spaces (we humans think in 1, 2, or 3 dimensions), the figure below illustrates a 2-dimensional embedding space"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#tokenizing-text",
    "href": "posts/LLM-From-Scratch/index.html#tokenizing-text",
    "title": "LLM From Scratch",
    "section": "2.2 Tokenizing text",
    "text": "2.2 Tokenizing text\n\nIn this section, we tokenize text, which means breaking text into smaller units, such as individual words and punctuation characters\n\n\n\nLoad raw text we want to work with\nThe Verdict by Edith Wharton is a public domain short story\n(If you encounter an ssl.SSLCertVerificationError when executing the previous code cell, it might be due to using an outdated Python version; you can find more information here on GitHub)\n\n\n\nTotal number of character: 20479\nI HAD always thought Jack Gisburn rather a cheap genius--though a good fellow enough--so it was no \n\n\n\nThe goal is to tokenize and embed this text for an LLM\nLet’s develop a simple tokenizer based on some simple sample text that we can then later apply to the text above\nThe following regular expression will split on whitespaces\n\n\n\n['Hello,', ' ', 'world.', ' ', 'This,', ' ', 'is', ' ', 'a', ' ', 'test.']\n\n\n\nWe don’t only want to split on whitespaces but also commas and periods, so let’s modify the regular expression to do that as well\n\n\n\n['Hello', ',', '', ' ', 'world', '.', '', ' ', 'This', ',', '', ' ', 'is', ' ', 'a', ' ', 'test', '.', '']\n\n\n\nAs we can see, this creates empty strings, let’s remove them\n\n\n\n['Hello', ',', 'world', '.', 'This', ',', 'is', 'a', 'test', '.']\n\n\n\nThis looks pretty good, but let’s also handle other types of punctuation, such as periods, question marks, and so on\n\n\n\n['Hello', ',', 'world', '.', 'Is', 'this', '--', 'a', 'test', '?']\n\n\n\nThis is pretty good, and we are now ready to apply this tokenization to the raw text\n\n\n\n\n['I', 'HAD', 'always', 'thought', 'Jack', 'Gisburn', 'rather', 'a', 'cheap', 'genius', '--', 'though', 'a', 'good', 'fellow', 'enough', '--', 'so', 'it', 'was', 'no', 'great', 'surprise', 'to', 'me', 'to', 'hear', 'that', ',', 'in']\n\n\n\nLet’s calculate the total number of tokens\n\n\n\n4690"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#converting-tokens-into-token-ids",
    "href": "posts/LLM-From-Scratch/index.html#converting-tokens-into-token-ids",
    "title": "LLM From Scratch",
    "section": "2.3 Converting tokens into token IDs",
    "text": "2.3 Converting tokens into token IDs\n\nNext, we convert the text tokens into token IDs that we can process via embedding layers later\n\n\n\nFrom these tokens, we can now build a vocabulary that consists of all the unique tokens\n\n\n\n1130\n\n\n\nBelow are the first 50 entries in this vocabulary:\n\n\n\n('!', 0)\n('\"', 1)\n(\"'\", 2)\n('(', 3)\n(')', 4)\n(',', 5)\n('--', 6)\n('.', 7)\n(':', 8)\n(';', 9)\n('?', 10)\n('A', 11)\n('Ah', 12)\n('Among', 13)\n('And', 14)\n('Are', 15)\n('Arrt', 16)\n('As', 17)\n('At', 18)\n('Be', 19)\n('Begin', 20)\n('Burlington', 21)\n('But', 22)\n('By', 23)\n('Carlo', 24)\n('Chicago', 25)\n('Claude', 26)\n('Come', 27)\n('Croft', 28)\n('Destroyed', 29)\n('Devonshire', 30)\n('Don', 31)\n('Dubarry', 32)\n('Emperors', 33)\n('Florence', 34)\n('For', 35)\n('Gallery', 36)\n('Gideon', 37)\n('Gisburn', 38)\n('Gisburns', 39)\n('Grafton', 40)\n('Greek', 41)\n('Grindle', 42)\n('Grindles', 43)\n('HAD', 44)\n('Had', 45)\n('Hang', 46)\n('Has', 47)\n('He', 48)\n('Her', 49)\n('Hermia', 50)\n\n\n\nBelow, we illustrate the tokenization of a short sample text using a small vocabulary:\n\n\n\nPutting it now all together into a tokenizer class\nThe encode function turns text into token IDs\nThe decode function turns token IDs back into text\n\n\n\nWe can use the tokenizer to encode (that is, tokenize) texts into integers\nThese integers can then be embedded (later) as input of/for the LLM\n\n\n\n[1, 56, 2, 850, 988, 602, 533, 746, 5, 1126, 596, 5, 1, 67, 7, 38, 851, 1108, 754, 793, 7]\n\n\n\nWe can decode the integers back into text\n\n\n\n'\" It\\' s the last he painted, you know,\" Mrs. Gisburn said with pardonable pride.'\n\n\n\n\n'\" It\\' s the last he painted, you know,\" Mrs. Gisburn said with pardonable pride.'"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#adding-special-context-tokens",
    "href": "posts/LLM-From-Scratch/index.html#adding-special-context-tokens",
    "title": "LLM From Scratch",
    "section": "2.4 Adding special context tokens",
    "text": "2.4 Adding special context tokens\n\nIt’s useful to add some “special” tokens for unknown words and to denote the end of a text\n\n\n\nSome tokenizers use special tokens to help the LLM with additional context\nSome of these special tokens are\n\n[BOS] (beginning of sequence) marks the beginning of text\n[EOS] (end of sequence) marks where the text ends (this is usually used to concatenate multiple unrelated texts, e.g., two different Wikipedia articles or two different books, and so on)\n[PAD] (padding) if we train LLMs with a batch size greater than 1 (we may include multiple texts with different lengths; with the padding token we pad the shorter texts to the longest length so that all texts have an equal length)\n\n[UNK] to represent words that are not included in the vocabulary\nNote that GPT-2 does not need any of these tokens mentioned above but only uses an &lt;|endoftext|&gt; token to reduce complexity\nThe &lt;|endoftext|&gt; is analogous to the [EOS] token mentioned above\nGPT also uses the &lt;|endoftext|&gt; for padding (since we typically use a mask when training on batched inputs, we would not attend padded tokens anyways, so it does not matter what these tokens are)\nGPT-2 does not use an &lt;UNK&gt; token for out-of-vocabulary words; instead, GPT-2 uses a byte-pair encoding (BPE) tokenizer, which breaks down words into subword units which we will discuss in a later section\nWe use the &lt;|endoftext|&gt; tokens between two independent sources of text:\n\n\n\nLet’s see what happens if we tokenize the following text:\n\n\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[17], line 5\n      1 tokenizer = SimpleTokenizerV1(vocab)\n      3 text = \"Hello, do you like tea. Is this-- a test?\"\n----&gt; 5 tokenizer.encode(text)\n\nCell In[13], line 12, in SimpleTokenizerV1.encode(self, text)\n      7 preprocessed = re.split(r'([,.:;?_!\"()\\']|--|\\s)', text)\n      9 preprocessed = [\n     10     item.strip() for item in preprocessed if item.strip()\n     11 ]\n---&gt; 12 ids = [self.str_to_int[s] for s in preprocessed]\n     13 return ids\n\nCell In[13], line 12, in &lt;listcomp&gt;(.0)\n      7 preprocessed = re.split(r'([,.:;?_!\"()\\']|--|\\s)', text)\n      9 preprocessed = [\n     10     item.strip() for item in preprocessed if item.strip()\n     11 ]\n---&gt; 12 ids = [self.str_to_int[s] for s in preprocessed]\n     13 return ids\n\nKeyError: 'Hello'\n\n\n\n\nThe above produces an error because the word “Hello” is not contained in the vocabulary\nTo deal with such cases, we can add special tokens like \"&lt;|unk|&gt;\" to the vocabulary to represent unknown words\nSince we are already extending the vocabulary, let’s add another token called \"&lt;|endoftext|&gt;\" which is used in GPT-2 training to denote the end of a text (and it’s also used between concatenated text, like if our training datasets consists of multiple articles, books, etc.)\n\n\n\n1132\n\n\n\n\n('younger', 1127)\n('your', 1128)\n('yourself', 1129)\n('&lt;|endoftext|&gt;', 1130)\n('&lt;|unk|&gt;', 1131)\n\n\n\nWe also need to adjust the tokenizer accordingly so that it knows when and how to use the new &lt;unk&gt; token\n\nLet’s try to tokenize text with the modified tokenizer:\n\n\nHello, do you like tea? &lt;|endoftext|&gt; In the sunlit terraces of the palace.\n\n\n\n\n[1131, 5, 355, 1126, 628, 975, 10, 1130, 55, 988, 956, 984, 722, 988, 1131, 7]\n\n\n\n\n'&lt;|unk|&gt;, do you like tea? &lt;|endoftext|&gt; In the sunlit terraces of the &lt;|unk|&gt;.'"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#bytepair-encoding",
    "href": "posts/LLM-From-Scratch/index.html#bytepair-encoding",
    "title": "LLM From Scratch",
    "section": "2.5 BytePair encoding",
    "text": "2.5 BytePair encoding\n\nGPT-2 used BytePair encoding (BPE) as its tokenizer\nit allows the model to break down words that aren’t in its predefined vocabulary into smaller subword units or even individual characters, enabling it to handle out-of-vocabulary words\nFor instance, if GPT-2’s vocabulary doesn’t have the word “unfamiliarword,” it might tokenize it as [“unfam”, “iliar”, “word”] or some other subword breakdown, depending on its trained BPE merges\nThe original BPE tokenizer can be found here: https://github.com/openai/gpt-2/blob/master/src/encoder.py\nIn this chapter, we are using the BPE tokenizer from OpenAI’s open-source tiktoken library, which implements its core algorithms in Rust to improve computational performance\nI created a notebook in the ./bytepair_encoder that compares these two implementations side-by-side (tiktoken was about 5x faster on the sample text)\n\n\n\ntiktoken version: 0.7.0\n\n\n\n\n[15496, 11, 466, 345, 588, 8887, 30, 220, 50256, 554, 262, 4252, 18250, 8812, 2114, 1659, 617, 34680, 27271, 13]\n\n\n\n\nHello, do you like tea? &lt;|endoftext|&gt; In the sunlit terracesof someunknownPlace.\n\n\n\nBPE tokenizers break down unknown words into subwords and individual characters:"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#data-sampling-with-a-sliding-window",
    "href": "posts/LLM-From-Scratch/index.html#data-sampling-with-a-sliding-window",
    "title": "LLM From Scratch",
    "section": "2.6 Data sampling with a sliding window",
    "text": "2.6 Data sampling with a sliding window\n\nWe train LLMs to generate one word at a time, so we want to prepare the training data accordingly where the next word in a sequence represents the target to predict:\n\n\n\n\n5145\n\n\n\nFor each text chunk, we want the inputs and targets\nSince we want the model to predict the next word, the targets are the inputs shifted by one position to the right\n\n\n\nx: [290, 4920, 2241, 287]\ny:      [4920, 2241, 287, 257]\n\n\n\nOne by one, the prediction would look like as follows:\n\n\n\n[290] ----&gt; 4920\n[290, 4920] ----&gt; 2241\n[290, 4920, 2241] ----&gt; 287\n[290, 4920, 2241, 287] ----&gt; 257\n\n\n\n\n and ----&gt;  established\n and established ----&gt;  himself\n and established himself ----&gt;  in\n and established himself in ----&gt;  a\n\n\n\nWe will take care of the next-word prediction in a later chapter after we covered the attention mechanism\nFor now, we implement a simple data loader that iterates over the input dataset and returns the inputs and targets shifted by one\nInstall and import PyTorch (see Appendix A for installation tips)\n\n\n\nPyTorch version: 2.5.1\n\n\n\nWe use a sliding window approach, changing the position by +1:\n\n\n\nCreate dataset and dataloader that extract chunks from the input text dataset\nLet’s test the dataloader with a batch size of 1 for an LLM with a context size of 4:\n\n\n\n[tensor([[  40,  367, 2885, 1464]]), tensor([[ 367, 2885, 1464, 1807]])]\n\n\n\n\n[tensor([[ 367, 2885, 1464, 1807]]), tensor([[2885, 1464, 1807, 3619]])]\n\n\n\nAn example using stride equal to the context length (here: 4) as shown below:\n\n\n\nWe can also create batched outputs\nNote that we increase the stride here so that we don’t have overlaps between the batches, since more overlap could lead to increased overfitting\n\n\n\nInputs:\n tensor([[   40,   367,  2885,  1464],\n        [ 1807,  3619,   402,   271],\n        [10899,  2138,   257,  7026],\n        [15632,   438,  2016,   257],\n        [  922,  5891,  1576,   438],\n        [  568,   340,   373,   645],\n        [ 1049,  5975,   284,   502],\n        [  284,  3285,   326,    11]])\n\nTargets:\n tensor([[  367,  2885,  1464,  1807],\n        [ 3619,   402,   271, 10899],\n        [ 2138,   257,  7026, 15632],\n        [  438,  2016,   257,   922],\n        [ 5891,  1576,   438,   568],\n        [  340,   373,   645,  1049],\n        [ 5975,   284,   502,   284],\n        [ 3285,   326,    11,   287]])"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#creating-token-embeddings",
    "href": "posts/LLM-From-Scratch/index.html#creating-token-embeddings",
    "title": "LLM From Scratch",
    "section": "2.7 Creating token embeddings",
    "text": "2.7 Creating token embeddings\n\nThe data is already almost ready for an LLM\nBut lastly let us embed the tokens in a continuous vector representation using an embedding layer\nUsually, these embedding layers are part of the LLM itself and are updated (trained) during model training\n\n\n\nSuppose we have the following four input examples with input ids 2, 3, 5, and 1 (after tokenization):\nFor the sake of simplicity, suppose we have a small vocabulary of only 6 words and we want to create embeddings of size 3:\nThis would result in a 6x3 weight matrix:\n\n\n\nParameter containing:\ntensor([[ 0.3374, -0.1778, -0.1690],\n        [ 0.9178,  1.5810,  1.3010],\n        [ 1.2753, -0.2010, -0.1606],\n        [-0.4015,  0.9666, -1.1481],\n        [-1.1589,  0.3255, -0.6315],\n        [-2.8400, -0.7849, -1.4096]], requires_grad=True)\n\n\n\nFor those who are familiar with one-hot encoding, the embedding layer approach above is essentially just a more efficient way of implementing one-hot encoding followed by matrix multiplication in a fully-connected layer, which is described in the supplementary code in ./embedding_vs_matmul\nBecause the embedding layer is just a more efficient implementation that is equivalent to the one-hot encoding and matrix-multiplication approach it can be seen as a neural network layer that can be optimized via backpropagation\nTo convert a token with id 3 into a 3-dimensional vector, we do the following:\n\n\n\ntensor([[-0.4015,  0.9666, -1.1481]], grad_fn=&lt;EmbeddingBackward0&gt;)\n\n\n\nNote that the above is the 4th row in the embedding_layer weight matrix\nTo embed all four input_ids values above, we do\n\n\n\ntensor([[ 1.2753, -0.2010, -0.1606],\n        [-0.4015,  0.9666, -1.1481],\n        [-2.8400, -0.7849, -1.4096],\n        [ 0.9178,  1.5810,  1.3010]], grad_fn=&lt;EmbeddingBackward0&gt;)\n\n\n\nAn embedding layer is essentially a look-up operation:\n\n\n\nYou may be interested in the bonus content comparing embedding layers with regular linear layers: ../03_bonus_embedding-vs-matmul"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#encoding-word-positions",
    "href": "posts/LLM-From-Scratch/index.html#encoding-word-positions",
    "title": "LLM From Scratch",
    "section": "2.8 Encoding word positions",
    "text": "2.8 Encoding word positions\n\nEmbedding layer convert IDs into identical vector representations regardless of where they are located in the input sequence:\n\n\n\nPositional embeddings are combined with the token embedding vector to form the input embeddings for a large language model:\n\n\n\nThe BytePair encoder has a vocabulary size of 50,257:\nSuppose we want to encode the input tokens into a 256-dimensional vector representation:\nIf we sample data from the dataloader, we embed the tokens in each batch into a 256-dimensional vector\nIf we have a batch size of 8 with 4 tokens each, this results in a 8 x 4 x 256 tensor:\n\n\n\nToken IDs:\n tensor([[   40,   367,  2885,  1464],\n        [ 1807,  3619,   402,   271],\n        [10899,  2138,   257,  7026],\n        [15632,   438,  2016,   257],\n        [  922,  5891,  1576,   438],\n        [  568,   340,   373,   645],\n        [ 1049,  5975,   284,   502],\n        [  284,  3285,   326,    11]])\n\nInputs shape:\n torch.Size([8, 4])\n\n\n\n\ntorch.Size([8, 4, 256])\n\n\n\nGPT-2 uses absolute position embeddings, so we just create another embedding layer:\n\n\n\ntorch.Size([4, 256])\n\n\n\nTo create the input embeddings used in an LLM, we simply add the token and the positional embeddings:\n\n\n\ntorch.Size([8, 4, 256])\n\n\n\nIn the initial phase of the input processing workflow, the input text is segmented into separate tokens\nFollowing this segmentation, these tokens are transformed into token IDs based on a predefined vocabulary:"
  },
  {
    "objectID": "posts/LLM-From-Scratch/ch02.html",
    "href": "posts/LLM-From-Scratch/ch02.html",
    "title": "Chapter 2: Working with Text Data",
    "section": "",
    "text": "Packages that are being used in this notebook:\nfrom importlib.metadata import version\n\nprint(\"torch version:\", version(\"torch\"))\nprint(\"tiktoken version:\", version(\"tiktoken\"))\n\ntorch version: 2.5.1\ntiktoken version: 0.7.0"
  },
  {
    "objectID": "posts/LLM-From-Scratch/ch02.html#understanding-word-embeddings",
    "href": "posts/LLM-From-Scratch/ch02.html#understanding-word-embeddings",
    "title": "Chapter 2: Working with Text Data",
    "section": "2.1 Understanding word embeddings",
    "text": "2.1 Understanding word embeddings\n\nNo code in this section\nThere are many forms of embeddings; we focus on text embeddings in this book\n\n\n\nLLMs work with embeddings in high-dimensional spaces (i.e., thousands of dimensions)\nSince we can’t visualize such high-dimensional spaces (we humans think in 1, 2, or 3 dimensions), the figure below illustrates a 2-dimensional embedding space"
  },
  {
    "objectID": "posts/LLM-From-Scratch/ch02.html#tokenizing-text",
    "href": "posts/LLM-From-Scratch/ch02.html#tokenizing-text",
    "title": "Chapter 2: Working with Text Data",
    "section": "2.2 Tokenizing text",
    "text": "2.2 Tokenizing text\n\nIn this section, we tokenize text, which means breaking text into smaller units, such as individual words and punctuation characters\n\n\n\nLoad raw text we want to work with\nThe Verdict by Edith Wharton is a public domain short story\n\n\nimport os\nimport urllib.request\n\nif not os.path.exists(\"the-verdict.txt\"):\n    url = (\"https://raw.githubusercontent.com/rasbt/\"\n           \"LLMs-from-scratch/main/ch02/01_main-chapter-code/\"\n           \"the-verdict.txt\")\n    file_path = \"the-verdict.txt\"\n    urllib.request.urlretrieve(url, file_path)\n\n\n(If you encounter an ssl.SSLCertVerificationError when executing the previous code cell, it might be due to using an outdated Python version; you can find more information here on GitHub)\n\n\nwith open(\"the-verdict.txt\", \"r\", encoding=\"utf-8\") as f:\n    raw_text = f.read()\n    \nprint(\"Total number of character:\", len(raw_text))\nprint(raw_text[:99])\n\nTotal number of character: 20479\nI HAD always thought Jack Gisburn rather a cheap genius--though a good fellow enough--so it was no \n\n\n\nThe goal is to tokenize and embed this text for an LLM\nLet’s develop a simple tokenizer based on some simple sample text that we can then later apply to the text above\nThe following regular expression will split on whitespaces\n\n\nimport re\n\ntext = \"Hello, world. This, is a test.\"\nresult = re.split(r'(\\s)', text)\n\nprint(result)\n\n['Hello,', ' ', 'world.', ' ', 'This,', ' ', 'is', ' ', 'a', ' ', 'test.']\n\n\n\nWe don’t only want to split on whitespaces but also commas and periods, so let’s modify the regular expression to do that as well\n\n\nresult = re.split(r'([,.]|\\s)', text)\n\nprint(result)\n\n['Hello', ',', '', ' ', 'world', '.', '', ' ', 'This', ',', '', ' ', 'is', ' ', 'a', ' ', 'test', '.', '']\n\n\n\nAs we can see, this creates empty strings, let’s remove them\n\n\n# Strip whitespace from each item and then filter out any empty strings.\nresult = [item for item in result if item.strip()]\nprint(result)\n\n['Hello', ',', 'world', '.', 'This', ',', 'is', 'a', 'test', '.']\n\n\n\nThis looks pretty good, but let’s also handle other types of punctuation, such as periods, question marks, and so on\n\n\ntext = \"Hello, world. Is this-- a test?\"\n\nresult = re.split(r'([,.:;?_!\"()\\']|--|\\s)', text)\nresult = [item.strip() for item in result if item.strip()]\nprint(result)\n\n['Hello', ',', 'world', '.', 'Is', 'this', '--', 'a', 'test', '?']\n\n\n\nThis is pretty good, and we are now ready to apply this tokenization to the raw text\n\n\n\npreprocessed = re.split(r'([,.:;?_!\"()\\']|--|\\s)', raw_text)\npreprocessed = [item.strip() for item in preprocessed if item.strip()]\nprint(preprocessed[:30])\n\n['I', 'HAD', 'always', 'thought', 'Jack', 'Gisburn', 'rather', 'a', 'cheap', 'genius', '--', 'though', 'a', 'good', 'fellow', 'enough', '--', 'so', 'it', 'was', 'no', 'great', 'surprise', 'to', 'me', 'to', 'hear', 'that', ',', 'in']\n\n\n\nLet’s calculate the total number of tokens\n\n\nprint(len(preprocessed))\n\n4690"
  },
  {
    "objectID": "posts/LLM-From-Scratch/ch02.html#converting-tokens-into-token-ids",
    "href": "posts/LLM-From-Scratch/ch02.html#converting-tokens-into-token-ids",
    "title": "Chapter 2: Working with Text Data",
    "section": "2.3 Converting tokens into token IDs",
    "text": "2.3 Converting tokens into token IDs\n\nNext, we convert the text tokens into token IDs that we can process via embedding layers later\n\n\n\nFrom these tokens, we can now build a vocabulary that consists of all the unique tokens\n\n\nall_words = sorted(set(preprocessed))\nvocab_size = len(all_words)\n\nprint(vocab_size)\n\n1130\n\n\n\nvocab = {token:integer for integer,token in enumerate(all_words)}\n\n\nBelow are the first 50 entries in this vocabulary:\n\n\nfor i, item in enumerate(vocab.items()):\n    print(item)\n    if i &gt;= 50:\n        break\n\n('!', 0)\n('\"', 1)\n(\"'\", 2)\n('(', 3)\n(')', 4)\n(',', 5)\n('--', 6)\n('.', 7)\n(':', 8)\n(';', 9)\n('?', 10)\n('A', 11)\n('Ah', 12)\n('Among', 13)\n('And', 14)\n('Are', 15)\n('Arrt', 16)\n('As', 17)\n('At', 18)\n('Be', 19)\n('Begin', 20)\n('Burlington', 21)\n('But', 22)\n('By', 23)\n('Carlo', 24)\n('Chicago', 25)\n('Claude', 26)\n('Come', 27)\n('Croft', 28)\n('Destroyed', 29)\n('Devonshire', 30)\n('Don', 31)\n('Dubarry', 32)\n('Emperors', 33)\n('Florence', 34)\n('For', 35)\n('Gallery', 36)\n('Gideon', 37)\n('Gisburn', 38)\n('Gisburns', 39)\n('Grafton', 40)\n('Greek', 41)\n('Grindle', 42)\n('Grindles', 43)\n('HAD', 44)\n('Had', 45)\n('Hang', 46)\n('Has', 47)\n('He', 48)\n('Her', 49)\n('Hermia', 50)\n\n\n\nBelow, we illustrate the tokenization of a short sample text using a small vocabulary:\n\n\n\nPutting it now all together into a tokenizer class\n\n\nclass SimpleTokenizerV1:\n    def __init__(self, vocab):\n        self.str_to_int = vocab\n        self.int_to_str = {i:s for s,i in vocab.items()}\n    \n    def encode(self, text):\n        preprocessed = re.split(r'([,.:;?_!\"()\\']|--|\\s)', text)\n                                \n        preprocessed = [\n            item.strip() for item in preprocessed if item.strip()\n        ]\n        ids = [self.str_to_int[s] for s in preprocessed]\n        return ids\n        \n    def decode(self, ids):\n        text = \" \".join([self.int_to_str[i] for i in ids])\n        # Replace spaces before the specified punctuations\n        text = re.sub(r'\\s+([,.?!\"()\\'])', r'\\1', text)\n        return text\n\n\nThe encode function turns text into token IDs\nThe decode function turns token IDs back into text\n\n\n\nWe can use the tokenizer to encode (that is, tokenize) texts into integers\nThese integers can then be embedded (later) as input of/for the LLM\n\n\ntokenizer = SimpleTokenizerV1(vocab)\n\ntext = \"\"\"\"It's the last he painted, you know,\" \n           Mrs. Gisburn said with pardonable pride.\"\"\"\nids = tokenizer.encode(text)\nprint(ids)\n\n[1, 56, 2, 850, 988, 602, 533, 746, 5, 1126, 596, 5, 1, 67, 7, 38, 851, 1108, 754, 793, 7]\n\n\n\nWe can decode the integers back into text\n\n\ntokenizer.decode(ids)\n\n'\" It\\' s the last he painted, you know,\" Mrs. Gisburn said with pardonable pride.'\n\n\n\ntokenizer.decode(tokenizer.encode(text))\n\n'\" It\\' s the last he painted, you know,\" Mrs. Gisburn said with pardonable pride.'"
  },
  {
    "objectID": "posts/LLM-From-Scratch/ch02.html#adding-special-context-tokens",
    "href": "posts/LLM-From-Scratch/ch02.html#adding-special-context-tokens",
    "title": "Chapter 2: Working with Text Data",
    "section": "2.4 Adding special context tokens",
    "text": "2.4 Adding special context tokens\n\nIt’s useful to add some “special” tokens for unknown words and to denote the end of a text\n\n\n\nSome tokenizers use special tokens to help the LLM with additional context\nSome of these special tokens are\n\n[BOS] (beginning of sequence) marks the beginning of text\n[EOS] (end of sequence) marks where the text ends (this is usually used to concatenate multiple unrelated texts, e.g., two different Wikipedia articles or two different books, and so on)\n[PAD] (padding) if we train LLMs with a batch size greater than 1 (we may include multiple texts with different lengths; with the padding token we pad the shorter texts to the longest length so that all texts have an equal length)\n\n[UNK] to represent words that are not included in the vocabulary\nNote that GPT-2 does not need any of these tokens mentioned above but only uses an &lt;|endoftext|&gt; token to reduce complexity\nThe &lt;|endoftext|&gt; is analogous to the [EOS] token mentioned above\nGPT also uses the &lt;|endoftext|&gt; for padding (since we typically use a mask when training on batched inputs, we would not attend padded tokens anyways, so it does not matter what these tokens are)\nGPT-2 does not use an &lt;UNK&gt; token for out-of-vocabulary words; instead, GPT-2 uses a byte-pair encoding (BPE) tokenizer, which breaks down words into subword units which we will discuss in a later section\nWe use the &lt;|endoftext|&gt; tokens between two independent sources of text:\n\n\n\nLet’s see what happens if we tokenize the following text:\n\n\ntokenizer = SimpleTokenizerV1(vocab)\n\ntext = \"Hello, do you like tea. Is this-- a test?\"\n\ntokenizer.encode(text)\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[17], line 5\n      1 tokenizer = SimpleTokenizerV1(vocab)\n      3 text = \"Hello, do you like tea. Is this-- a test?\"\n----&gt; 5 tokenizer.encode(text)\n\nCell In[13], line 12, in SimpleTokenizerV1.encode(self, text)\n      7 preprocessed = re.split(r'([,.:;?_!\"()\\']|--|\\s)', text)\n      9 preprocessed = [\n     10     item.strip() for item in preprocessed if item.strip()\n     11 ]\n---&gt; 12 ids = [self.str_to_int[s] for s in preprocessed]\n     13 return ids\n\nCell In[13], line 12, in &lt;listcomp&gt;(.0)\n      7 preprocessed = re.split(r'([,.:;?_!\"()\\']|--|\\s)', text)\n      9 preprocessed = [\n     10     item.strip() for item in preprocessed if item.strip()\n     11 ]\n---&gt; 12 ids = [self.str_to_int[s] for s in preprocessed]\n     13 return ids\n\nKeyError: 'Hello'\n\n\n\n\nThe above produces an error because the word “Hello” is not contained in the vocabulary\nTo deal with such cases, we can add special tokens like \"&lt;|unk|&gt;\" to the vocabulary to represent unknown words\nSince we are already extending the vocabulary, let’s add another token called \"&lt;|endoftext|&gt;\" which is used in GPT-2 training to denote the end of a text (and it’s also used between concatenated text, like if our training datasets consists of multiple articles, books, etc.)\n\n\nall_tokens = sorted(list(set(preprocessed)))\nall_tokens.extend([\"&lt;|endoftext|&gt;\", \"&lt;|unk|&gt;\"])\n\nvocab = {token:integer for integer,token in enumerate(all_tokens)}\n\n\nlen(vocab.items())\n\n1132\n\n\n\nfor i, item in enumerate(list(vocab.items())[-5:]):\n    print(item)\n\n('younger', 1127)\n('your', 1128)\n('yourself', 1129)\n('&lt;|endoftext|&gt;', 1130)\n('&lt;|unk|&gt;', 1131)\n\n\n\nWe also need to adjust the tokenizer accordingly so that it knows when and how to use the new &lt;unk&gt; token\n\n\nclass SimpleTokenizerV2:\n    def __init__(self, vocab):\n        self.str_to_int = vocab\n        self.int_to_str = { i:s for s,i in vocab.items()}\n    \n    def encode(self, text):\n        preprocessed = re.split(r'([,.:;?_!\"()\\']|--|\\s)', text)\n        preprocessed = [item.strip() for item in preprocessed if item.strip()]\n        preprocessed = [\n            item if item in self.str_to_int \n            else \"&lt;|unk|&gt;\" for item in preprocessed\n        ]\n\n        ids = [self.str_to_int[s] for s in preprocessed]\n        return ids\n        \n    def decode(self, ids):\n        text = \" \".join([self.int_to_str[i] for i in ids])\n        # Replace spaces before the specified punctuations\n        text = re.sub(r'\\s+([,.:;?!\"()\\'])', r'\\1', text)\n        return text\n\nLet’s try to tokenize text with the modified tokenizer:\n\ntokenizer = SimpleTokenizerV2(vocab)\n\ntext1 = \"Hello, do you like tea?\"\ntext2 = \"In the sunlit terraces of the palace.\"\n\ntext = \" &lt;|endoftext|&gt; \".join((text1, text2))\n\nprint(text)\n\nHello, do you like tea? &lt;|endoftext|&gt; In the sunlit terraces of the palace.\n\n\n\ntokenizer.encode(text)\n\n[1131, 5, 355, 1126, 628, 975, 10, 1130, 55, 988, 956, 984, 722, 988, 1131, 7]\n\n\n\ntokenizer.decode(tokenizer.encode(text))\n\n'&lt;|unk|&gt;, do you like tea? &lt;|endoftext|&gt; In the sunlit terraces of the &lt;|unk|&gt;.'"
  },
  {
    "objectID": "posts/LLM-From-Scratch/ch02.html#bytepair-encoding",
    "href": "posts/LLM-From-Scratch/ch02.html#bytepair-encoding",
    "title": "Chapter 2: Working with Text Data",
    "section": "2.5 BytePair encoding",
    "text": "2.5 BytePair encoding\n\nGPT-2 used BytePair encoding (BPE) as its tokenizer\nit allows the model to break down words that aren’t in its predefined vocabulary into smaller subword units or even individual characters, enabling it to handle out-of-vocabulary words\nFor instance, if GPT-2’s vocabulary doesn’t have the word “unfamiliarword,” it might tokenize it as [“unfam”, “iliar”, “word”] or some other subword breakdown, depending on its trained BPE merges\nThe original BPE tokenizer can be found here: https://github.com/openai/gpt-2/blob/master/src/encoder.py\nIn this chapter, we are using the BPE tokenizer from OpenAI’s open-source tiktoken library, which implements its core algorithms in Rust to improve computational performance\nI created a notebook in the ./bytepair_encoder that compares these two implementations side-by-side (tiktoken was about 5x faster on the sample text)\n\n\n# pip install tiktoken\n\n\nimport importlib\nimport tiktoken\n\nprint(\"tiktoken version:\", importlib.metadata.version(\"tiktoken\"))\n\ntiktoken version: 0.7.0\n\n\n\ntokenizer = tiktoken.get_encoding(\"gpt2\")\n\n\ntext = (\n    \"Hello, do you like tea? &lt;|endoftext|&gt; In the sunlit terraces\"\n     \"of someunknownPlace.\"\n)\n\nintegers = tokenizer.encode(text, allowed_special={\"&lt;|endoftext|&gt;\"})\n\nprint(integers)\n\n[15496, 11, 466, 345, 588, 8887, 30, 220, 50256, 554, 262, 4252, 18250, 8812, 2114, 1659, 617, 34680, 27271, 13]\n\n\n\nstrings = tokenizer.decode(integers)\n\nprint(strings)\n\nHello, do you like tea? &lt;|endoftext|&gt; In the sunlit terracesof someunknownPlace.\n\n\n\nBPE tokenizers break down unknown words into subwords and individual characters:"
  },
  {
    "objectID": "posts/LLM-From-Scratch/ch02.html#data-sampling-with-a-sliding-window",
    "href": "posts/LLM-From-Scratch/ch02.html#data-sampling-with-a-sliding-window",
    "title": "Chapter 2: Working with Text Data",
    "section": "2.6 Data sampling with a sliding window",
    "text": "2.6 Data sampling with a sliding window\n\nWe train LLMs to generate one word at a time, so we want to prepare the training data accordingly where the next word in a sequence represents the target to predict:\n\n\n\nwith open(\"the-verdict.txt\", \"r\", encoding=\"utf-8\") as f:\n    raw_text = f.read()\n\nenc_text = tokenizer.encode(raw_text)\nprint(len(enc_text))\n\n5145\n\n\n\nFor each text chunk, we want the inputs and targets\nSince we want the model to predict the next word, the targets are the inputs shifted by one position to the right\n\n\nenc_sample = enc_text[50:]\n\n\ncontext_size = 4\n\nx = enc_sample[:context_size]\ny = enc_sample[1:context_size+1]\n\nprint(f\"x: {x}\")\nprint(f\"y:      {y}\")\n\nx: [290, 4920, 2241, 287]\ny:      [4920, 2241, 287, 257]\n\n\n\nOne by one, the prediction would look like as follows:\n\n\nfor i in range(1, context_size+1):\n    context = enc_sample[:i]\n    desired = enc_sample[i]\n\n    print(context, \"----&gt;\", desired)\n\n[290] ----&gt; 4920\n[290, 4920] ----&gt; 2241\n[290, 4920, 2241] ----&gt; 287\n[290, 4920, 2241, 287] ----&gt; 257\n\n\n\nfor i in range(1, context_size+1):\n    context = enc_sample[:i]\n    desired = enc_sample[i]\n\n    print(tokenizer.decode(context), \"----&gt;\", tokenizer.decode([desired]))\n\n and ----&gt;  established\n and established ----&gt;  himself\n and established himself ----&gt;  in\n and established himself in ----&gt;  a\n\n\n\nWe will take care of the next-word prediction in a later chapter after we covered the attention mechanism\nFor now, we implement a simple data loader that iterates over the input dataset and returns the inputs and targets shifted by one\nInstall and import PyTorch (see Appendix A for installation tips)\n\n\nimport torch\nprint(\"PyTorch version:\", torch.__version__)\n\nPyTorch version: 2.5.1\n\n\n\nWe use a sliding window approach, changing the position by +1:\n\n\n\nCreate dataset and dataloader that extract chunks from the input text dataset\n\n\nfrom torch.utils.data import Dataset, DataLoader\n\n\nclass GPTDatasetV1(Dataset):\n    def __init__(self, txt, tokenizer, max_length, stride):\n        self.input_ids = []\n        self.target_ids = []\n\n        # Tokenize the entire text\n        token_ids = tokenizer.encode(txt, allowed_special={\"&lt;|endoftext|&gt;\"})\n        assert len(token_ids) &gt; max_length, \"Number of tokenized inputs must at least be equal to max_length+1\"\n\n        # Use a sliding window to chunk the book into overlapping sequences of max_length\n        for i in range(0, len(token_ids) - max_length, stride):\n            input_chunk = token_ids[i:i + max_length]\n            target_chunk = token_ids[i + 1: i + max_length + 1]\n            self.input_ids.append(torch.tensor(input_chunk))\n            self.target_ids.append(torch.tensor(target_chunk))\n\n    def __len__(self):\n        return len(self.input_ids)\n\n    def __getitem__(self, idx):\n        return self.input_ids[idx], self.target_ids[idx]\n\n\ndef create_dataloader_v1(txt, batch_size=4, max_length=256, \n                         stride=128, shuffle=True, drop_last=True,\n                         num_workers=0):\n\n    # Initialize the tokenizer\n    tokenizer = tiktoken.get_encoding(\"gpt2\")\n\n    # Create dataset\n    dataset = GPTDatasetV1(txt, tokenizer, max_length, stride)\n\n    # Create dataloader\n    dataloader = DataLoader(\n        dataset,\n        batch_size=batch_size,\n        shuffle=shuffle,\n        drop_last=drop_last,\n        num_workers=num_workers\n    )\n\n    return dataloader\n\n\nLet’s test the dataloader with a batch size of 1 for an LLM with a context size of 4:\n\n\nwith open(\"the-verdict.txt\", \"r\", encoding=\"utf-8\") as f:\n    raw_text = f.read()\n\n\ndataloader = create_dataloader_v1(\n    raw_text, batch_size=1, max_length=4, stride=1, shuffle=False\n)\n\ndata_iter = iter(dataloader)\nfirst_batch = next(data_iter)\nprint(first_batch)\n\n[tensor([[  40,  367, 2885, 1464]]), tensor([[ 367, 2885, 1464, 1807]])]\n\n\n\nsecond_batch = next(data_iter)\nprint(second_batch)\n\n[tensor([[ 367, 2885, 1464, 1807]]), tensor([[2885, 1464, 1807, 3619]])]\n\n\n\nAn example using stride equal to the context length (here: 4) as shown below:\n\n\n\nWe can also create batched outputs\nNote that we increase the stride here so that we don’t have overlaps between the batches, since more overlap could lead to increased overfitting\n\n\ndataloader = create_dataloader_v1(raw_text, batch_size=8, max_length=4, stride=4, shuffle=False)\n\ndata_iter = iter(dataloader)\ninputs, targets = next(data_iter)\nprint(\"Inputs:\\n\", inputs)\nprint(\"\\nTargets:\\n\", targets)\n\nInputs:\n tensor([[   40,   367,  2885,  1464],\n        [ 1807,  3619,   402,   271],\n        [10899,  2138,   257,  7026],\n        [15632,   438,  2016,   257],\n        [  922,  5891,  1576,   438],\n        [  568,   340,   373,   645],\n        [ 1049,  5975,   284,   502],\n        [  284,  3285,   326,    11]])\n\nTargets:\n tensor([[  367,  2885,  1464,  1807],\n        [ 3619,   402,   271, 10899],\n        [ 2138,   257,  7026, 15632],\n        [  438,  2016,   257,   922],\n        [ 5891,  1576,   438,   568],\n        [  340,   373,   645,  1049],\n        [ 5975,   284,   502,   284],\n        [ 3285,   326,    11,   287]])"
  },
  {
    "objectID": "posts/LLM-From-Scratch/ch02.html#creating-token-embeddings",
    "href": "posts/LLM-From-Scratch/ch02.html#creating-token-embeddings",
    "title": "Chapter 2: Working with Text Data",
    "section": "2.7 Creating token embeddings",
    "text": "2.7 Creating token embeddings\n\nThe data is already almost ready for an LLM\nBut lastly let us embed the tokens in a continuous vector representation using an embedding layer\nUsually, these embedding layers are part of the LLM itself and are updated (trained) during model training\n\n\n\nSuppose we have the following four input examples with input ids 2, 3, 5, and 1 (after tokenization):\n\n\ninput_ids = torch.tensor([2, 3, 5, 1])\n\n\nFor the sake of simplicity, suppose we have a small vocabulary of only 6 words and we want to create embeddings of size 3:\n\n\nvocab_size = 6\noutput_dim = 3\n\ntorch.manual_seed(123)\nembedding_layer = torch.nn.Embedding(vocab_size, output_dim)\n\n\nThis would result in a 6x3 weight matrix:\n\n\nprint(embedding_layer.weight)\n\nParameter containing:\ntensor([[ 0.3374, -0.1778, -0.1690],\n        [ 0.9178,  1.5810,  1.3010],\n        [ 1.2753, -0.2010, -0.1606],\n        [-0.4015,  0.9666, -1.1481],\n        [-1.1589,  0.3255, -0.6315],\n        [-2.8400, -0.7849, -1.4096]], requires_grad=True)\n\n\n\nFor those who are familiar with one-hot encoding, the embedding layer approach above is essentially just a more efficient way of implementing one-hot encoding followed by matrix multiplication in a fully-connected layer, which is described in the supplementary code in ./embedding_vs_matmul\nBecause the embedding layer is just a more efficient implementation that is equivalent to the one-hot encoding and matrix-multiplication approach it can be seen as a neural network layer that can be optimized via backpropagation\nTo convert a token with id 3 into a 3-dimensional vector, we do the following:\n\n\nprint(embedding_layer(torch.tensor([3])))\n\ntensor([[-0.4015,  0.9666, -1.1481]], grad_fn=&lt;EmbeddingBackward0&gt;)\n\n\n\nNote that the above is the 4th row in the embedding_layer weight matrix\nTo embed all four input_ids values above, we do\n\n\nprint(embedding_layer(input_ids))\n\ntensor([[ 1.2753, -0.2010, -0.1606],\n        [-0.4015,  0.9666, -1.1481],\n        [-2.8400, -0.7849, -1.4096],\n        [ 0.9178,  1.5810,  1.3010]], grad_fn=&lt;EmbeddingBackward0&gt;)\n\n\n\nAn embedding layer is essentially a look-up operation:\n\n\n\nYou may be interested in the bonus content comparing embedding layers with regular linear layers: ../03_bonus_embedding-vs-matmul"
  },
  {
    "objectID": "posts/LLM-From-Scratch/ch02.html#encoding-word-positions",
    "href": "posts/LLM-From-Scratch/ch02.html#encoding-word-positions",
    "title": "Chapter 2: Working with Text Data",
    "section": "2.8 Encoding word positions",
    "text": "2.8 Encoding word positions\n\nEmbedding layer convert IDs into identical vector representations regardless of where they are located in the input sequence:\n\n\n\nPositional embeddings are combined with the token embedding vector to form the input embeddings for a large language model:\n\n\n\nThe BytePair encoder has a vocabulary size of 50,257:\nSuppose we want to encode the input tokens into a 256-dimensional vector representation:\n\n\nvocab_size = 50257\noutput_dim = 256\n\ntoken_embedding_layer = torch.nn.Embedding(vocab_size, output_dim)\n\n\nIf we sample data from the dataloader, we embed the tokens in each batch into a 256-dimensional vector\nIf we have a batch size of 8 with 4 tokens each, this results in a 8 x 4 x 256 tensor:\n\n\nmax_length = 4\ndataloader = create_dataloader_v1(\n    raw_text, batch_size=8, max_length=max_length,\n    stride=max_length, shuffle=False\n)\ndata_iter = iter(dataloader)\ninputs, targets = next(data_iter)\n\n\nprint(\"Token IDs:\\n\", inputs)\nprint(\"\\nInputs shape:\\n\", inputs.shape)\n\nToken IDs:\n tensor([[   40,   367,  2885,  1464],\n        [ 1807,  3619,   402,   271],\n        [10899,  2138,   257,  7026],\n        [15632,   438,  2016,   257],\n        [  922,  5891,  1576,   438],\n        [  568,   340,   373,   645],\n        [ 1049,  5975,   284,   502],\n        [  284,  3285,   326,    11]])\n\nInputs shape:\n torch.Size([8, 4])\n\n\n\ntoken_embeddings = token_embedding_layer(inputs)\nprint(token_embeddings.shape)\n\n# uncomment & execute the following line to see how the embeddings look like\n# print(token_embeddings)\n\ntorch.Size([8, 4, 256])\n\n\n\nGPT-2 uses absolute position embeddings, so we just create another embedding layer:\n\n\ncontext_length = max_length\npos_embedding_layer = torch.nn.Embedding(context_length, output_dim)\n\n# uncomment & execute the following line to see how the embedding layer weights look like\n# print(pos_embedding_layer.weight)\n\n\npos_embeddings = pos_embedding_layer(torch.arange(max_length))\nprint(pos_embeddings.shape)\n\n# uncomment & execute the following line to see how the embeddings look like\n# print(pos_embeddings)\n\ntorch.Size([4, 256])\n\n\n\nTo create the input embeddings used in an LLM, we simply add the token and the positional embeddings:\n\n\ninput_embeddings = token_embeddings + pos_embeddings\nprint(input_embeddings.shape)\n\n# uncomment & execute the following line to see how the embeddings look like\n# print(input_embeddings)\n\ntorch.Size([8, 4, 256])\n\n\n\nIn the initial phase of the input processing workflow, the input text is segmented into separate tokens\nFollowing this segmentation, these tokens are transformed into token IDs based on a predefined vocabulary:"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#the-problem-with-modeling-long-sequences",
    "href": "posts/LLM-From-Scratch/index.html#the-problem-with-modeling-long-sequences",
    "title": "LLM From Scratch",
    "section": "3.1 The problem with modeling long sequences",
    "text": "3.1 The problem with modeling long sequences\n\nNo code in this section\nTranslating a text word by word isn’t feasible due to the differences in grammatical structures between the source and target languages:\n\n\n\nPrior to the introduction of transformer models, encoder-decoder RNNs were commonly used for machine translation tasks\nIn this setup, the encoder processes a sequence of tokens from the source language, using a hidden state—a kind of intermediate layer within the neural network—to generate a condensed representation of the entire input sequence:"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#capturing-data-dependencies-with-attention-mechanisms",
    "href": "posts/LLM-From-Scratch/index.html#capturing-data-dependencies-with-attention-mechanisms",
    "title": "LLM From Scratch",
    "section": "3.2 Capturing data dependencies with attention mechanisms",
    "text": "3.2 Capturing data dependencies with attention mechanisms\n\nNo code in this section\nThrough an attention mechanism, the text-generating decoder segment of the network is capable of selectively accessing all input tokens, implying that certain input tokens hold more significance than others in the generation of a specific output token:\n\n\n\nSelf-attention in transformers is a technique designed to enhance input representations by enabling each position in a sequence to engage with and determine the relevance of every other position within the same sequence"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#attending-to-different-parts-of-the-input-with-self-attention",
    "href": "posts/LLM-From-Scratch/index.html#attending-to-different-parts-of-the-input-with-self-attention",
    "title": "LLM From Scratch",
    "section": "3.3 Attending to different parts of the input with self-attention",
    "text": "3.3 Attending to different parts of the input with self-attention\n\n3.3.1 A simple self-attention mechanism without trainable weights\n\nThis section explains a very simplified variant of self-attention, which does not contain any trainable weights\nThis is purely for illustration purposes and NOT the attention mechanism that is used in transformers\nThe next section, section 3.3.2, will extend this simple attention mechanism to implement the real self-attention mechanism\nSuppose we are given an input sequence \\(x^{(1)}\\) to \\(x^{(T)}\\)\n\nThe input is a text (for example, a sentence like “Your journey starts with one step”) that has already been converted into token embeddings as described in chapter 2\nFor instance, \\(x^{(1)}\\) is a d-dimensional vector representing the word “Your”, and so forth\n\nGoal: compute context vectors \\(z^{(i)}\\) for each input sequence element \\(x^{(i)}\\) in \\(x^{(1)}\\) to \\(x^{(T)}\\) (where \\(z\\) and \\(x\\) have the same dimension)\n\nA context vector \\(z^{(i)}\\) is a weighted sum over the inputs \\(x^{(1)}\\) to \\(x^{(T)}\\)\nThe context vector is “context”-specific to a certain input\n\nInstead of \\(x^{(i)}\\) as a placeholder for an arbitrary input token, let’s consider the second input, \\(x^{(2)}\\)\nAnd to continue with a concrete example, instead of the placeholder \\(z^{(i)}\\), we consider the second output context vector, \\(z^{(2)}\\)\nThe second context vector, \\(z^{(2)}\\), is a weighted sum over all inputs \\(x^{(1)}\\) to \\(x^{(T)}\\) weighted with respect to the second input element, \\(x^{(2)}\\)\nThe attention weights are the weights that determine how much each of the input elements contributes to the weighted sum when computing \\(z^{(2)}\\)\nIn short, think of \\(z^{(2)}\\) as a modified version of \\(x^{(2)}\\) that also incorporates information about all other input elements that are relevant to a given task at hand\n\n\n\n\n\n(Please note that the numbers in this figure are truncated to one digit after the decimal point to reduce visual clutter; similarly, other figures may also contain truncated values)\nBy convention, the unnormalized attention weights are referred to as “attention scores” whereas the normalized attention scores, which sum to 1, are referred to as “attention weights”\nThe code below walks through the figure above step by step\n\n\n\nStep 1: compute unnormalized attention scores \\(\\omega\\)\nSuppose we use the second input token as the query, that is, \\(q^{(2)} = x^{(2)}\\), we compute the unnormalized attention scores via dot products:\n\n\\(\\omega_{21} = x^{(1)} q^{(2)\\top}\\)\n\\(\\omega_{22} = x^{(2)} q^{(2)\\top}\\)\n\\(\\omega_{23} = x^{(3)} q^{(2)\\top}\\)\n…\n\\(\\omega_{2T} = x^{(T)} q^{(2)\\top}\\)\n\nAbove, \\(\\omega\\) is the Greek letter “omega” used to symbolize the unnormalized attention scores\n\nThe subscript “21” in \\(\\omega_{21}\\) means that input sequence element 2 was used as a query against input sequence element 1\n\nSuppose we have the following input sentence that is already embedded in 3-dimensional vectors as described in chapter 3 (we use a very small embedding dimension here for illustration purposes, so that it fits onto the page without line breaks):\n(In this book, we follow the common machine learning and deep learning convention where training examples are represented as rows and feature values as columns; in the case of the tensor shown above, each row represents a word, and each column represents an embedding dimension)\nThe primary objective of this section is to demonstrate how the context vector \\(z^{(2)}\\) is calculated using the second input sequence, \\(x^{(2)}\\), as a query\nThe figure depicts the initial step in this process, which involves calculating the attention scores ω between \\(x^{(2)}\\) and all other input elements through a dot product operation\n\n\n\nWe use input sequence element 2, \\(x^{(2)}\\), as an example to compute context vector \\(z^{(2)}\\); later in this section, we will generalize this to compute all context vectors.\nThe first step is to compute the unnormalized attention scores by computing the dot product between the query \\(x^{(2)}\\) and all other input tokens:\n\n\n\ntensor([0.9544, 1.4950, 1.4754, 0.8434, 0.7070, 1.0865])\n\n\n\nSide note: a dot product is essentially a shorthand for multiplying two vectors elements-wise and summing the resulting products:\n\n\n\ntensor(0.9544)\ntensor(0.9544)\n\n\n\nStep 2: normalize the unnormalized attention scores (“omegas”, \\(\\omega\\)) so that they sum up to 1\nHere is a simple way to normalize the unnormalized attention scores to sum up to 1 (a convention, useful for interpretation, and important for training stability):\n\n\n\n\nAttention weights: tensor([0.1455, 0.2278, 0.2249, 0.1285, 0.1077, 0.1656])\nSum: tensor(1.0000)\n\n\n\nHowever, in practice, using the softmax function for normalization, which is better at handling extreme values and has more desirable gradient properties during training, is common and recommended.\nHere’s a naive implementation of a softmax function for scaling, which also normalizes the vector elements such that they sum up to 1:\n\n\n\nAttention weights: tensor([0.1385, 0.2379, 0.2333, 0.1240, 0.1082, 0.1581])\nSum: tensor(1.)\n\n\n\nThe naive implementation above can suffer from numerical instability issues for large or small input values due to overflow and underflow issues\nHence, in practice, it’s recommended to use the PyTorch implementation of softmax instead, which has been highly optimized for performance:\n\n\n\nAttention weights: tensor([0.1385, 0.2379, 0.2333, 0.1240, 0.1082, 0.1581])\nSum: tensor(1.)\n\n\n\nStep 3: compute the context vector \\(z^{(2)}\\) by multiplying the embedded input tokens, \\(x^{(i)}\\) with the attention weights and sum the resulting vectors:\n\n\n\n\ntensor([0.4419, 0.6515, 0.5683])\n\n\n\n\n3.3.2 Computing attention weights for all input tokens\n\nGeneralize to all input sequence tokens:\n\nAbove, we computed the attention weights and context vector for input 2 (as illustrated in the highlighted row in the figure below)\nNext, we are generalizing this computation to compute all attention weights and context vectors\n\n\n\n(Please note that the numbers in this figure are truncated to two digits after the decimal point to reduce visual clutter; the values in each row should add up to 1.0 or 100%; similarly, digits in other figures are truncated)\nIn self-attention, the process starts with the calculation of attention scores, which are subsequently normalized to derive attention weights that total 1\nThese attention weights are then utilized to generate the context vectors through a weighted summation of the inputs\n\n\n\nApply previous step 1 to all pairwise elements to compute the unnormalized attention score matrix:\n\n\n\ntensor([[0.9995, 0.9544, 0.9422, 0.4753, 0.4576, 0.6310],\n        [0.9544, 1.4950, 1.4754, 0.8434, 0.7070, 1.0865],\n        [0.9422, 1.4754, 1.4570, 0.8296, 0.7154, 1.0605],\n        [0.4753, 0.8434, 0.8296, 0.4937, 0.3474, 0.6565],\n        [0.4576, 0.7070, 0.7154, 0.3474, 0.6654, 0.2935],\n        [0.6310, 1.0865, 1.0605, 0.6565, 0.2935, 0.9450]])\n\n\n\nWe can achieve the same as above more efficiently via matrix multiplication:\n\n\n\ntensor([[0.9995, 0.9544, 0.9422, 0.4753, 0.4576, 0.6310],\n        [0.9544, 1.4950, 1.4754, 0.8434, 0.7070, 1.0865],\n        [0.9422, 1.4754, 1.4570, 0.8296, 0.7154, 1.0605],\n        [0.4753, 0.8434, 0.8296, 0.4937, 0.3474, 0.6565],\n        [0.4576, 0.7070, 0.7154, 0.3474, 0.6654, 0.2935],\n        [0.6310, 1.0865, 1.0605, 0.6565, 0.2935, 0.9450]])\n\n\n\nSimilar to step 2 previously, we normalize each row so that the values in each row sum to 1:\n\n\n\ntensor([[0.2098, 0.2006, 0.1981, 0.1242, 0.1220, 0.1452],\n        [0.1385, 0.2379, 0.2333, 0.1240, 0.1082, 0.1581],\n        [0.1390, 0.2369, 0.2326, 0.1242, 0.1108, 0.1565],\n        [0.1435, 0.2074, 0.2046, 0.1462, 0.1263, 0.1720],\n        [0.1526, 0.1958, 0.1975, 0.1367, 0.1879, 0.1295],\n        [0.1385, 0.2184, 0.2128, 0.1420, 0.0988, 0.1896]])\n\n\n\nQuick verification that the values in each row indeed sum to 1:\n\n\n\nRow 2 sum: 1.0\nAll row sums: tensor([1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000])\n\n\n\nApply previous step 3 to compute all context vectors:\n\n\n\ntensor([[0.4421, 0.5931, 0.5790],\n        [0.4419, 0.6515, 0.5683],\n        [0.4431, 0.6496, 0.5671],\n        [0.4304, 0.6298, 0.5510],\n        [0.4671, 0.5910, 0.5266],\n        [0.4177, 0.6503, 0.5645]])\n\n\n\nAs a sanity check, the previously computed context vector \\(z^{(2)} = [0.4419, 0.6515, 0.5683]\\) can be found in the 2nd row in above:\n\n\n\nPrevious 2nd context vector: tensor([0.4419, 0.6515, 0.5683])"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#implementing-self-attention-with-trainable-weights",
    "href": "posts/LLM-From-Scratch/index.html#implementing-self-attention-with-trainable-weights",
    "title": "LLM From Scratch",
    "section": "3.4 Implementing self-attention with trainable weights",
    "text": "3.4 Implementing self-attention with trainable weights\n\nA conceptual framework illustrating how the self-attention mechanism developed in this section integrates into the overall narrative and structure of this book and chapter\n\n\n\n3.4.1 Computing the attention weights step by step\n\nIn this section, we are implementing the self-attention mechanism that is used in the original transformer architecture, the GPT models, and most other popular LLMs\nThis self-attention mechanism is also called “scaled dot-product attention”\nThe overall idea is similar to before:\n\nWe want to compute context vectors as weighted sums over the input vectors specific to a certain input element\nFor the above, we need attention weights\n\nAs you will see, there are only slight differences compared to the basic attention mechanism introduced earlier:\n\nThe most notable difference is the introduction of weight matrices that are updated during model training\nThese trainable weight matrices are crucial so that the model (specifically, the attention module inside the model) can learn to produce “good” context vectors\n\n\n\n\nImplementing the self-attention mechanism step by step, we will start by introducing the three training weight matrices \\(W_q\\), \\(W_k\\), and \\(W_v\\)\nThese three matrices are used to project the embedded input tokens, \\(x^{(i)}\\), into query, key, and value vectors via matrix multiplication:\n\nQuery vector: $q^{(i)} = x^{(i)},W_q $\nKey vector: $k^{(i)} = x^{(i)},W_k $\nValue vector: $v^{(i)} = x^{(i)},W_v $\n\nThe embedding dimensions of the input \\(x\\) and the query vector \\(q\\) can be the same or different, depending on the model’s design and specific implementation\nIn GPT models, the input and output dimensions are usually the same, but for illustration purposes, to better follow the computation, we choose different input and output dimensions here:\nBelow, we initialize the three weight matrices; note that we are setting requires_grad=False to reduce clutter in the outputs for illustration purposes, but if we were to use the weight matrices for model training, we would set requires_grad=True to update these matrices during model training\nNext we compute the query, key, and value vectors:\n\n\n\ntensor([0.4306, 1.4551])\n\n\n\nAs we can see below, we successfully projected the 6 input tokens from a 3D onto a 2D embedding space:\n\n\n\nkeys.shape: torch.Size([6, 2])\nvalues.shape: torch.Size([6, 2])\n\n\n\nIn the next step, step 2, we compute the unnormalized attention scores by computing the dot product between the query and each key vector:\n\n\n\n\ntensor(1.8524)\n\n\n\nSince we have 6 inputs, we have 6 attention scores for the given query vector:\n\n\n\ntensor([1.2705, 1.8524, 1.8111, 1.0795, 0.5577, 1.5440])\n\n\n\n\nNext, in step 3, we compute the attention weights (normalized attention scores that sum up to 1) using the softmax function we used earlier\nThe difference to earlier is that we now scale the attention scores by dividing them by the square root of the embedding dimension, \\(\\sqrt{d_k}\\) (i.e., d_k**0.5):\n\n\n\ntensor([0.1500, 0.2264, 0.2199, 0.1311, 0.0906, 0.1820])\n\n\n\n\nIn step 4, we now compute the context vector for input query vector 2:\n\n\n\ntensor([0.3061, 0.8210])\n\n\n\n\n3.4.2 Implementing a compact SelfAttention class\n\nPutting it all together, we can implement the self-attention mechanism as follows:\n\n\n\ntensor([[0.2996, 0.8053],\n        [0.3061, 0.8210],\n        [0.3058, 0.8203],\n        [0.2948, 0.7939],\n        [0.2927, 0.7891],\n        [0.2990, 0.8040]], grad_fn=&lt;MmBackward0&gt;)\n\n\n\n\nWe can streamline the implementation above using PyTorch’s Linear layers, which are equivalent to a matrix multiplication if we disable the bias units\nAnother big advantage of using nn.Linear over our manual nn.Parameter(torch.rand(...) approach is that nn.Linear has a preferred weight initialization scheme, which leads to more stable model training\n\n\n\ntensor([[-0.0739,  0.0713],\n        [-0.0748,  0.0703],\n        [-0.0749,  0.0702],\n        [-0.0760,  0.0685],\n        [-0.0763,  0.0679],\n        [-0.0754,  0.0693]], grad_fn=&lt;MmBackward0&gt;)\n\n\n\nNote that SelfAttention_v1 and SelfAttention_v2 give different outputs because they use different initial weights for the weight matrices"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#hiding-future-words-with-causal-attention",
    "href": "posts/LLM-From-Scratch/index.html#hiding-future-words-with-causal-attention",
    "title": "LLM From Scratch",
    "section": "3.5 Hiding future words with causal attention",
    "text": "3.5 Hiding future words with causal attention\n\nIn causal attention, the attention weights above the diagonal are masked, ensuring that for any given input, the LLM is unable to utilize future tokens while calculating the context vectors with the attention weight\n\n\n\n3.5.1 Applying a causal attention mask\n\nIn this section, we are converting the previous self-attention mechanism into a causal self-attention mechanism\nCausal self-attention ensures that the model’s prediction for a certain position in a sequence is only dependent on the known outputs at previous positions, not on future positions\nIn simpler words, this ensures that each next word prediction should only depend on the preceding words\nTo achieve this, for each given token, we mask out the future tokens (the ones that come after the current token in the input text):\n\n\n\nTo illustrate and implement causal self-attention, let’s work with the attention scores and weights from the previous section:\n\n\n\ntensor([[0.1921, 0.1646, 0.1652, 0.1550, 0.1721, 0.1510],\n        [0.2041, 0.1659, 0.1662, 0.1496, 0.1665, 0.1477],\n        [0.2036, 0.1659, 0.1662, 0.1498, 0.1664, 0.1480],\n        [0.1869, 0.1667, 0.1668, 0.1571, 0.1661, 0.1564],\n        [0.1830, 0.1669, 0.1670, 0.1588, 0.1658, 0.1585],\n        [0.1935, 0.1663, 0.1666, 0.1542, 0.1666, 0.1529]],\n       grad_fn=&lt;SoftmaxBackward0&gt;)\n\n\n\nThe simplest way to mask out future attention weights is by creating a mask via PyTorch’s tril function with elements below the main diagonal (including the diagonal itself) set to 1 and above the main diagonal set to 0:\n\n\n\ntensor([[1., 0., 0., 0., 0., 0.],\n        [1., 1., 0., 0., 0., 0.],\n        [1., 1., 1., 0., 0., 0.],\n        [1., 1., 1., 1., 0., 0.],\n        [1., 1., 1., 1., 1., 0.],\n        [1., 1., 1., 1., 1., 1.]])\n\n\n\nThen, we can multiply the attention weights with this mask to zero out the attention scores above the diagonal:\n\n\n\ntensor([[0.1921, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n        [0.2041, 0.1659, 0.0000, 0.0000, 0.0000, 0.0000],\n        [0.2036, 0.1659, 0.1662, 0.0000, 0.0000, 0.0000],\n        [0.1869, 0.1667, 0.1668, 0.1571, 0.0000, 0.0000],\n        [0.1830, 0.1669, 0.1670, 0.1588, 0.1658, 0.0000],\n        [0.1935, 0.1663, 0.1666, 0.1542, 0.1666, 0.1529]],\n       grad_fn=&lt;MulBackward0&gt;)\n\n\n\nHowever, if the mask were applied after softmax, like above, it would disrupt the probability distribution created by softmax\nSoftmax ensures that all output values sum to 1\nMasking after softmax would require re-normalizing the outputs to sum to 1 again, which complicates the process and might lead to unintended effects\nTo make sure that the rows sum to 1, we can normalize the attention weights as follows:\n\n\n\ntensor([[1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n        [0.5517, 0.4483, 0.0000, 0.0000, 0.0000, 0.0000],\n        [0.3800, 0.3097, 0.3103, 0.0000, 0.0000, 0.0000],\n        [0.2758, 0.2460, 0.2462, 0.2319, 0.0000, 0.0000],\n        [0.2175, 0.1983, 0.1984, 0.1888, 0.1971, 0.0000],\n        [0.1935, 0.1663, 0.1666, 0.1542, 0.1666, 0.1529]],\n       grad_fn=&lt;DivBackward0&gt;)\n\n\n\nWhile we are technically done with coding the causal attention mechanism now, let’s briefly look at a more efficient approach to achieve the same as above\nSo, instead of zeroing out attention weights above the diagonal and renormalizing the results, we can mask the unnormalized attention scores above the diagonal with negative infinity before they enter the softmax function:\n\n\n\n\ntensor([[0.2899,   -inf,   -inf,   -inf,   -inf,   -inf],\n        [0.4656, 0.1723,   -inf,   -inf,   -inf,   -inf],\n        [0.4594, 0.1703, 0.1731,   -inf,   -inf,   -inf],\n        [0.2642, 0.1024, 0.1036, 0.0186,   -inf,   -inf],\n        [0.2183, 0.0874, 0.0882, 0.0177, 0.0786,   -inf],\n        [0.3408, 0.1270, 0.1290, 0.0198, 0.1290, 0.0078]],\n       grad_fn=&lt;MaskedFillBackward0&gt;)\n\n\n\nAs we can see below, now the attention weights in each row correctly sum to 1 again:\n\n\n\ntensor([[1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n        [0.5517, 0.4483, 0.0000, 0.0000, 0.0000, 0.0000],\n        [0.3800, 0.3097, 0.3103, 0.0000, 0.0000, 0.0000],\n        [0.2758, 0.2460, 0.2462, 0.2319, 0.0000, 0.0000],\n        [0.2175, 0.1983, 0.1984, 0.1888, 0.1971, 0.0000],\n        [0.1935, 0.1663, 0.1666, 0.1542, 0.1666, 0.1529]],\n       grad_fn=&lt;SoftmaxBackward0&gt;)\n\n\n\n\n3.5.2 Masking additional attention weights with dropout\n\nIn addition, we also apply dropout to reduce overfitting during training\nDropout can be applied in several places:\n\nfor example, after computing the attention weights;\nor after multiplying the attention weights with the value vectors\n\nHere, we will apply the dropout mask after computing the attention weights because it’s more common\nFurthermore, in this specific example, we use a dropout rate of 50%, which means randomly masking out half of the attention weights. (When we train the GPT model later, we will use a lower dropout rate, such as 0.1 or 0.2\n\n\n\nIf we apply a dropout rate of 0.5 (50%), the non-dropped values will be scaled accordingly by a factor of 1/0.5 = 2\nThe scaling is calculated by the formula 1 / (1 - dropout_rate)\n\n\n\ntensor([[2., 2., 0., 2., 2., 0.],\n        [0., 0., 0., 2., 0., 2.],\n        [2., 2., 2., 2., 0., 2.],\n        [0., 2., 2., 0., 0., 2.],\n        [0., 2., 0., 2., 0., 2.],\n        [0., 2., 2., 2., 2., 0.]])\n\n\n\n\ntensor([[2.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n        [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n        [0.7599, 0.6194, 0.6206, 0.0000, 0.0000, 0.0000],\n        [0.0000, 0.4921, 0.4925, 0.0000, 0.0000, 0.0000],\n        [0.0000, 0.3966, 0.0000, 0.3775, 0.0000, 0.0000],\n        [0.0000, 0.3327, 0.3331, 0.3084, 0.3331, 0.0000]],\n       grad_fn=&lt;MulBackward0&gt;)\n\n\n\nNote that the resulting dropout outputs may look different depending on your operating system; you can read more about this inconsistency here on the PyTorch issue tracker\n\n\n\n3.5.3 Implementing a compact causal self-attention class\n\nNow, we are ready to implement a working implementation of self-attention, including the causal and dropout masks\nOne more thing is to implement the code to handle batches consisting of more than one input so that our CausalAttention class supports the batch outputs produced by the data loader we implemented in chapter 2\nFor simplicity, to simulate such batch input, we duplicate the input text example:\n\n\n\ntorch.Size([2, 6, 3])\n\n\n\n\ntensor([[[-0.4519,  0.2216],\n         [-0.5874,  0.0058],\n         [-0.6300, -0.0632],\n         [-0.5675, -0.0843],\n         [-0.5526, -0.0981],\n         [-0.5299, -0.1081]],\n\n        [[-0.4519,  0.2216],\n         [-0.5874,  0.0058],\n         [-0.6300, -0.0632],\n         [-0.5675, -0.0843],\n         [-0.5526, -0.0981],\n         [-0.5299, -0.1081]]], grad_fn=&lt;UnsafeViewBackward0&gt;)\ncontext_vecs.shape: torch.Size([2, 6, 2])\n\n\n\nNote that dropout is only applied during training, not during inference"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#extending-single-head-attention-to-multi-head-attention",
    "href": "posts/LLM-From-Scratch/index.html#extending-single-head-attention-to-multi-head-attention",
    "title": "LLM From Scratch",
    "section": "3.6 Extending single-head attention to multi-head attention",
    "text": "3.6 Extending single-head attention to multi-head attention\n\n3.6.1 Stacking multiple single-head attention layers\n\nBelow is a summary of the self-attention implemented previously (causal and dropout masks not shown for simplicity)\nThis is also called single-head attention:\n\n\n\nWe simply stack multiple single-head attention modules to obtain a multi-head attention module:\n\n\n\nThe main idea behind multi-head attention is to run the attention mechanism multiple times (in parallel) with different, learned linear projections. This allows the model to jointly attend to information from different representation subspaces at different positions.\n\n\n\ntensor([[[-0.4519,  0.2216,  0.4772,  0.1063],\n         [-0.5874,  0.0058,  0.5891,  0.3257],\n         [-0.6300, -0.0632,  0.6202,  0.3860],\n         [-0.5675, -0.0843,  0.5478,  0.3589],\n         [-0.5526, -0.0981,  0.5321,  0.3428],\n         [-0.5299, -0.1081,  0.5077,  0.3493]],\n\n        [[-0.4519,  0.2216,  0.4772,  0.1063],\n         [-0.5874,  0.0058,  0.5891,  0.3257],\n         [-0.6300, -0.0632,  0.6202,  0.3860],\n         [-0.5675, -0.0843,  0.5478,  0.3589],\n         [-0.5526, -0.0981,  0.5321,  0.3428],\n         [-0.5299, -0.1081,  0.5077,  0.3493]]], grad_fn=&lt;CatBackward0&gt;)\ncontext_vecs.shape: torch.Size([2, 6, 4])\n\n\n\nIn the implementation above, the embedding dimension is 4, because we d_out=2 as the embedding dimension for the key, query, and value vectors as well as the context vector. And since we have 2 attention heads, we have the output embedding dimension 2*2=4\n\n\n\n3.6.2 Implementing multi-head attention with weight splits\n\nWhile the above is an intuitive and fully functional implementation of multi-head attention (wrapping the single-head attention CausalAttention implementation from earlier), we can write a stand-alone class called MultiHeadAttention to achieve the same\nWe don’t concatenate single attention heads for this stand-alone MultiHeadAttention class\nInstead, we create single W_query, W_key, and W_value weight matrices and then split those into individual matrices for each attention head:\n\n\n\ntensor([[[0.3190, 0.4858],\n         [0.2943, 0.3897],\n         [0.2856, 0.3593],\n         [0.2693, 0.3873],\n         [0.2639, 0.3928],\n         [0.2575, 0.4028]],\n\n        [[0.3190, 0.4858],\n         [0.2943, 0.3897],\n         [0.2856, 0.3593],\n         [0.2693, 0.3873],\n         [0.2639, 0.3928],\n         [0.2575, 0.4028]]], grad_fn=&lt;ViewBackward0&gt;)\ncontext_vecs.shape: torch.Size([2, 6, 2])\n\n\n\nNote that the above is essentially a rewritten version of MultiHeadAttentionWrapper that is more efficient\nThe resulting output looks a bit different since the random weight initializations differ, but both are fully functional implementations that can be used in the GPT class we will implement in the upcoming chapters\nNote that in addition, we added a linear projection layer (self.out_proj) to the MultiHeadAttention class above. This is simply a linear transformation that doesn’t change the dimensions. It’s a standard convention to use such a projection layer in LLM implementation, but it’s not strictly necessary (recent research has shown that it can be removed without affecting the modeling performance; see the further reading section at the end of this chapter)\n\n\n\nNote that if you are interested in a compact and efficient implementation of the above, you can also consider the torch.nn.MultiheadAttention class in PyTorch\nSince the above implementation may look a bit complex at first glance, let’s look at what happens when executing attn_scores = queries @ keys.transpose(2, 3):\n\n\n\ntensor([[[[1.3208, 1.1631, 1.2879],\n          [1.1631, 2.2150, 1.8424],\n          [1.2879, 1.8424, 2.0402]],\n\n         [[0.4391, 0.7003, 0.5903],\n          [0.7003, 1.3737, 1.0620],\n          [0.5903, 1.0620, 0.9912]]]])\n\n\n\nIn this case, the matrix multiplication implementation in PyTorch will handle the 4-dimensional input tensor so that the matrix multiplication is carried out between the 2 last dimensions (num_tokens, head_dim) and then repeated for the individual heads\nFor instance, the following becomes a more compact way to compute the matrix multiplication for each head separately:\n\n\n\nFirst head:\n tensor([[1.3208, 1.1631, 1.2879],\n        [1.1631, 2.2150, 1.8424],\n        [1.2879, 1.8424, 2.0402]])\n\nSecond head:\n tensor([[0.4391, 0.7003, 0.5903],\n        [0.7003, 1.3737, 1.0620],\n        [0.5903, 1.0620, 0.9912]])"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#coding-an-llm-architecture",
    "href": "posts/LLM-From-Scratch/index.html#coding-an-llm-architecture",
    "title": "LLM From Scratch",
    "section": "4.1 Coding an LLM architecture",
    "text": "4.1 Coding an LLM architecture\n\nChapter 1 discussed models like GPT and Llama, which generate words sequentially and are based on the decoder part of the original transformer architecture\nTherefore, these LLMs are often referred to as “decoder-like” LLMs\nCompared to conventional deep learning models, LLMs are larger, mainly due to their vast number of parameters, not the amount of code\nWe’ll see that many elements are repeated in an LLM’s architecture\n\n\n\nIn previous chapters, we used small embedding dimensions for token inputs and outputs for ease of illustration, ensuring they fit on a single page\nIn this chapter, we consider embedding and model sizes akin to a small GPT-2 model\nWe’ll specifically code the architecture of the smallest GPT-2 model (124 million parameters), as outlined in Radford et al.’s Language Models are Unsupervised Multitask Learners (note that the initial report lists it as 117M parameters, but this was later corrected in the model weight repository)\nChapter 6 will show how to load pretrained weights into our implementation, which will be compatible with model sizes of 345, 762, and 1542 million parameters\nConfiguration details for the 124 million parameter GPT-2 model include:\nWe use short variable names to avoid long lines of code later\n\"vocab_size\" indicates a vocabulary size of 50,257 words, supported by the BPE tokenizer discussed in Chapter 2\n\"context_length\" represents the model’s maximum input token count, as enabled by positional embeddings covered in Chapter 2\n\"emb_dim\" is the embedding size for token inputs, converting each input token into a 768-dimensional vector\n\"n_heads\" is the number of attention heads in the multi-head attention mechanism implemented in Chapter 3\n\"n_layers\" is the number of transformer blocks within the model, which we’ll implement in upcoming sections\n\"drop_rate\" is the dropout mechanism’s intensity, discussed in Chapter 3; 0.1 means dropping 10% of hidden units during training to mitigate overfitting\n\"qkv_bias\" decides if the Linear layers in the multi-head attention mechanism (from Chapter 3) should include a bias vector when computing query (Q), key (K), and value (V) tensors; we’ll disable this option, which is standard practice in modern LLMs; however, we’ll revisit this later when loading pretrained GPT-2 weights from OpenAI into our reimplementation in chapter 5\n\n\n\n\n\ntensor([[6109, 3626, 6100,  345],\n        [6109, 1110, 6622,  257]])\n\n\n\n\nOutput shape: torch.Size([2, 4, 50257])\ntensor([[[-1.2034,  0.3201, -0.7130,  ..., -1.5548, -0.2390, -0.4667],\n         [-0.1192,  0.4539, -0.4432,  ...,  0.2392,  1.3469,  1.2430],\n         [ 0.5307,  1.6720, -0.4695,  ...,  1.1966,  0.0111,  0.5835],\n         [ 0.0139,  1.6754, -0.3388,  ...,  1.1586, -0.0435, -1.0400]],\n\n        [[-1.0908,  0.1798, -0.9484,  ..., -1.6047,  0.2439, -0.4530],\n         [-0.7860,  0.5581, -0.0610,  ...,  0.4835, -0.0077,  1.6621],\n         [ 0.3567,  1.2698, -0.6398,  ..., -0.0162, -0.1296,  0.3717],\n         [-0.2407, -0.7349, -0.5102,  ...,  2.0057, -0.3694,  0.1814]]],\n       grad_fn=&lt;UnsafeViewBackward0&gt;)\n\n\n\nNote\n\nIf you are running this code on Windows or Linux, the resulting values above may look like as follows:\n\nOutput shape: torch.Size([2, 4, 50257])\ntensor([[[-0.9289,  0.2748, -0.7557,  ..., -1.6070,  0.2702, -0.5888],\n         [-0.4476,  0.1726,  0.5354,  ..., -0.3932,  1.5285,  0.8557],\n         [ 0.5680,  1.6053, -0.2155,  ...,  1.1624,  0.1380,  0.7425],\n         [ 0.0447,  2.4787, -0.8843,  ...,  1.3219, -0.0864, -0.5856]],\n\n        [[-1.5474, -0.0542, -1.0571,  ..., -1.8061, -0.4494, -0.6747],\n         [-0.8422,  0.8243, -0.1098,  ..., -0.1434,  0.2079,  1.2046],\n         [ 0.1355,  1.1858, -0.1453,  ...,  0.0869, -0.1590,  0.1552],\n         [ 0.1666, -0.8138,  0.2307,  ...,  2.5035, -0.3055, -0.3083]]],\n       grad_fn=&lt;UnsafeViewBackward0&gt;)\n\nSince these are just random numbers, this is not a reason for concern, and you can proceed with the remainder of the chapter without issues\nOne possible reason for this discrepancy is the differing behavior of nn.Dropout across operating systems, depending on how PyTorch was compiled, as discussed here on the PyTorch issue tracker"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#normalizing-activations-with-layer-normalization",
    "href": "posts/LLM-From-Scratch/index.html#normalizing-activations-with-layer-normalization",
    "title": "LLM From Scratch",
    "section": "4.2 Normalizing activations with layer normalization",
    "text": "4.2 Normalizing activations with layer normalization\n\nLayer normalization, also known as LayerNorm (Ba et al. 2016), centers the activations of a neural network layer around a mean of 0 and normalizes their variance to 1\nThis stabilizes training and enables faster convergence to effective weights\nLayer normalization is applied both before and after the multi-head attention module within the transformer block, which we will implement later; it’s also applied before the final output layer\n\n\n\nLet’s see how layer normalization works by passing a small input sample through a simple neural network layer:\n\n\n\ntensor([[0.2260, 0.3470, 0.0000, 0.2216, 0.0000, 0.0000],\n        [0.2133, 0.2394, 0.0000, 0.5198, 0.3297, 0.0000]],\n       grad_fn=&lt;ReluBackward0&gt;)\n\n\n\nLet’s compute the mean and variance for each of the 2 inputs above:\n\n\n\nMean:\n tensor([[0.1324],\n        [0.2170]], grad_fn=&lt;MeanBackward1&gt;)\nVariance:\n tensor([[0.0231],\n        [0.0398]], grad_fn=&lt;VarBackward0&gt;)\n\n\n\nThe normalization is applied to each of the two inputs (rows) independently; using dim=-1 applies the calculation across the last dimension (in this case, the feature dimension) instead of the row dimension\n\n\n\nSubtracting the mean and dividing by the square-root of the variance (standard deviation) centers the inputs to have a mean of 0 and a variance of 1 across the column (feature) dimension:\n\n\n\nNormalized layer outputs:\n tensor([[ 0.6159,  1.4126, -0.8719,  0.5872, -0.8719, -0.8719],\n        [-0.0189,  0.1121, -1.0876,  1.5173,  0.5647, -1.0876]],\n       grad_fn=&lt;DivBackward0&gt;)\nMean:\n tensor([[-5.9605e-08],\n        [ 1.9868e-08]], grad_fn=&lt;MeanBackward1&gt;)\nVariance:\n tensor([[1.0000],\n        [1.0000]], grad_fn=&lt;VarBackward0&gt;)\n\n\n\nEach input is centered at 0 and has a unit variance of 1; to improve readability, we can disable PyTorch’s scientific notation:\n\n\n\nMean:\n tensor([[    -0.0000],\n        [     0.0000]], grad_fn=&lt;MeanBackward1&gt;)\nVariance:\n tensor([[1.0000],\n        [1.0000]], grad_fn=&lt;VarBackward0&gt;)\n\n\n\nAbove, we normalized the features of each input\nNow, using the same idea, we can implement a LayerNorm class:\n\nScale and shift\n\nNote that in addition to performing the normalization by subtracting the mean and dividing by the variance, we added two trainable parameters, a scale and a shift parameter\nThe initial scale (multiplying by 1) and shift (adding 0) values don’t have any effect; however, scale and shift are trainable parameters that the LLM automatically adjusts during training if it is determined that doing so would improve the model’s performance on its training task\nThis allows the model to learn appropriate scaling and shifting that best suit the data it is processing\nNote that we also add a smaller value (eps) before computing the square root of the variance; this is to avoid division-by-zero errors if the variance is 0\n\nBiased variance - In the variance calculation above, setting unbiased=False means using the formula \\(\\frac{\\sum_i (x_i - \\bar{x})^2}{n}\\) to compute the variance where n is the sample size (here, the number of features or columns); this formula does not include Bessel’s correction (which uses n-1 in the denominator), thus providing a biased estimate of the variance - For LLMs, where the embedding dimension n is very large, the difference between using n and n-1 is negligible - However, GPT-2 was trained with a biased variance in the normalization layers, which is why we also adopted this setting for compatibility reasons with the pretrained weights that we will load in later chapters\n\nLet’s now try out LayerNorm in practice:\n\n\n\nMean:\n tensor([[    -0.0000],\n        [     0.0000]], grad_fn=&lt;MeanBackward1&gt;)\nVariance:\n tensor([[1.0000],\n        [1.0000]], grad_fn=&lt;VarBackward0&gt;)"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#implementing-a-feed-forward-network-with-gelu-activations",
    "href": "posts/LLM-From-Scratch/index.html#implementing-a-feed-forward-network-with-gelu-activations",
    "title": "LLM From Scratch",
    "section": "4.3 Implementing a feed forward network with GELU activations",
    "text": "4.3 Implementing a feed forward network with GELU activations\n\nIn this section, we implement a small neural network submodule that is used as part of the transformer block in LLMs\nWe start with the activation function\nIn deep learning, ReLU (Rectified Linear Unit) activation functions are commonly used due to their simplicity and effectiveness in various neural network architectures\nIn LLMs, various other types of activation functions are used beyond the traditional ReLU; two notable examples are GELU (Gaussian Error Linear Unit) and SwiGLU (Swish-Gated Linear Unit)\nGELU and SwiGLU are more complex, smooth activation functions incorporating Gaussian and sigmoid-gated linear units, respectively, offering better performance for deep learning models, unlike the simpler, piecewise linear function of ReLU\nGELU (Hendrycks and Gimpel 2016) can be implemented in several ways; the exact version is defined as GELU(x)=x⋅Φ(x), where Φ(x) is the cumulative distribution function of the standard Gaussian distribution.\nIn practice, it’s common to implement a computationally cheaper approximation: \\(\\text{GELU}(x) \\approx 0.5 \\cdot x \\cdot \\left(1 + \\tanh\\left[\\sqrt{\\frac{2}{\\pi}} \\cdot \\left(x + 0.044715 \\cdot x^3\\right)\\right]\\right)\\) (the original GPT-2 model was also trained with this approximation)\n\n\n\n\n\n\n\n\n\n\n\nAs we can see, ReLU is a piecewise linear function that outputs the input directly if it is positive; otherwise, it outputs zero\nGELU is a smooth, non-linear function that approximates ReLU but with a non-zero gradient for negative values (except at approximately -0.75)\nNext, let’s implement the small neural network module, FeedForward, that we will be using in the LLM’s transformer block later:\n\n\n\n768\n\n\n\n\n\ntorch.Size([2, 3, 768])"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#adding-shortcut-connections",
    "href": "posts/LLM-From-Scratch/index.html#adding-shortcut-connections",
    "title": "LLM From Scratch",
    "section": "4.4 Adding shortcut connections",
    "text": "4.4 Adding shortcut connections\n\nNext, let’s talk about the concept behind shortcut connections, also called skip or residual connections\nOriginally, shortcut connections were proposed in deep networks for computer vision (residual networks) to mitigate vanishing gradient problems\nA shortcut connection creates an alternative shorter path for the gradient to flow through the network\nThis is achieved by adding the output of one layer to the output of a later layer, usually skipping one or more layers in between\nLet’s illustrate this idea with a small example network:\n\n\n\nIn code, it looks like this:\nLet’s print the gradient values first without shortcut connections:\n\n\n\nlayers.0.0.weight has gradient mean of 0.00020173587836325169\nlayers.1.0.weight has gradient mean of 0.00012011159560643137\nlayers.2.0.weight has gradient mean of 0.0007152039906941354\nlayers.3.0.weight has gradient mean of 0.0013988736318424344\nlayers.4.0.weight has gradient mean of 0.005049645435065031\n\n\n\nNext, let’s print the gradient values with shortcut connections:\n\n\n\nlayers.0.0.weight has gradient mean of 0.22169792652130127\nlayers.1.0.weight has gradient mean of 0.20694106817245483\nlayers.2.0.weight has gradient mean of 0.32896995544433594\nlayers.3.0.weight has gradient mean of 0.2665732204914093\nlayers.4.0.weight has gradient mean of 1.3258540630340576\n\n\n\nAs we can see based on the output above, shortcut connections prevent the gradients from vanishing in the early layers (towards layer.0)\nWe will use this concept of a shortcut connection next when we implement a transformer block"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#connecting-attention-and-linear-layers-in-a-transformer-block",
    "href": "posts/LLM-From-Scratch/index.html#connecting-attention-and-linear-layers-in-a-transformer-block",
    "title": "LLM From Scratch",
    "section": "4.5 Connecting attention and linear layers in a transformer block",
    "text": "4.5 Connecting attention and linear layers in a transformer block\n\nIn this section, we now combine the previous concepts into a so-called transformer block\nA transformer block combines the causal multi-head attention module from the previous chapter with the linear layers, the feed forward neural network we implemented in an earlier section\nIn addition, the transformer block also uses dropout and shortcut connections\n\n\n\nSuppose we have 2 input samples with 6 tokens each, where each token is a 768-dimensional embedding vector; then this transformer block applies self-attention, followed by linear layers, to produce an output of similar size\nYou can think of the output as an augmented version of the context vectors we discussed in the previous chapter\n\n\n\nInput shape: torch.Size([2, 4, 768])\nOutput shape: torch.Size([2, 4, 768])"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#coding-the-gpt-model",
    "href": "posts/LLM-From-Scratch/index.html#coding-the-gpt-model",
    "title": "LLM From Scratch",
    "section": "4.6 Coding the GPT model",
    "text": "4.6 Coding the GPT model\n\nWe are almost there: now let’s plug in the transformer block into the architecture we coded at the very beginning of this chapter so that we obtain a usable GPT architecture\nNote that the transformer block is repeated multiple times; in the case of the smallest 124M GPT-2 model, we repeat it 12 times:\n\n\n\nThe corresponding code implementation, where cfg[\"n_layers\"] = 12:\nUsing the configuration of the 124M parameter model, we can now instantiate this GPT model with random initial weights as follows:\n\n\n\nInput batch:\n tensor([[6109, 3626, 6100,  345],\n        [6109, 1110, 6622,  257]])\n\nOutput shape: torch.Size([2, 4, 50257])\ntensor([[[ 0.3613,  0.4222, -0.0711,  ...,  0.3483,  0.4661, -0.2838],\n         [-0.1792, -0.5660, -0.9485,  ...,  0.0477,  0.5181, -0.3168],\n         [ 0.7120,  0.0332,  0.1085,  ...,  0.1018, -0.4327, -0.2553],\n         [-1.0076,  0.3418, -0.1190,  ...,  0.7195,  0.4023,  0.0532]],\n\n        [[-0.2564,  0.0900,  0.0335,  ...,  0.2659,  0.4454, -0.6806],\n         [ 0.1230,  0.3653, -0.2074,  ...,  0.7705,  0.2710,  0.2246],\n         [ 1.0558,  1.0318, -0.2800,  ...,  0.6936,  0.3205, -0.3178],\n         [-0.1565,  0.3926,  0.3288,  ...,  1.2630, -0.1858,  0.0388]]],\n       grad_fn=&lt;UnsafeViewBackward0&gt;)\n\n\n\nWe will train this model in the next chapter\nHowever, a quick note about its size: we previously referred to it as a 124M parameter model; we can double check this number as follows:\n\n\n\nTotal number of parameters: 163,009,536\n\n\n\nAs we see above, this model has 163M, not 124M parameters; why?\nIn the original GPT-2 paper, the researchers applied weight tying, which means that they reused the token embedding layer (tok_emb) as the output layer, which means setting self.out_head.weight = self.tok_emb.weight\nThe token embedding layer projects the 50,257-dimensional one-hot encoded input tokens to a 768-dimensional embedding representation\nThe output layer projects 768-dimensional embeddings back into a 50,257-dimensional representation so that we can convert these back into words (more about that in the next section)\nSo, the embedding and output layer have the same number of weight parameters, as we can see based on the shape of their weight matrices\nHowever, a quick note about its size: we previously referred to it as a 124M parameter model; we can double check this number as follows:\n\n\n\nToken embedding layer shape: torch.Size([50257, 768])\nOutput layer shape: torch.Size([50257, 768])\n\n\n\nIn the original GPT-2 paper, the researchers reused the token embedding matrix as an output matrix\nCorrespondingly, if we subtracted the number of parameters of the output layer, we’d get a 124M parameter model:\n\n\n\nNumber of trainable parameters considering weight tying: 124,412,160\n\n\n\nIn practice, I found it easier to train the model without weight-tying, which is why we didn’t implement it here\nHowever, we will revisit and apply this weight-tying idea later when we load the pretrained weights in chapter 5\nLastly, we can compute the memory requirements of the model as follows, which can be a helpful reference point:\n\n\n\nTotal size of the model: 621.83 MB\n\n\n\nExercise: you can try the following other configurations, which are referenced in the GPT-2 paper, as well.\n\nGPT2-small (the 124M configuration we already implemented):\n\n“emb_dim” = 768\n“n_layers” = 12\n“n_heads” = 12\n\nGPT2-medium:\n\n“emb_dim” = 1024\n“n_layers” = 24\n“n_heads” = 16\n\nGPT2-large:\n\n“emb_dim” = 1280\n“n_layers” = 36\n“n_heads” = 20\n\nGPT2-XL:\n\n“emb_dim” = 1600\n“n_layers” = 48\n“n_heads” = 25"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#generating-text",
    "href": "posts/LLM-From-Scratch/index.html#generating-text",
    "title": "LLM From Scratch",
    "section": "4.7 Generating text",
    "text": "4.7 Generating text\n\nLLMs like the GPT model we implemented above are used to generate one word at a time\n\n\n\nThe following generate_text_simple function implements greedy decoding, which is a simple and fast method to generate text\nIn greedy decoding, at each step, the model chooses the word (or token) with the highest probability as its next output (the highest logit corresponds to the highest probability, so we technically wouldn’t even have to compute the softmax function explicitly)\nIn the next chapter, we will implement a more advanced generate_text function\nThe figure below depicts how the GPT model, given an input context, generates the next word token\n\n\n\nThe generate_text_simple above implements an iterative process, where it creates one token at a time\n\n\n\nLet’s prepare an input example:\n\n\n\nencoded: [15496, 11, 314, 716]\nencoded_tensor.shape: torch.Size([1, 4])\n\n\n\n\nOutput: tensor([[15496,    11,   314,   716, 27018, 24086, 47843, 30961, 42348,  7267]])\nOutput length: 10\n\n\n\nRemove batch dimension and convert back into text:\n\n\n\nHello, I am Featureiman Byeswickattribute argue\n\n\n\nNote that the model is untrained; hence the random output texts above\nWe will train the model in the next chapter"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#summary-and-takeaways-2",
    "href": "posts/LLM-From-Scratch/index.html#summary-and-takeaways-2",
    "title": "LLM From Scratch",
    "section": "Summary and takeaways",
    "text": "Summary and takeaways\n\nSee the ./gpt.py script, a self-contained script containing the GPT model we implement in this Jupyter notebook\nYou can find the exercise solutions in ./exercise-solutions.ipynb"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#different-categories-of-finetuning",
    "href": "posts/LLM-From-Scratch/index.html#different-categories-of-finetuning",
    "title": "LLM From Scratch",
    "section": "6.1 Different categories of finetuning",
    "text": "6.1 Different categories of finetuning\n\nNo code in this section\nThe most common ways to finetune language models are instruction-finetuning and classification finetuning\nInstruction-finetuning, depicted below, is the topic of the next chapter\n\n\n\nClassification finetuning, the topic of this chapter, is a procedure you may already be familiar with if you have a background in machine learning – it’s similar to training a convolutional network to classify handwritten digits, for example\nIn classification finetuning, we have a specific number of class labels (for example, “spam” and “not spam”) that the model can output\nA classification finetuned model can only predict classes it has seen during training (for example, “spam” or “not spam”), whereas an instruction-finetuned model can usually perform many tasks\nWe can think of a classification-finetuned model as a very specialized model; in practice, it is much easier to create a specialized model than a generalist model that performs well on many different tasks"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#preparing-the-dataset",
    "href": "posts/LLM-From-Scratch/index.html#preparing-the-dataset",
    "title": "LLM From Scratch",
    "section": "6.2 Preparing the dataset",
    "text": "6.2 Preparing the dataset\n\n\nThis section prepares the dataset we use for classification finetuning\nWe use a dataset consisting of spam and non-spam text messages to finetune the LLM to classify them\nFirst, we download and unzip the dataset\n\n\n\nFile downloaded and saved as sms_spam_collection/SMSSpamCollection.tsv\n\n\n\nThe dataset is saved as a tab-separated text file, which we can load into a pandas DataFrame\n\n\n\n\n\n\n\n\n\n\nLabel\nText\n\n\n\n\n0\nham\nGo until jurong point, crazy.. Available only ...\n\n\n1\nham\nOk lar... Joking wif u oni...\n\n\n2\nspam\nFree entry in 2 a wkly comp to win FA Cup fina...\n\n\n3\nham\nU dun say so early hor... U c already then say...\n\n\n4\nham\nNah I don't think he goes to usf, he lives aro...\n\n\n...\n...\n...\n\n\n5567\nspam\nThis is the 2nd time we have tried 2 contact u...\n\n\n5568\nham\nWill ü b going to esplanade fr home?\n\n\n5569\nham\nPity, * was in mood for that. So...any other s...\n\n\n5570\nham\nThe guy did some bitching but I acted like i'd...\n\n\n5571\nham\nRofl. Its true to its name\n\n\n\n\n5572 rows × 2 columns\n\n\n\n\nWhen we check the class distribution, we see that the data contains “ham” (i.e., “not spam”) much more frequently than “spam”\n\n\n\nLabel\nham     4825\nspam     747\nName: count, dtype: int64\n\n\n\nFor simplicity, and because we prefer a small dataset for educational purposes anyway (it will make it possible to finetune the LLM faster), we subsample (undersample) the dataset so that it contains 747 instances from each class\n(Next to undersampling, there are several other ways to deal with class balances, but they are out of the scope of a book on LLMs; you can find examples and more information in the imbalanced-learn user guide)\n\n\n\nLabel\nham     747\nspam    747\nName: count, dtype: int64\n\n\n\nNext, we change the string class labels “ham” and “spam” into integer class labels 0 and 1:\n\n\n\n\n\n\n\n\n\n\nLabel\nText\n\n\n\n\n4307\n0\nAwww dat is sweet! We can think of something t...\n\n\n4138\n0\nJust got to &lt;#&gt;\n\n\n4831\n0\nThe word \"Checkmate\" in chess comes from the P...\n\n\n4461\n0\nThis is wishing you a great day. Moji told me ...\n\n\n5440\n0\nThank you. do you generally date the brothas?\n\n\n...\n...\n...\n\n\n5537\n1\nWant explicit SEX in 30 secs? Ring 02073162414...\n\n\n5540\n1\nASKED 3MOBILE IF 0870 CHATLINES INCLU IN FREE ...\n\n\n5547\n1\nHad your contract mobile 11 Mnths? Latest Moto...\n\n\n5566\n1\nREMINDER FROM O2: To get 2.50 pounds free call...\n\n\n5567\n1\nThis is the 2nd time we have tried 2 contact u...\n\n\n\n\n1494 rows × 2 columns\n\n\n\n\nLet’s now define a function that randomly divides the dataset into training, validation, and test subsets"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#creating-data-loaders",
    "href": "posts/LLM-From-Scratch/index.html#creating-data-loaders",
    "title": "LLM From Scratch",
    "section": "6.3 Creating data loaders",
    "text": "6.3 Creating data loaders\n\nNote that the text messages have different lengths; if we want to combine multiple training examples in a batch, we have to either\n\ntruncate all messages to the length of the shortest message in the dataset or batch\npad all messages to the length of the longest message in the dataset or batch\n\nWe choose option 2 and pad all messages to the longest message in the dataset\nFor that, we use &lt;|endoftext|&gt; as a padding token, as discussed in chapter 2\n\n\n\n\n[50256]\n\n\n\nThe SpamDataset class below identifies the longest sequence in the training dataset and adds the padding token to the others to match that sequence length\n\n\n\n120\n\n\n\nWe also pad the validation and test set to the longest training sequence\nNote that validation and test set samples that are longer than the longest training example are being truncated via encoded_text[:self.max_length] in the SpamDataset code\nThis behavior is entirely optional, and it would also work well if we set max_length=None in both the validation and test set cases\nNext, we use the dataset to instantiate the data loaders, which is similar to creating the data loaders in previous chapters\n\n\n\nAs a verification step, we iterate through the data loaders and ensure that the batches contain 8 training examples each, where each training example consists of 120 tokens\n\n\n\nTrain loader:\nInput batch dimensions: torch.Size([8, 120])\nLabel batch dimensions torch.Size([8])\n\n\n\nLastly, let’s print the total number of batches in each dataset\n\n\n\n130 training batches\n19 validation batches\n38 test batches"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#initializing-a-model-with-pretrained-weights",
    "href": "posts/LLM-From-Scratch/index.html#initializing-a-model-with-pretrained-weights",
    "title": "LLM From Scratch",
    "section": "6.4 Initializing a model with pretrained weights",
    "text": "6.4 Initializing a model with pretrained weights\n\nIn this section, we initialize the pretrained model we worked with in the previous chapter\n\n\n\n\nFile already exists and is up-to-date: gpt2/124M/checkpoint\nFile already exists and is up-to-date: gpt2/124M/encoder.json\nFile already exists and is up-to-date: gpt2/124M/hparams.json\nFile already exists and is up-to-date: gpt2/124M/model.ckpt.data-00000-of-00001\nFile already exists and is up-to-date: gpt2/124M/model.ckpt.index\nFile already exists and is up-to-date: gpt2/124M/model.ckpt.meta\nFile already exists and is up-to-date: gpt2/124M/vocab.bpe\n\n\n\nTo ensure that the model was loaded correctly, let’s double-check that it generates coherent text\n\n\n\nEvery effort moves you forward.\n\nThe first step is to understand the importance of your work\n\n\n\nBefore we finetune the model as a classifier, let’s see if the model can perhaps already classify spam messages via prompting\n\n\n\nIs the following text 'spam'? Answer with 'yes' or 'no': 'You are a winner you have been specially selected to receive $1000 cash or a $2000 award.'\n\nThe following text 'spam'? Answer with 'yes' or 'no': 'You are a winner\n\n\n\nAs we can see, the model is not very good at following instructions\nThis is expected, since it has only been pretrained and not instruction-finetuned (instruction finetuning will be covered in the next chapter)"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#adding-a-classification-head",
    "href": "posts/LLM-From-Scratch/index.html#adding-a-classification-head",
    "title": "LLM From Scratch",
    "section": "6.5 Adding a classification head",
    "text": "6.5 Adding a classification head\n\n\nIn this section, we are modifying the pretrained LLM to make it ready for classification finetuning\nLet’s take a look at the model architecture first\n\n\n\nGPTModel(\n  (tok_emb): Embedding(50257, 768)\n  (pos_emb): Embedding(1024, 768)\n  (drop_emb): Dropout(p=0.0, inplace=False)\n  (trf_blocks): Sequential(\n    (0): TransformerBlock(\n      (att): MultiHeadAttention(\n        (W_query): Linear(in_features=768, out_features=768, bias=True)\n        (W_key): Linear(in_features=768, out_features=768, bias=True)\n        (W_value): Linear(in_features=768, out_features=768, bias=True)\n        (out_proj): Linear(in_features=768, out_features=768, bias=True)\n        (dropout): Dropout(p=0.0, inplace=False)\n      )\n      (ff): FeedForward(\n        (layers): Sequential(\n          (0): Linear(in_features=768, out_features=3072, bias=True)\n          (1): GELU()\n          (2): Linear(in_features=3072, out_features=768, bias=True)\n        )\n      )\n      (norm1): LayerNorm()\n      (norm2): LayerNorm()\n      (drop_resid): Dropout(p=0.0, inplace=False)\n    )\n    (1): TransformerBlock(\n      (att): MultiHeadAttention(\n        (W_query): Linear(in_features=768, out_features=768, bias=True)\n        (W_key): Linear(in_features=768, out_features=768, bias=True)\n        (W_value): Linear(in_features=768, out_features=768, bias=True)\n        (out_proj): Linear(in_features=768, out_features=768, bias=True)\n        (dropout): Dropout(p=0.0, inplace=False)\n      )\n      (ff): FeedForward(\n        (layers): Sequential(\n          (0): Linear(in_features=768, out_features=3072, bias=True)\n          (1): GELU()\n          (2): Linear(in_features=3072, out_features=768, bias=True)\n        )\n      )\n      (norm1): LayerNorm()\n      (norm2): LayerNorm()\n      (drop_resid): Dropout(p=0.0, inplace=False)\n    )\n    (2): TransformerBlock(\n      (att): MultiHeadAttention(\n        (W_query): Linear(in_features=768, out_features=768, bias=True)\n        (W_key): Linear(in_features=768, out_features=768, bias=True)\n        (W_value): Linear(in_features=768, out_features=768, bias=True)\n        (out_proj): Linear(in_features=768, out_features=768, bias=True)\n        (dropout): Dropout(p=0.0, inplace=False)\n      )\n      (ff): FeedForward(\n        (layers): Sequential(\n          (0): Linear(in_features=768, out_features=3072, bias=True)\n          (1): GELU()\n          (2): Linear(in_features=3072, out_features=768, bias=True)\n        )\n      )\n      (norm1): LayerNorm()\n      (norm2): LayerNorm()\n      (drop_resid): Dropout(p=0.0, inplace=False)\n    )\n    (3): TransformerBlock(\n      (att): MultiHeadAttention(\n        (W_query): Linear(in_features=768, out_features=768, bias=True)\n        (W_key): Linear(in_features=768, out_features=768, bias=True)\n        (W_value): Linear(in_features=768, out_features=768, bias=True)\n        (out_proj): Linear(in_features=768, out_features=768, bias=True)\n        (dropout): Dropout(p=0.0, inplace=False)\n      )\n      (ff): FeedForward(\n        (layers): Sequential(\n          (0): Linear(in_features=768, out_features=3072, bias=True)\n          (1): GELU()\n          (2): Linear(in_features=3072, out_features=768, bias=True)\n        )\n      )\n      (norm1): LayerNorm()\n      (norm2): LayerNorm()\n      (drop_resid): Dropout(p=0.0, inplace=False)\n    )\n    (4): TransformerBlock(\n      (att): MultiHeadAttention(\n        (W_query): Linear(in_features=768, out_features=768, bias=True)\n        (W_key): Linear(in_features=768, out_features=768, bias=True)\n        (W_value): Linear(in_features=768, out_features=768, bias=True)\n        (out_proj): Linear(in_features=768, out_features=768, bias=True)\n        (dropout): Dropout(p=0.0, inplace=False)\n      )\n      (ff): FeedForward(\n        (layers): Sequential(\n          (0): Linear(in_features=768, out_features=3072, bias=True)\n          (1): GELU()\n          (2): Linear(in_features=3072, out_features=768, bias=True)\n        )\n      )\n      (norm1): LayerNorm()\n      (norm2): LayerNorm()\n      (drop_resid): Dropout(p=0.0, inplace=False)\n    )\n    (5): TransformerBlock(\n      (att): MultiHeadAttention(\n        (W_query): Linear(in_features=768, out_features=768, bias=True)\n        (W_key): Linear(in_features=768, out_features=768, bias=True)\n        (W_value): Linear(in_features=768, out_features=768, bias=True)\n        (out_proj): Linear(in_features=768, out_features=768, bias=True)\n        (dropout): Dropout(p=0.0, inplace=False)\n      )\n      (ff): FeedForward(\n        (layers): Sequential(\n          (0): Linear(in_features=768, out_features=3072, bias=True)\n          (1): GELU()\n          (2): Linear(in_features=3072, out_features=768, bias=True)\n        )\n      )\n      (norm1): LayerNorm()\n      (norm2): LayerNorm()\n      (drop_resid): Dropout(p=0.0, inplace=False)\n    )\n    (6): TransformerBlock(\n      (att): MultiHeadAttention(\n        (W_query): Linear(in_features=768, out_features=768, bias=True)\n        (W_key): Linear(in_features=768, out_features=768, bias=True)\n        (W_value): Linear(in_features=768, out_features=768, bias=True)\n        (out_proj): Linear(in_features=768, out_features=768, bias=True)\n        (dropout): Dropout(p=0.0, inplace=False)\n      )\n      (ff): FeedForward(\n        (layers): Sequential(\n          (0): Linear(in_features=768, out_features=3072, bias=True)\n          (1): GELU()\n          (2): Linear(in_features=3072, out_features=768, bias=True)\n        )\n      )\n      (norm1): LayerNorm()\n      (norm2): LayerNorm()\n      (drop_resid): Dropout(p=0.0, inplace=False)\n    )\n    (7): TransformerBlock(\n      (att): MultiHeadAttention(\n        (W_query): Linear(in_features=768, out_features=768, bias=True)\n        (W_key): Linear(in_features=768, out_features=768, bias=True)\n        (W_value): Linear(in_features=768, out_features=768, bias=True)\n        (out_proj): Linear(in_features=768, out_features=768, bias=True)\n        (dropout): Dropout(p=0.0, inplace=False)\n      )\n      (ff): FeedForward(\n        (layers): Sequential(\n          (0): Linear(in_features=768, out_features=3072, bias=True)\n          (1): GELU()\n          (2): Linear(in_features=3072, out_features=768, bias=True)\n        )\n      )\n      (norm1): LayerNorm()\n      (norm2): LayerNorm()\n      (drop_resid): Dropout(p=0.0, inplace=False)\n    )\n    (8): TransformerBlock(\n      (att): MultiHeadAttention(\n        (W_query): Linear(in_features=768, out_features=768, bias=True)\n        (W_key): Linear(in_features=768, out_features=768, bias=True)\n        (W_value): Linear(in_features=768, out_features=768, bias=True)\n        (out_proj): Linear(in_features=768, out_features=768, bias=True)\n        (dropout): Dropout(p=0.0, inplace=False)\n      )\n      (ff): FeedForward(\n        (layers): Sequential(\n          (0): Linear(in_features=768, out_features=3072, bias=True)\n          (1): GELU()\n          (2): Linear(in_features=3072, out_features=768, bias=True)\n        )\n      )\n      (norm1): LayerNorm()\n      (norm2): LayerNorm()\n      (drop_resid): Dropout(p=0.0, inplace=False)\n    )\n    (9): TransformerBlock(\n      (att): MultiHeadAttention(\n        (W_query): Linear(in_features=768, out_features=768, bias=True)\n        (W_key): Linear(in_features=768, out_features=768, bias=True)\n        (W_value): Linear(in_features=768, out_features=768, bias=True)\n        (out_proj): Linear(in_features=768, out_features=768, bias=True)\n        (dropout): Dropout(p=0.0, inplace=False)\n      )\n      (ff): FeedForward(\n        (layers): Sequential(\n          (0): Linear(in_features=768, out_features=3072, bias=True)\n          (1): GELU()\n          (2): Linear(in_features=3072, out_features=768, bias=True)\n        )\n      )\n      (norm1): LayerNorm()\n      (norm2): LayerNorm()\n      (drop_resid): Dropout(p=0.0, inplace=False)\n    )\n    (10): TransformerBlock(\n      (att): MultiHeadAttention(\n        (W_query): Linear(in_features=768, out_features=768, bias=True)\n        (W_key): Linear(in_features=768, out_features=768, bias=True)\n        (W_value): Linear(in_features=768, out_features=768, bias=True)\n        (out_proj): Linear(in_features=768, out_features=768, bias=True)\n        (dropout): Dropout(p=0.0, inplace=False)\n      )\n      (ff): FeedForward(\n        (layers): Sequential(\n          (0): Linear(in_features=768, out_features=3072, bias=True)\n          (1): GELU()\n          (2): Linear(in_features=3072, out_features=768, bias=True)\n        )\n      )\n      (norm1): LayerNorm()\n      (norm2): LayerNorm()\n      (drop_resid): Dropout(p=0.0, inplace=False)\n    )\n    (11): TransformerBlock(\n      (att): MultiHeadAttention(\n        (W_query): Linear(in_features=768, out_features=768, bias=True)\n        (W_key): Linear(in_features=768, out_features=768, bias=True)\n        (W_value): Linear(in_features=768, out_features=768, bias=True)\n        (out_proj): Linear(in_features=768, out_features=768, bias=True)\n        (dropout): Dropout(p=0.0, inplace=False)\n      )\n      (ff): FeedForward(\n        (layers): Sequential(\n          (0): Linear(in_features=768, out_features=3072, bias=True)\n          (1): GELU()\n          (2): Linear(in_features=3072, out_features=768, bias=True)\n        )\n      )\n      (norm1): LayerNorm()\n      (norm2): LayerNorm()\n      (drop_resid): Dropout(p=0.0, inplace=False)\n    )\n  )\n  (final_norm): LayerNorm()\n  (out_head): Linear(in_features=768, out_features=50257, bias=False)\n)\n\n\n\nAbove, we can see the architecture we implemented in chapter 4 neatly laid out\nThe goal is to replace and finetune the output layer\nTo achieve this, we first freeze the model, meaning that we make all layers non-trainable\nThen, we replace the output layer (model.out_head), which originally maps the layer inputs to 50,257 dimensions (the size of the vocabulary)\nSince we finetune the model for binary classification (predicting 2 classes, “spam” and “not spam”), we can replace the output layer as shown below, which will be trainable by default\nNote that we use BASE_CONFIG[\"emb_dim\"] (which is equal to 768 in the \"gpt2-small (124M)\" model) to keep the code below more general\nTechnically, it’s sufficient to only train the output layer\nHowever, as I found in Finetuning Large Language Models, experiments show that finetuning additional layers can noticeably improve the performance\nSo, we are also making the last transformer block and the final LayerNorm module connecting the last transformer block to the output layer trainable\n\n\n\nWe can still use this model similar to before in previous chapters\nFor example, let’s feed it some text input\n\n\n\nInputs: tensor([[5211,  345,  423,  640]])\nInputs dimensions: torch.Size([1, 4])\n\n\n\nWhat’s different compared to previous chapters is that it now has two output dimensions instead of 50,257\n\n\n\nOutputs:\n tensor([[[-1.5854,  0.9904],\n         [-3.7235,  7.4548],\n         [-2.2661,  6.6049],\n         [-3.5983,  3.9902]]])\nOutputs dimensions: torch.Size([1, 4, 2])\n\n\n\nAs discussed in previous chapters, for each input token, there’s one output vector\nSince we fed the model a text sample with 4 input tokens, the output consists of 4 2-dimensional output vectors above\n\n\n\nIn chapter 3, we discussed the attention mechanism, which connects each input token to each other input token\nIn chapter 3, we then also introduced the causal attention mask that is used in GPT-like models; this causal mask lets a current token only attend to the current and previous token positions\nBased on this causal attention mechanism, the 4th (last) token contains the most information among all tokens because it’s the only token that includes information about all other tokens\nHence, we are particularly interested in this last token, which we will finetune for the spam classification task\n\n\n\nLast output token: tensor([[-3.5983,  3.9902]])"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#calculating-the-classification-loss-and-accuracy",
    "href": "posts/LLM-From-Scratch/index.html#calculating-the-classification-loss-and-accuracy",
    "title": "LLM From Scratch",
    "section": "6.6 Calculating the classification loss and accuracy",
    "text": "6.6 Calculating the classification loss and accuracy\n\n\nBefore explaining the loss calculation, let’s have a brief look at how the model outputs are turned into class labels\n\n\n\n\nLast output token: tensor([[-3.5983,  3.9902]])\n\n\n\nSimilar to chapter 5, we convert the outputs (logits) into probability scores via the softmax function and then obtain the index position of the largest probability value via the argmax function\n\n\n\nClass label: 1\n\n\n\nNote that the softmax function is optional here, as explained in chapter 5, because the largest outputs correspond to the largest probability scores\n\n\n\nClass label: 1\n\n\n\nWe can apply this concept to calculate the so-called classification accuracy, which computes the percentage of correct predictions in a given dataset\nTo calculate the classification accuracy, we can apply the preceding argmax-based prediction code to all examples in a dataset and calculate the fraction of correct predictions as follows:\nLet’s apply the function to calculate the classification accuracies for the different datasets:\n\n\n\nTraining accuracy: 46.25%\nValidation accuracy: 45.00%\nTest accuracy: 48.75%\n\n\n\nAs we can see, the prediction accuracies are not very good, since we haven’t finetuned the model, yet\nBefore we can start finetuning (/training), we first have to define the loss function we want to optimize during training\nThe goal is to maximize the spam classification accuracy of the model; however, classification accuracy is not a differentiable function\nHence, instead, we minimize the cross-entropy loss as a proxy for maximizing the classification accuracy (you can learn more about this topic in lecture 8 of my freely available Introduction to Deep Learning class)\nThe calc_loss_batch function is the same here as in chapter 5, except that we are only interested in optimizing the last token model(input_batch)[:, -1, :] instead of all tokens model(input_batch)\n\nThe calc_loss_loader is exactly the same as in chapter 5\n\nUsing the calc_closs_loader, we compute the initial training, validation, and test set losses before we start training\n\n\n\nTraining loss: 2.453\nValidation loss: 2.583\nTest loss: 2.322\n\n\n\nIn the next section, we train the model to improve the loss values and consequently the classification accuracy"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#finetuning-the-model-on-supervised-data",
    "href": "posts/LLM-From-Scratch/index.html#finetuning-the-model-on-supervised-data",
    "title": "LLM From Scratch",
    "section": "6.7 Finetuning the model on supervised data",
    "text": "6.7 Finetuning the model on supervised data\n\nIn this section, we define and use the training function to improve the classification accuracy of the model\nThe train_classifier_simple function below is practically the same as the train_model_simple function we used for pretraining the model in chapter 5\nThe only two differences are that we now\n\ntrack the number of training examples seen (examples_seen) instead of the number of tokens seen\ncalculate the accuracy after each epoch instead of printing a sample text after each epoch\n\n\n\n\nThe evaluate_model function used in the train_classifier_simple is the same as the one we used in chapter 5\nThe training takes about 5 minutes on a M3 MacBook Air laptop computer and less than half a minute on a V100 or A100 GPU\n\n\n\nEp 1 (Step 000000): Train loss 2.153, Val loss 2.392\nEp 1 (Step 000050): Train loss 0.617, Val loss 0.637\nEp 1 (Step 000100): Train loss 0.523, Val loss 0.557\nTraining accuracy: 70.00% | Validation accuracy: 72.50%\nEp 2 (Step 000150): Train loss 0.561, Val loss 0.489\nEp 2 (Step 000200): Train loss 0.419, Val loss 0.397\nEp 2 (Step 000250): Train loss 0.409, Val loss 0.353\nTraining accuracy: 82.50% | Validation accuracy: 85.00%\nEp 3 (Step 000300): Train loss 0.333, Val loss 0.320\nEp 3 (Step 000350): Train loss 0.340, Val loss 0.306\nTraining accuracy: 90.00% | Validation accuracy: 90.00%\nEp 4 (Step 000400): Train loss 0.136, Val loss 0.200\nEp 4 (Step 000450): Train loss 0.153, Val loss 0.132\nEp 4 (Step 000500): Train loss 0.222, Val loss 0.137\nTraining accuracy: 100.00% | Validation accuracy: 97.50%\nEp 5 (Step 000550): Train loss 0.207, Val loss 0.143\nEp 5 (Step 000600): Train loss 0.083, Val loss 0.074\nTraining accuracy: 100.00% | Validation accuracy: 97.50%\nTraining completed in 5.31 minutes.\n\n\n\nSimilar to chapter 5, we use matplotlib to plot the loss function for the training and validation set\n\n\n\n\n\n\n\n\n\n\n\nAbove, based on the downward slope, we see that the model learns well\nFurthermore, the fact that the training and validation loss are very close indicates that the model does not tend to overfit the training data\nSimilarly, we can plot the accuracy below\n\n\n\n\n\n\n\n\n\n\n\nBased on the accuracy plot above, we can see that the model achieves a relatively high training and validation accuracy after epochs 4 and 5\nHowever, we have to keep in mind that we specified eval_iter=5 in the training function earlier, which means that we only estimated the training and validation set performances\nWe can compute the training, validation, and test set performances over the complete dataset as follows below\n\n\n\nTraining accuracy: 97.21%\nValidation accuracy: 97.32%\nTest accuracy: 95.67%\n\n\n\nWe can see that the training and validation set performances are practically identical\nHowever, based on the slightly lower test set performance, we can see that the model overfits the training data to a very small degree, as well as the validation data that has been used for tweaking some of the hyperparameters, such as the learning rate\nThis is normal, however, and this gap could potentially be further reduced by increasing the model’s dropout rate (drop_rate) or the weight_decay in the optimizer setting"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#using-the-llm-as-a-spam-classifier",
    "href": "posts/LLM-From-Scratch/index.html#using-the-llm-as-a-spam-classifier",
    "title": "LLM From Scratch",
    "section": "6.8 Using the LLM as a spam classifier",
    "text": "6.8 Using the LLM as a spam classifier\n\n\nFinally, let’s use the finetuned GPT model in action\nThe classify_review function below implements the data preprocessing steps similar to the SpamDataset we implemented earlier\nThen, the function returns the predicted integer class label from the model and returns the corresponding class name\nLet’s try it out on a few examples below\n\n\n\nspam\n\n\n\n\nnot spam\n\n\n\nFinally, let’s save the model in case we want to reuse the model later without having to train it again\nThen, in a new session, we could load the model as follows\n\n\n\n&lt;All keys matched successfully&gt;"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#summary-and-takeaways-3",
    "href": "posts/LLM-From-Scratch/index.html#summary-and-takeaways-3",
    "title": "LLM From Scratch",
    "section": "Summary and takeaways",
    "text": "Summary and takeaways\n\nSee the ./gpt_train.py script, a self-contained script for training\nThe ./gpt_generate.py script loads pretrained weights from OpenAI and generates text based on a prompt\nYou can find the exercise solutions in ./exercise-solutions.ipynb"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#evaluating-generative-text-models",
    "href": "posts/LLM-From-Scratch/index.html#evaluating-generative-text-models",
    "title": "LLM From Scratch",
    "section": "5.1 Evaluating generative text models",
    "text": "5.1 Evaluating generative text models\n\nWe start this section with a brief recap of initializing a GPT model using the code from the previous chapter\nThen, we discuss basic evaluation metrics for LLMs\nLastly, in this section, we apply these evaluation metrics to a training and validation dataset\n\n\n5.1.1 Using GPT to generate text\n\nWe initialize a GPT model using the code from the previous chapter\n\nimport torch\nfrom previous_chapters import GPTModel\n# If the `previous_chapters.py` file is not available locally,\n# you can import it from the `llms-from-scratch` PyPI package.\n# For details, see: https://github.com/rasbt/LLMs-from-scratch/tree/main/pkg\n# E.g.,\n# from llms_from_scratch.ch04 import GPTModel\n\nGPT_CONFIG_124M = {\n    \"vocab_size\": 50257,   # Vocabulary size\n    \"context_length\": 256, # Shortened context length (orig: 1024)\n    \"emb_dim\": 768,        # Embedding dimension\n    \"n_heads\": 12,         # Number of attention heads\n    \"n_layers\": 12,        # Number of layers\n    \"drop_rate\": 0.1,      # Dropout rate\n    \"qkv_bias\": False      # Query-key-value bias\n}\n\ntorch.manual_seed(123)\nmodel = GPTModel(GPT_CONFIG_124M)\nmodel.eval();  # Disable dropout during inference\n\nWe use dropout of 0.1 above, but it’s relatively common to train LLMs without dropout nowadays\nModern LLMs also don’t use bias vectors in the nn.Linear layers for the query, key, and value matrices (unlike earlier GPT models), which is achieved by setting \"qkv_bias\": False\nWe reduce the context length (context_length) of only 256 tokens to reduce the computational resource requirements for training the model, whereas the original 124 million parameter GPT-2 model used 1024 tokens\n\nThis is so that more readers will be able to follow and execute the code examples on their laptop computer\nHowever, please feel free to increase the context_length to 1024 tokens (this would not require any code changes)\nWe will also load a model with a 1024 context_length later from pretrained weights\n\nNext, we use the generate_text_simple function from the previous chapter to generate text\nIn addition, we define two convenience functions, text_to_token_ids and token_ids_to_text, for converting between token and text representations that we use throughout this chapter\n\n\nimport tiktoken\nfrom previous_chapters import generate_text_simple\n\n# Alternatively:\n# from llms_from_scratch.ch04 import generate_text_simple\n\ndef text_to_token_ids(text, tokenizer):\n    encoded = tokenizer.encode(text, allowed_special={'&lt;|endoftext|&gt;'})\n    encoded_tensor = torch.tensor(encoded).unsqueeze(0) # add batch dimension\n    return encoded_tensor\n\ndef token_ids_to_text(token_ids, tokenizer):\n    flat = token_ids.squeeze(0) # remove batch dimension\n    return tokenizer.decode(flat.tolist())\n\nstart_context = \"Every effort moves you\"\ntokenizer = tiktoken.get_encoding(\"gpt2\")\n\ntoken_ids = generate_text_simple(\n    model=model,\n    idx=text_to_token_ids(start_context, tokenizer),\n    max_new_tokens=10,\n    context_size=GPT_CONFIG_124M[\"context_length\"]\n)\n\nprint(\"Output text:\\n\", token_ids_to_text(token_ids, tokenizer))\nOutput text:\n Every effort moves you rentingetic wasnم refres RexMeCHicular stren\n\nAs we can see above, the model does not produce good text because it has not been trained yet\nHow do we measure or capture what “good text” is, in a numeric form, to track it during training?\nThe next subsection introduces metrics to calculate a loss metric for the generated outputs that we can use to measure the training progress\nThe next chapters on finetuning LLMs will also introduce additional ways to measure model quality\n\n\n\n\n5.1.2 Calculating the text generation loss: cross-entropy and perplexity\n\nSuppose we have an inputs tensor containing the token IDs for 2 training examples (rows)\nCorresponding to the inputs, the targets contain the desired token IDs that we want the model to generate\nNotice that the targets are the inputs shifted by 1 position, as explained in chapter 2 when we implemented the data loader\n\ninputs = torch.tensor([[16833, 3626, 6100],   # [\"every effort moves\",\n                       [40,    1107, 588]])   #  \"I really like\"]\n\ntargets = torch.tensor([[3626, 6100, 345  ],  # [\" effort moves you\",\n                        [1107,  588, 11311]]) #  \" really like chocolate\"]\n\nFeeding the inputs to the model, we obtain the logits vector for the 2 input examples that consist of 3 tokens each\nEach of the tokens is a 50,257-dimensional vector corresponding to the size of the vocabulary\nApplying the softmax function, we can turn the logits tensor into a tensor of the same dimension containing probability scores\n\nwith torch.no_grad():\n    logits = model(inputs)\n\nprobas = torch.softmax(logits, dim=-1) # Probability of each token in vocabulary\nprint(probas.shape) # Shape: (batch_size, num_tokens, vocab_size)\ntorch.Size([2, 3, 50257])\n\nThe figure below, using a very small vocabulary for illustration purposes, outlines how we convert the probability scores back into text, which we discussed at the end of the previous chapter\n\n\n\nAs discussed in the previous chapter, we can apply the argmax function to convert the probability scores into predicted token IDs\nThe softmax function above produced a 50,257-dimensional vector for each token; the argmax function returns the position of the highest probability score in this vector, which is the predicted token ID for the given token\nSince we have 2 input batches with 3 tokens each, we obtain 2 by 3 predicted token IDs:\n\ntoken_ids = torch.argmax(probas, dim=-1, keepdim=True)\nprint(\"Token IDs:\\n\", token_ids)\nToken IDs:\n tensor([[[16657],\n         [  339],\n         [42826]],\n\n        [[49906],\n         [29669],\n         [41751]]])\n\nIf we decode these tokens, we find that these are quite different from the tokens we want the model to predict, namely the target tokens:\n\nprint(f\"Targets batch 1: {token_ids_to_text(targets[0], tokenizer)}\")\nprint(f\"Outputs batch 1: {token_ids_to_text(token_ids[0].flatten(), tokenizer)}\")\nTargets batch 1:  effort moves you\nOutputs batch 1:  Armed heNetflix\n\nThat’s because the model wasn’t trained yet\nTo train the model, we need to know how far it is away from the correct predictions (targets)\n\n\n\nThe token probabilities corresponding to the target indices are as follows:\n\ntext_idx = 0\ntarget_probas_1 = probas[text_idx, [0, 1, 2], targets[text_idx]]\nprint(\"Text 1:\", target_probas_1)\n\ntext_idx = 1\ntarget_probas_2 = probas[text_idx, [0, 1, 2], targets[text_idx]]\nprint(\"Text 2:\", target_probas_2)\nText 1: tensor([7.4541e-05, 3.1061e-05, 1.1563e-05])\nText 2: tensor([1.0337e-05, 5.6776e-05, 4.7559e-06])\n\nWe want to maximize all these values, bringing them close to a probability of 1\nIn mathematical optimization, it is easier to maximize the logarithm of the probability score than the probability score itself; this is out of the scope of this book, but I have recorded a lecture with more details here: L8.2 Logistic Regression Loss Function\n\n# Compute logarithm of all token probabilities\nlog_probas = torch.log(torch.cat((target_probas_1, target_probas_2)))\nprint(log_probas)\ntensor([ -9.5042, -10.3796, -11.3677, -11.4798,  -9.7764, -12.2561])\n\nNext, we compute the average log probability:\n\n# Calculate the average probability for each token\navg_log_probas = torch.mean(log_probas)\nprint(avg_log_probas)\ntensor(-10.7940)\n\nThe goal is to make this average log probability as large as possible by optimizing the model weights\nDue to the log, the largest possible value is 0, and we are currently far away from 0\nIn deep learning, instead of maximizing the average log-probability, it’s a standard convention to minimize the negative average log-probability value; in our case, instead of maximizing -10.7722 so that it approaches 0, in deep learning, we would minimize 10.7722 so that it approaches 0\nThe value negative of -10.7722, i.e., 10.7722, is also called cross-entropy loss in deep learning\n\nneg_avg_log_probas = avg_log_probas * -1\nprint(neg_avg_log_probas)\ntensor(10.7940)\n\nPyTorch already implements a cross_entropy function that carries out the previous steps\n\n\n\nBefore we apply the cross_entropy function, let’s check the shape of the logits and targets\n\n# Logits have shape (batch_size, num_tokens, vocab_size)\nprint(\"Logits shape:\", logits.shape)\n\n# Targets have shape (batch_size, num_tokens)\nprint(\"Targets shape:\", targets.shape)\nLogits shape: torch.Size([2, 3, 50257])\nTargets shape: torch.Size([2, 3])\n\nFor the cross_entropy function in PyTorch, we want to flatten these tensors by combining them over the batch dimension:\n\nlogits_flat = logits.flatten(0, 1)\ntargets_flat = targets.flatten()\n\nprint(\"Flattened logits:\", logits_flat.shape)\nprint(\"Flattened targets:\", targets_flat.shape)\nFlattened logits: torch.Size([6, 50257])\nFlattened targets: torch.Size([6])\n\nNote that the targets are the token IDs, which also represent the index positions in the logits tensors that we want to maximize\nThe cross_entropy function in PyTorch will automatically take care of applying the softmax and log-probability computation internally over those token indices in the logits that are to be maximized\n\nloss = torch.nn.functional.cross_entropy(logits_flat, targets_flat)\nprint(loss)\ntensor(10.7940)\n\nA concept related to the cross-entropy loss is the perplexity of an LLM\nThe perplexity is simply the exponential of the cross-entropy loss\n\nperplexity = torch.exp(loss)\nprint(perplexity)\ntensor(48725.8203)\n\nThe perplexity is often considered more interpretable because it can be understood as the effective vocabulary size that the model is uncertain about at each step (in the example above, that’d be 48,725 words or tokens)\nIn other words, perplexity provides a measure of how well the probability distribution predicted by the model matches the actual distribution of the words in the dataset\nSimilar to the loss, a lower perplexity indicates that the model predictions are closer to the actual distribution\n\n\n\n5.1.3 Calculating the training and validation set losses\n\nWe use a relatively small dataset for training the LLM (in fact, only one short story)\nThe reasons are:\n\nYou can run the code examples in a few minutes on a laptop computer without a suitable GPU\nThe training finishes relatively fast (minutes instead of weeks), which is good for educational purposes\nWe use a text from the public domain, which can be included in this GitHub repository without violating any usage rights or bloating the repository size\n\nFor example, Llama 2 7B required 184,320 GPU hours on A100 GPUs to be trained on 2 trillion tokens\n\nAt the time of this writing, the hourly cost of an 8xA100 cloud server at AWS is approximately \\$30\nSo, via an off-the-envelope calculation, training this LLM would cost 184,320 / 8 * \\$30 = \\$690,000\n\nBelow, we use the same dataset we used in chapter 2\n\nimport os\nimport urllib.request\n\nfile_path = \"the-verdict.txt\"\nurl = \"https://raw.githubusercontent.com/rasbt/LLMs-from-scratch/main/ch02/01_main-chapter-code/the-verdict.txt\"\n\nif not os.path.exists(file_path):\n    with urllib.request.urlopen(url) as response:\n        text_data = response.read().decode('utf-8')\n    with open(file_path, \"w\", encoding=\"utf-8\") as file:\n        file.write(text_data)\nelse:\n    with open(file_path, \"r\", encoding=\"utf-8\") as file:\n        text_data = file.read()\n\nA quick check that the text loaded ok by printing the first and last 99 characters\n\n# First 99 characters\nprint(text_data[:99])\nI HAD always thought Jack Gisburn rather a cheap genius--though a good fellow enough--so it was no \n# Last 99 characters\nprint(text_data[-99:])\nit for me! The Strouds stand alone, and happen once--but there's no exterminating our kind of art.\"\ntotal_characters = len(text_data)\ntotal_tokens = len(tokenizer.encode(text_data))\n\nprint(\"Characters:\", total_characters)\nprint(\"Tokens:\", total_tokens)\nCharacters: 20479\nTokens: 5145\n\nWith 5,145 tokens, the text is very short for training an LLM, but again, it’s for educational purposes (we will also load pretrained weights later)\nNext, we divide the dataset into a training and a validation set and use the data loaders from chapter 2 to prepare the batches for LLM training\nFor visualization purposes, the figure below assumes a max_length=6, but for the training loader, we set the max_length equal to the context length that the LLM supports\nThe figure below only shows the input tokens for simplicity\n\nSince we train the LLM to predict the next word in the text, the targets look the same as these inputs, except that the targets are shifted by one position\n\n\n\nfrom previous_chapters import create_dataloader_v1\n# Alternatively:\n# from llms_from_scratch.ch02 import create_dataloader_v1\n\n# Train/validation ratio\ntrain_ratio = 0.90\nsplit_idx = int(train_ratio * len(text_data))\ntrain_data = text_data[:split_idx]\nval_data = text_data[split_idx:]\n\n\ntorch.manual_seed(123)\n\ntrain_loader = create_dataloader_v1(\n    train_data,\n    batch_size=2,\n    max_length=GPT_CONFIG_124M[\"context_length\"],\n    stride=GPT_CONFIG_124M[\"context_length\"],\n    drop_last=True,\n    shuffle=True,\n    num_workers=0\n)\n\nval_loader = create_dataloader_v1(\n    val_data,\n    batch_size=2,\n    max_length=GPT_CONFIG_124M[\"context_length\"],\n    stride=GPT_CONFIG_124M[\"context_length\"],\n    drop_last=False,\n    shuffle=False,\n    num_workers=0\n)\n# Sanity check\n\nif total_tokens * (train_ratio) &lt; GPT_CONFIG_124M[\"context_length\"]:\n    print(\"Not enough tokens for the training loader. \"\n          \"Try to lower the `GPT_CONFIG_124M['context_length']` or \"\n          \"increase the `training_ratio`\")\n\nif total_tokens * (1-train_ratio) &lt; GPT_CONFIG_124M[\"context_length\"]:\n    print(\"Not enough tokens for the validation loader. \"\n          \"Try to lower the `GPT_CONFIG_124M['context_length']` or \"\n          \"decrease the `training_ratio`\")\n\nWe use a relatively small batch size to reduce the computational resource demand, and because the dataset is very small to begin with\nLlama 2 7B was trained with a batch size of 1024, for example\nAn optional check that the data was loaded correctly:\n\nprint(\"Train loader:\")\nfor x, y in train_loader:\n    print(x.shape, y.shape)\n\nprint(\"\\nValidation loader:\")\nfor x, y in val_loader:\n    print(x.shape, y.shape)\nTrain loader:\ntorch.Size([2, 256]) torch.Size([2, 256])\ntorch.Size([2, 256]) torch.Size([2, 256])\ntorch.Size([2, 256]) torch.Size([2, 256])\ntorch.Size([2, 256]) torch.Size([2, 256])\ntorch.Size([2, 256]) torch.Size([2, 256])\ntorch.Size([2, 256]) torch.Size([2, 256])\ntorch.Size([2, 256]) torch.Size([2, 256])\ntorch.Size([2, 256]) torch.Size([2, 256])\ntorch.Size([2, 256]) torch.Size([2, 256])\n\nValidation loader:\ntorch.Size([2, 256]) torch.Size([2, 256])\n\nAnother optional check that the token sizes are in the expected ballpark:\n\ntrain_tokens = 0\nfor input_batch, target_batch in train_loader:\n    train_tokens += input_batch.numel()\n\nval_tokens = 0\nfor input_batch, target_batch in val_loader:\n    val_tokens += input_batch.numel()\n\nprint(\"Training tokens:\", train_tokens)\nprint(\"Validation tokens:\", val_tokens)\nprint(\"All tokens:\", train_tokens + val_tokens)\nTraining tokens: 4608\nValidation tokens: 512\nAll tokens: 5120\n\nNext, we implement a utility function to calculate the cross-entropy loss of a given batch\nIn addition, we implement a second utility function to compute the loss for a user-specified number of batches in a data loader\n\ndef calc_loss_batch(input_batch, target_batch, model, device):\n    input_batch, target_batch = input_batch.to(device), target_batch.to(device)\n    logits = model(input_batch)\n    loss = torch.nn.functional.cross_entropy(logits.flatten(0, 1), target_batch.flatten())\n    return loss\n\n\ndef calc_loss_loader(data_loader, model, device, num_batches=None):\n    total_loss = 0.\n    if len(data_loader) == 0:\n        return float(\"nan\")\n    elif num_batches is None:\n        num_batches = len(data_loader)\n    else:\n        # Reduce the number of batches to match the total number of batches in the data loader\n        # if num_batches exceeds the number of batches in the data loader\n        num_batches = min(num_batches, len(data_loader))\n    for i, (input_batch, target_batch) in enumerate(data_loader):\n        if i &lt; num_batches:\n            loss = calc_loss_batch(input_batch, target_batch, model, device)\n            total_loss += loss.item()\n        else:\n            break\n    return total_loss / num_batches\n\nIf you have a machine with a CUDA-supported GPU, the LLM will train on the GPU without making any changes to the code\nVia the device setting, we ensure that the data is loaded onto the same device as the LLM model\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n# Note:\n# Uncommenting the following lines will allow the code to run on Apple Silicon chips, if applicable,\n# which is approximately 2x faster than on an Apple CPU (as measured on an M3 MacBook Air).\n# However, the resulting loss values may be slightly different.\n\n#if torch.cuda.is_available():\n#    device = torch.device(\"cuda\")\n#elif torch.backends.mps.is_available():\n#    device = torch.device(\"mps\")\n#else:\n#    device = torch.device(\"cpu\")\n#\n# print(f\"Using {device} device.\")\n\n\nmodel.to(device) # no assignment model = model.to(device) necessary for nn.Module classes\n\n\ntorch.manual_seed(123) # For reproducibility due to the shuffling in the data loader\n\nwith torch.no_grad(): # Disable gradient tracking for efficiency because we are not training, yet\n    train_loss = calc_loss_loader(train_loader, model, device)\n    val_loss = calc_loss_loader(val_loader, model, device)\n\nprint(\"Training loss:\", train_loss)\nprint(\"Validation loss:\", val_loss)\nTraining loss: 10.98758347829183\nValidation loss: 10.98110580444336"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#training-an-llm",
    "href": "posts/LLM-From-Scratch/index.html#training-an-llm",
    "title": "LLM From Scratch",
    "section": "5.2 Training an LLM",
    "text": "5.2 Training an LLM\n\nIn this section, we finally implement the code for training the LLM\nWe focus on a simple training function (if you are interested in augmenting this training function with more advanced techniques, such as learning rate warmup, cosine annealing, and gradient clipping, please refer to Appendix D)\n\n\ndef train_model_simple(model, train_loader, val_loader, optimizer, device, num_epochs,\n                       eval_freq, eval_iter, start_context, tokenizer):\n    # Initialize lists to track losses and tokens seen\n    train_losses, val_losses, track_tokens_seen = [], [], []\n    tokens_seen, global_step = 0, -1\n\n    # Main training loop\n    for epoch in range(num_epochs):\n        model.train()  # Set model to training mode\n        \n        for input_batch, target_batch in train_loader:\n            optimizer.zero_grad() # Reset loss gradients from previous batch iteration\n            loss = calc_loss_batch(input_batch, target_batch, model, device)\n            loss.backward() # Calculate loss gradients\n            optimizer.step() # Update model weights using loss gradients\n            tokens_seen += input_batch.numel()\n            global_step += 1\n\n            # Optional evaluation step\n            if global_step % eval_freq == 0:\n                train_loss, val_loss = evaluate_model(\n                    model, train_loader, val_loader, device, eval_iter)\n                train_losses.append(train_loss)\n                val_losses.append(val_loss)\n                track_tokens_seen.append(tokens_seen)\n                print(f\"Ep {epoch+1} (Step {global_step:06d}): \"\n                      f\"Train loss {train_loss:.3f}, Val loss {val_loss:.3f}\")\n\n        # Print a sample text after each epoch\n        generate_and_print_sample(\n            model, tokenizer, device, start_context\n        )\n\n    return train_losses, val_losses, track_tokens_seen\n\n\ndef evaluate_model(model, train_loader, val_loader, device, eval_iter):\n    model.eval()\n    with torch.no_grad():\n        train_loss = calc_loss_loader(train_loader, model, device, num_batches=eval_iter)\n        val_loss = calc_loss_loader(val_loader, model, device, num_batches=eval_iter)\n    model.train()\n    return train_loss, val_loss\n\n\ndef generate_and_print_sample(model, tokenizer, device, start_context):\n    model.eval()\n    context_size = model.pos_emb.weight.shape[0]\n    encoded = text_to_token_ids(start_context, tokenizer).to(device)\n    with torch.no_grad():\n        token_ids = generate_text_simple(\n            model=model, idx=encoded,\n            max_new_tokens=50, context_size=context_size\n        )\n    decoded_text = token_ids_to_text(token_ids, tokenizer)\n    print(decoded_text.replace(\"\\n\", \" \"))  # Compact print format\n    model.train()\n\nNow, let’s train the LLM using the training function defined above:\n\n# Note:\n# Uncomment the following code to calculate the execution time\n# import time\n# start_time = time.time()\n\ntorch.manual_seed(123)\nmodel = GPTModel(GPT_CONFIG_124M)\nmodel.to(device)\noptimizer = torch.optim.AdamW(model.parameters(), lr=0.0004, weight_decay=0.1)\n\nnum_epochs = 10\ntrain_losses, val_losses, tokens_seen = train_model_simple(\n    model, train_loader, val_loader, optimizer, device,\n    num_epochs=num_epochs, eval_freq=5, eval_iter=5,\n    start_context=\"Every effort moves you\", tokenizer=tokenizer\n)\n\n# Note:\n# Uncomment the following code to show the execution time\n# end_time = time.time()\n# execution_time_minutes = (end_time - start_time) / 60\n# print(f\"Training completed in {execution_time_minutes:.2f} minutes.\")\nEp 1 (Step 000000): Train loss 9.781, Val loss 9.933\nEp 1 (Step 000005): Train loss 8.111, Val loss 8.339\nEvery effort moves you,,,,,,,,,,,,.                                     \nEp 2 (Step 000010): Train loss 6.661, Val loss 7.048\nEp 2 (Step 000015): Train loss 5.961, Val loss 6.616\nEvery effort moves you, and, and, and, and, and, and, and, and, and, and, and, and, and, and, and, and, and, and, and, and, and, and,, and, and,\nEp 3 (Step 000020): Train loss 5.726, Val loss 6.600\nEp 3 (Step 000025): Train loss 5.201, Val loss 6.348\nEvery effort moves you, and I had been.                                            \nEp 4 (Step 000030): Train loss 4.417, Val loss 6.278\nEp 4 (Step 000035): Train loss 4.069, Val loss 6.226\nEvery effort moves you know the                          \"I he had the donkey and I had the and I had the donkey and down the room, I had\nEp 5 (Step 000040): Train loss 3.732, Val loss 6.160\nEvery effort moves you know it was not that the picture--I had the fact by the last I had been--his, and in the            \"Oh, and he said, and down the room, and in\nEp 6 (Step 000045): Train loss 2.850, Val loss 6.179\nEp 6 (Step 000050): Train loss 2.427, Val loss 6.141\nEvery effort moves you know,\" was one of the picture. The--I had a little of a little: \"Yes, and in fact, and in the picture was, and I had been at my elbow and as his pictures, and down the room, I had\nEp 7 (Step 000055): Train loss 2.104, Val loss 6.134\nEp 7 (Step 000060): Train loss 1.882, Val loss 6.233\nEvery effort moves you know,\" was one of the picture for nothing--I told Mrs.  \"I was no--as! The women had been, in the moment--as Jack himself, as once one had been the donkey, and were, and in his\nEp 8 (Step 000065): Train loss 1.320, Val loss 6.238\nEp 8 (Step 000070): Train loss 0.985, Val loss 6.242\nEvery effort moves you know,\" was one of the axioms he had been the tips of a self-confident moustache, I felt to see a smile behind his close grayish beard--as if he had the donkey. \"strongest,\" as his\nEp 9 (Step 000075): Train loss 0.717, Val loss 6.293\nEp 9 (Step 000080): Train loss 0.541, Val loss 6.393\nEvery effort moves you?\"  \"Yes--quite insensible to the irony. She wanted him vindicated--and by me!\"  He laughed again, and threw back the window-curtains, I had the donkey. \"There were days when I\nEp 10 (Step 000085): Train loss 0.391, Val loss 6.452\nEvery effort moves you know,\" was one of the axioms he laid down across the Sevres and silver of an exquisitely appointed luncheon-table, when, on a later day, I had again run over from Monte Carlo; and Mrs. Gis\n\nNote that you might get slightly different loss values on your computer, which is not a reason for concern if they are roughly similar (a training loss below 1 and a validation loss below 7)\nSmall differences can often be due to different GPU hardware and CUDA versions or small changes in newer PyTorch versions\nEven if you are running the example on a CPU, you may observe slight differences; a possible reason for a discrepancy is the differing behavior of nn.Dropout across operating systems, depending on how PyTorch was compiled, as discussed here on the PyTorch issue tracker\n\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import MaxNLocator\n\n\ndef plot_losses(epochs_seen, tokens_seen, train_losses, val_losses):\n    fig, ax1 = plt.subplots(figsize=(5, 3))\n\n    # Plot training and validation loss against epochs\n    ax1.plot(epochs_seen, train_losses, label=\"Training loss\")\n    ax1.plot(epochs_seen, val_losses, linestyle=\"-.\", label=\"Validation loss\")\n    ax1.set_xlabel(\"Epochs\")\n    ax1.set_ylabel(\"Loss\")\n    ax1.legend(loc=\"upper right\")\n    ax1.xaxis.set_major_locator(MaxNLocator(integer=True))  # only show integer labels on x-axis\n\n    # Create a second x-axis for tokens seen\n    ax2 = ax1.twiny()  # Create a second x-axis that shares the same y-axis\n    ax2.plot(tokens_seen, train_losses, alpha=0)  # Invisible plot for aligning ticks\n    ax2.set_xlabel(\"Tokens seen\")\n\n    fig.tight_layout()  # Adjust layout to make room\n    plt.savefig(\"loss-plot.pdf\")\n    plt.show()\n\nepochs_tensor = torch.linspace(0, num_epochs, len(train_losses))\nplot_losses(epochs_tensor, tokens_seen, train_losses, val_losses)\n\n\n\npng\n\n\n\nLooking at the results above, we can see that the model starts out generating incomprehensible strings of words, whereas towards the end, it’s able to produce grammatically more or less correct sentences\nHowever, based on the training and validation set losses, we can see that the model starts overfitting\nIf we were to check a few passages it writes towards the end, we would find that they are contained in the training set verbatim – it simply memorizes the training data\nLater, we will cover decoding strategies that can mitigate this memorization by a certain degree\nNote that the overfitting here occurs because we have a very, very small training set, and we iterate over it so many times\n\nThe LLM training here primarily serves educational purposes; we mainly want to see that the model can learn to produce coherent text\nInstead of spending weeks or months on training this model on vast amounts of expensive hardware, we load pretrained weights later\n\n\n\nIf you are interested in augmenting this training function with more advanced techniques, such as learning rate warmup, cosine annealing, and gradient clipping, please refer to Appendix D\nIf you are interested in a larger training dataset and longer training run, see ../03_bonus_pretraining_on_gutenberg"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#decoding-strategies-to-control-randomness",
    "href": "posts/LLM-From-Scratch/index.html#decoding-strategies-to-control-randomness",
    "title": "LLM From Scratch",
    "section": "5.3 Decoding strategies to control randomness",
    "text": "5.3 Decoding strategies to control randomness\n\nInference is relatively cheap with a relatively small LLM as the GPT model we trained above, so there’s no need to use a GPU for it in case you used a GPU for training it above\nUsing the generate_text_simple function (from the previous chapter) that we used earlier inside the simple training function, we can generate new text one word (or token) at a time\nAs explained in section 5.1.2, the next generated token is the token corresponding to the largest probability score among all tokens in the vocabulary\n\nmodel.to(\"cpu\")\nmodel.eval()\n\ntokenizer = tiktoken.get_encoding(\"gpt2\")\n\ntoken_ids = generate_text_simple(\n    model=model,\n    idx=text_to_token_ids(\"Every effort moves you\", tokenizer),\n    max_new_tokens=25,\n    context_size=GPT_CONFIG_124M[\"context_length\"]\n)\n\nprint(\"Output text:\\n\", token_ids_to_text(token_ids, tokenizer))\nOutput text:\n Every effort moves you know,\" was one of the axioms he laid down across the Sevres and silver of an exquisitely appointed lun\n\nEven if we execute the generate_text_simple function above multiple times, the LLM will always generate the same outputs\nWe now introduce two concepts, so-called decoding strategies, to modify the generate_text_simple: temperature scaling and top-k sampling\nThese will allow the model to control the randomness and diversity of the generated text\n\n\n5.3.1 Temperature scaling\n\nPreviously, we always sampled the token with the highest probability as the next token using torch.argmax\nTo add variety, we can sample the next token using The torch.multinomial(probs, num_samples=1), sampling from a probability distribution\nHere, each index’s chance of being picked corresponds to its probability in the input tensor\nHere’s a little recap of generating the next token, assuming a very small vocabulary for illustration purposes:\n\nvocab = { \n    \"closer\": 0,\n    \"every\": 1, \n    \"effort\": 2, \n    \"forward\": 3,\n    \"inches\": 4,\n    \"moves\": 5, \n    \"pizza\": 6,\n    \"toward\": 7,\n    \"you\": 8,\n} \n\ninverse_vocab = {v: k for k, v in vocab.items()}\n\n# Suppose input is \"every effort moves you\", and the LLM\n# returns the following logits for the next token:\nnext_token_logits = torch.tensor(\n    [4.51, 0.89, -1.90, 6.75, 1.63, -1.62, -1.89, 6.28, 1.79]\n)\n\nprobas = torch.softmax(next_token_logits, dim=0)\nnext_token_id = torch.argmax(probas).item()\n\n# The next generated token is then as follows:\nprint(inverse_vocab[next_token_id])\nforward\ntorch.manual_seed(123)\nnext_token_id = torch.multinomial(probas, num_samples=1).item()\nprint(inverse_vocab[next_token_id])\nforward\n\nInstead of determining the most likely token via torch.argmax, we use torch.multinomial(probas, num_samples=1) to determine the most likely token by sampling from the softmax distribution\nFor illustration purposes, let’s see what happens when we sample the next token 1,000 times using the original softmax probabilities:\n\ndef print_sampled_tokens(probas):\n    torch.manual_seed(123) # Manual seed for reproducibility\n    sample = [torch.multinomial(probas, num_samples=1).item() for i in range(1_000)]\n    sampled_ids = torch.bincount(torch.tensor(sample), minlength=len(probas))\n    for i, freq in enumerate(sampled_ids):\n        print(f\"{freq} x {inverse_vocab[i]}\")\n\nprint_sampled_tokens(probas)\n73 x closer\n0 x every\n0 x effort\n582 x forward\n2 x inches\n0 x moves\n0 x pizza\n343 x toward\n0 x you\n\nWe can control the distribution and selection process via a concept called temperature scaling\n“Temperature scaling” is just a fancy word for dividing the logits by a number greater than 0\nTemperatures greater than 1 will result in more uniformly distributed token probabilities after applying the softmax\nTemperatures smaller than 1 will result in more confident (sharper or more peaky) distributions after applying the softmax\nNote that the resulting dropout outputs may look different depending on your operating system; you can read more about this inconsistency here on the PyTorch issue tracker\n\ndef softmax_with_temperature(logits, temperature):\n    scaled_logits = logits / temperature\n    return torch.softmax(scaled_logits, dim=0)\n\n# Temperature values\ntemperatures = [1, 0.1, 5]  # Original, higher confidence, and lower confidence\n\n# Calculate scaled probabilities\nscaled_probas = [softmax_with_temperature(next_token_logits, T) for T in temperatures]\n# Plotting\nx = torch.arange(len(vocab))\nbar_width = 0.15\n\nfig, ax = plt.subplots(figsize=(5, 3))\nfor i, T in enumerate(temperatures):\n    rects = ax.bar(x + i * bar_width, scaled_probas[i], bar_width, label=f'Temperature = {T}')\n\nax.set_ylabel('Probability')\nax.set_xticks(x)\nax.set_xticklabels(vocab.keys(), rotation=90)\nax.legend()\n\nplt.tight_layout()\nplt.savefig(\"temperature-plot.pdf\")\nplt.show()\n\n\n\npng\n\n\n\nWe can see that the rescaling via temperature 0.1 results in a sharper distribution, approaching torch.argmax, such that the most likely word is almost always selected:\n\nprint_sampled_tokens(scaled_probas[1])\n0 x closer\n0 x every\n0 x effort\n985 x forward\n0 x inches\n0 x moves\n0 x pizza\n15 x toward\n0 x you\n\nThe rescaled probabilities via temperature 5 are more uniformly distributed:\n\nprint_sampled_tokens(scaled_probas[2])\n165 x closer\n75 x every\n42 x effort\n239 x forward\n71 x inches\n46 x moves\n32 x pizza\n227 x toward\n103 x you\n\nAssuming an LLM input “every effort moves you”, using the approach above can sometimes result in nonsensical texts, such as “every effort moves you pizza”, 3.2% of the time (32 out of 1000 times)\n\n\n\n5.3.2 Top-k sampling\n\nTo be able to use higher temperatures to increase output diversity and to reduce the probability of nonsensical sentences, we can restrict the sampled tokens to the top-k most likely tokens:\n\n\n\n(Please note that the numbers in this figure are truncated to two digits after the decimal point to reduce visual clutter. The values in the Softmax row should add up to 1.0.)\nIn code, we can implement this as follows:\n\ntop_k = 3\ntop_logits, top_pos = torch.topk(next_token_logits, top_k)\n\nprint(\"Top logits:\", top_logits)\nprint(\"Top positions:\", top_pos)\nTop logits: tensor([6.7500, 6.2800, 4.5100])\nTop positions: tensor([3, 7, 0])\nnew_logits = torch.where(\n    condition=next_token_logits &lt; top_logits[-1],\n    input=torch.tensor(float(\"-inf\")), \n    other=next_token_logits\n)\n\nprint(new_logits)\ntensor([4.5100,   -inf,   -inf, 6.7500,   -inf,   -inf,   -inf, 6.2800,   -inf])\n\nNOTE:\nAn alternative, slightly more efficient implementation of the previous code cell is the following:\nnew_logits = torch.full_like( # create tensor containing -inf values\n   next_token_logits, -torch.inf\n)   \nnew_logits[top_pos] = next_token_logits[top_pos] # copy top k values into the -inf tensor\n For more details, see https://github.com/rasbt/LLMs-from-scratch/discussions/326\n\ntopk_probas = torch.softmax(new_logits, dim=0)\nprint(topk_probas)\ntensor([0.0615, 0.0000, 0.0000, 0.5775, 0.0000, 0.0000, 0.0000, 0.3610, 0.0000])\n\n\n5.3.3 Modifying the text generation function\n\nThe previous two subsections introduced temperature sampling and top-k sampling\nLet’s use these two concepts to modify the generate_simple function we used to generate text via the LLM earlier, creating a new generate function:\n\ndef generate(model, idx, max_new_tokens, context_size, temperature=0.0, top_k=None, eos_id=None):\n\n    # For-loop is the same as before: Get logits, and only focus on last time step\n    for _ in range(max_new_tokens):\n        idx_cond = idx[:, -context_size:]\n        with torch.no_grad():\n            logits = model(idx_cond)\n        logits = logits[:, -1, :]\n\n        # New: Filter logits with top_k sampling\n        if top_k is not None:\n            # Keep only top_k values\n            top_logits, _ = torch.topk(logits, top_k)\n            min_val = top_logits[:, -1]\n            logits = torch.where(logits &lt; min_val, torch.tensor(float(\"-inf\")).to(logits.device), logits)\n\n        # New: Apply temperature scaling\n        if temperature &gt; 0.0:\n            logits = logits / temperature\n\n            # Apply softmax to get probabilities\n            probs = torch.softmax(logits, dim=-1)  # (batch_size, context_len)\n\n            # Sample from the distribution\n            idx_next = torch.multinomial(probs, num_samples=1)  # (batch_size, 1)\n\n        # Otherwise same as before: get idx of the vocab entry with the highest logits value\n        else:\n            idx_next = torch.argmax(logits, dim=-1, keepdim=True)  # (batch_size, 1)\n\n        if idx_next == eos_id:  # Stop generating early if end-of-sequence token is encountered and eos_id is specified\n            break\n\n        # Same as before: append sampled index to the running sequence\n        idx = torch.cat((idx, idx_next), dim=1)  # (batch_size, num_tokens+1)\n\n    return idx\ntorch.manual_seed(123)\n\ntoken_ids = generate(\n    model=model,\n    idx=text_to_token_ids(\"Every effort moves you\", tokenizer),\n    max_new_tokens=15,\n    context_size=GPT_CONFIG_124M[\"context_length\"],\n    top_k=25,\n    temperature=1.4\n)\n\nprint(\"Output text:\\n\", token_ids_to_text(token_ids, tokenizer))\nOutput text:\n Every effort moves you stand to work on surprise, a one of us had gone with random-"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#loading-and-saving-model-weights-in-pytorch",
    "href": "posts/LLM-From-Scratch/index.html#loading-and-saving-model-weights-in-pytorch",
    "title": "LLM From Scratch",
    "section": "5.4 Loading and saving model weights in PyTorch",
    "text": "5.4 Loading and saving model weights in PyTorch\n\nTraining LLMs is computationally expensive, so it’s crucial to be able to save and load LLM weights\n\n\n\nThe recommended way in PyTorch is to save the model weights, the so-called state_dict via by applying the torch.save function to the .state_dict() method:\n\ntorch.save(model.state_dict(), \"model.pth\")\n\nThen we can load the model weights into a new GPTModel model instance as follows:\n\nmodel = GPTModel(GPT_CONFIG_124M)\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nmodel.load_state_dict(torch.load(\"model.pth\", map_location=device, weights_only=True))\nmodel.eval();\n\nIt’s common to train LLMs with adaptive optimizers like Adam or AdamW instead of regular SGD\nThese adaptive optimizers store additional parameters for each model weight, so it makes sense to save them as well in case we plan to continue the pretraining later:\n\ntorch.save({\n    \"model_state_dict\": model.state_dict(),\n    \"optimizer_state_dict\": optimizer.state_dict(),\n    }, \n    \"model_and_optimizer.pth\"\n)\ncheckpoint = torch.load(\"model_and_optimizer.pth\", weights_only=True)\n\nmodel = GPTModel(GPT_CONFIG_124M)\nmodel.load_state_dict(checkpoint[\"model_state_dict\"])\n\noptimizer = torch.optim.AdamW(model.parameters(), lr=0.0005, weight_decay=0.1)\noptimizer.load_state_dict(checkpoint[\"optimizer_state_dict\"])\nmodel.train();"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#loading-pretrained-weights-from-openai",
    "href": "posts/LLM-From-Scratch/index.html#loading-pretrained-weights-from-openai",
    "title": "LLM From Scratch",
    "section": "5.5 Loading pretrained weights from OpenAI",
    "text": "5.5 Loading pretrained weights from OpenAI\n\nPreviously, we only trained a small GPT-2 model using a very small short-story book for educational purposes\nInterested readers can also find a longer pretraining run on the complete Project Gutenberg book corpus in ../03_bonus_pretraining_on_gutenberg\nFortunately, we don’t have to spend tens to hundreds of thousands of dollars to pretrain the model on a large pretraining corpus but can load the pretrained weights provided by OpenAI\n\n\n\n⚠️ Note: Some users may encounter issues in this section due to TensorFlow compatibility problems, particularly on certain Windows systems. TensorFlow is required here only to load the original OpenAI GPT-2 weight files, which we then convert to PyTorch. If you’re running into TensorFlow-related issues, you can use the alternative code below instead of the remaining code in this section. This alternative is based on pre-converted PyTorch weights, created using the same conversion process described in the previous section. For details, refer to the notebook: ../02_alternative_weight_loading/weight-loading-pytorch.ipynb notebook.\nfile_name = \"gpt2-small-124M.pth\"\n# file_name = \"gpt2-medium-355M.pth\"\n# file_name = \"gpt2-large-774M.pth\"\n# file_name = \"gpt2-xl-1558M.pth\"\n\nurl = f\"https://huggingface.co/rasbt/gpt2-from-scratch-pytorch/resolve/main/{file_name}\"\n\nif not os.path.exists(file_name):\n    urllib.request.urlretrieve(url, file_name)\n    print(f\"Downloaded to {file_name}\")\n\ngpt = GPTModel(BASE_CONFIG)\ngpt.load_state_dict(torch.load(file_name, weights_only=True))\ngpt.eval()\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\ngpt.to(device);\n\n\ntorch.manual_seed(123)\n\ntoken_ids = generate(\n    model=gpt,\n    idx=text_to_token_ids(\"Every effort moves you\", tokenizer).to(device),\n    max_new_tokens=25,\n    context_size=NEW_CONFIG[\"context_length\"],\n    top_k=50,\n    temperature=1.5\n)\n\nprint(\"Output text:\\n\", token_ids_to_text(token_ids, tokenizer))\n\n\n\nFirst, some boilerplate code to download the files from OpenAI and load the weights into Python\nSince OpenAI used TensorFlow, we will have to install and use TensorFlow for loading the weights; tqdm is a progress bar library\nUncomment and run the next cell to install the required libraries\n\n# pip install tensorflow tqdm\nprint(\"TensorFlow version:\", version(\"tensorflow\"))\nprint(\"tqdm version:\", version(\"tqdm\"))\nTensorFlow version: 2.18.0\ntqdm version: 4.67.1\n# Relative import from the gpt_download.py contained in this folder\n\nfrom gpt_download import download_and_load_gpt2\n# Alternatively:\n# from llms_from_scratch.ch05 import download_and_load_gpt2\n\nNote\n\nIn very rare cases, the code cell above may result in a zsh: illegal hardware instruction python error, which could be due to a TensorFlow installation issue on your machine\nA reader found that installing TensorFlow via conda solved the issue in this specific case, as mentioned here\nYou can find more instructions in this supplementary Python setup tutorial\n\n\n\nWe can then download the model weights for the 124 million parameter model as follows:\n\nsettings, params = download_and_load_gpt2(model_size=\"124M\", models_dir=\"gpt2\")\ncheckpoint: 100%|████████████████████████████████████████████████████████████████████████████████| 77.0/77.0 [00:00&lt;00:00, 63.1kiB/s]\nencoder.json: 100%|████████████████████████████████████████████████████████████████████████████| 1.04M/1.04M [00:00&lt;00:00, 4.69MiB/s]\nhparams.json: 100%|██████████████████████████████████████████████████████████████████████████████| 90.0/90.0 [00:00&lt;00:00, 59.7kiB/s]\nmodel.ckpt.data-00000-of-00001: 100%|████████████████████████████████████████████████████████████| 498M/498M [01:09&lt;00:00, 7.15MiB/s]\nmodel.ckpt.index: 100%|████████████████████████████████████████████████████████████████████████| 5.21k/5.21k [00:00&lt;00:00, 2.32MiB/s]\nmodel.ckpt.meta: 100%|███████████████████████████████████████████████████████████████████████████| 471k/471k [00:00&lt;00:00, 2.19MiB/s]\nvocab.bpe: 100%|█████████████████████████████████████████████████████████████████████████████████| 456k/456k [00:00&lt;00:00, 3.47MiB/s]\nprint(\"Settings:\", settings)\nSettings: {'n_vocab': 50257, 'n_ctx': 1024, 'n_embd': 768, 'n_head': 12, 'n_layer': 12}\nprint(\"Parameter dictionary keys:\", params.keys())\nParameter dictionary keys: dict_keys(['blocks', 'b', 'g', 'wpe', 'wte'])\nprint(params[\"wte\"])\nprint(\"Token embedding weight tensor dimensions:\", params[\"wte\"].shape)\n[[-0.11010301 -0.03926672  0.03310751 ... -0.1363697   0.01506208\n   0.04531523]\n [ 0.04034033 -0.04861503  0.04624869 ...  0.08605453  0.00253983\n   0.04318958]\n [-0.12746179  0.04793796  0.18410145 ...  0.08991534 -0.12972379\n  -0.08785918]\n ...\n [-0.04453601 -0.05483596  0.01225674 ...  0.10435229  0.09783269\n  -0.06952604]\n [ 0.1860082   0.01665728  0.04611587 ... -0.09625227  0.07847701\n  -0.02245961]\n [ 0.05135201 -0.02768905  0.0499369  ...  0.00704835  0.15519823\n   0.12067825]]\nToken embedding weight tensor dimensions: (50257, 768)\n\nAlternatively, “355M”, “774M”, and “1558M” are also supported model_size arguments\nThe difference between these differently sized models is summarized in the figure below:\n\n\n\nAbove, we loaded the 124M GPT-2 model weights into Python, however we still need to transfer them into our GPTModel instance\nFirst, we initialize a new GPTModel instance\nNote that the original GPT model initialized the linear layers for the query, key, and value matrices in the multi-head attention module with bias vectors, which is not required or recommended; however, to be able to load the weights correctly, we have to enable these too by setting qkv_bias to True in our implementation, too\nWe are also using the 1024 token context length that was used by the original GPT-2 model(s)\n\n# Define model configurations in a dictionary for compactness\nmodel_configs = {\n    \"gpt2-small (124M)\": {\"emb_dim\": 768, \"n_layers\": 12, \"n_heads\": 12},\n    \"gpt2-medium (355M)\": {\"emb_dim\": 1024, \"n_layers\": 24, \"n_heads\": 16},\n    \"gpt2-large (774M)\": {\"emb_dim\": 1280, \"n_layers\": 36, \"n_heads\": 20},\n    \"gpt2-xl (1558M)\": {\"emb_dim\": 1600, \"n_layers\": 48, \"n_heads\": 25},\n}\n\n# Copy the base configuration and update with specific model settings\nmodel_name = \"gpt2-small (124M)\"  # Example model name\nNEW_CONFIG = GPT_CONFIG_124M.copy()\nNEW_CONFIG.update(model_configs[model_name])\nNEW_CONFIG.update({\"context_length\": 1024, \"qkv_bias\": True})\n\ngpt = GPTModel(NEW_CONFIG)\ngpt.eval();\n\nThe next task is to assign the OpenAI weights to the corresponding weight tensors in our GPTModel instance\n\ndef assign(left, right):\n    if left.shape != right.shape:\n        raise ValueError(f\"Shape mismatch. Left: {left.shape}, Right: {right.shape}\")\n    return torch.nn.Parameter(torch.tensor(right))\nimport numpy as np\n\ndef load_weights_into_gpt(gpt, params):\n    gpt.pos_emb.weight = assign(gpt.pos_emb.weight, params['wpe'])\n    gpt.tok_emb.weight = assign(gpt.tok_emb.weight, params['wte'])\n    \n    for b in range(len(params[\"blocks\"])):\n        q_w, k_w, v_w = np.split(\n            (params[\"blocks\"][b][\"attn\"][\"c_attn\"])[\"w\"], 3, axis=-1)\n        gpt.trf_blocks[b].att.W_query.weight = assign(\n            gpt.trf_blocks[b].att.W_query.weight, q_w.T)\n        gpt.trf_blocks[b].att.W_key.weight = assign(\n            gpt.trf_blocks[b].att.W_key.weight, k_w.T)\n        gpt.trf_blocks[b].att.W_value.weight = assign(\n            gpt.trf_blocks[b].att.W_value.weight, v_w.T)\n\n        q_b, k_b, v_b = np.split(\n            (params[\"blocks\"][b][\"attn\"][\"c_attn\"])[\"b\"], 3, axis=-1)\n        gpt.trf_blocks[b].att.W_query.bias = assign(\n            gpt.trf_blocks[b].att.W_query.bias, q_b)\n        gpt.trf_blocks[b].att.W_key.bias = assign(\n            gpt.trf_blocks[b].att.W_key.bias, k_b)\n        gpt.trf_blocks[b].att.W_value.bias = assign(\n            gpt.trf_blocks[b].att.W_value.bias, v_b)\n\n        gpt.trf_blocks[b].att.out_proj.weight = assign(\n            gpt.trf_blocks[b].att.out_proj.weight, \n            params[\"blocks\"][b][\"attn\"][\"c_proj\"][\"w\"].T)\n        gpt.trf_blocks[b].att.out_proj.bias = assign(\n            gpt.trf_blocks[b].att.out_proj.bias, \n            params[\"blocks\"][b][\"attn\"][\"c_proj\"][\"b\"])\n\n        gpt.trf_blocks[b].ff.layers[0].weight = assign(\n            gpt.trf_blocks[b].ff.layers[0].weight, \n            params[\"blocks\"][b][\"mlp\"][\"c_fc\"][\"w\"].T)\n        gpt.trf_blocks[b].ff.layers[0].bias = assign(\n            gpt.trf_blocks[b].ff.layers[0].bias, \n            params[\"blocks\"][b][\"mlp\"][\"c_fc\"][\"b\"])\n        gpt.trf_blocks[b].ff.layers[2].weight = assign(\n            gpt.trf_blocks[b].ff.layers[2].weight, \n            params[\"blocks\"][b][\"mlp\"][\"c_proj\"][\"w\"].T)\n        gpt.trf_blocks[b].ff.layers[2].bias = assign(\n            gpt.trf_blocks[b].ff.layers[2].bias, \n            params[\"blocks\"][b][\"mlp\"][\"c_proj\"][\"b\"])\n\n        gpt.trf_blocks[b].norm1.scale = assign(\n            gpt.trf_blocks[b].norm1.scale, \n            params[\"blocks\"][b][\"ln_1\"][\"g\"])\n        gpt.trf_blocks[b].norm1.shift = assign(\n            gpt.trf_blocks[b].norm1.shift, \n            params[\"blocks\"][b][\"ln_1\"][\"b\"])\n        gpt.trf_blocks[b].norm2.scale = assign(\n            gpt.trf_blocks[b].norm2.scale, \n            params[\"blocks\"][b][\"ln_2\"][\"g\"])\n        gpt.trf_blocks[b].norm2.shift = assign(\n            gpt.trf_blocks[b].norm2.shift, \n            params[\"blocks\"][b][\"ln_2\"][\"b\"])\n\n    gpt.final_norm.scale = assign(gpt.final_norm.scale, params[\"g\"])\n    gpt.final_norm.shift = assign(gpt.final_norm.shift, params[\"b\"])\n    gpt.out_head.weight = assign(gpt.out_head.weight, params[\"wte\"])\n    \n    \nload_weights_into_gpt(gpt, params)\ngpt.to(device);\n\nIf the model is loaded correctly, we can use it to generate new text using our previous generate function:\n\ntorch.manual_seed(123)\n\ntoken_ids = generate(\n    model=gpt,\n    idx=text_to_token_ids(\"Every effort moves you\", tokenizer).to(device),\n    max_new_tokens=25,\n    context_size=NEW_CONFIG[\"context_length\"],\n    top_k=50,\n    temperature=1.5\n)\n\nprint(\"Output text:\\n\", token_ids_to_text(token_ids, tokenizer))\nOutput text:\n Every effort moves you toward finding an ideal new way to practice something!\n\nWhat makes us want to be on top of that?\n\nWe know that we loaded the model weights correctly because the model can generate coherent text; if we made even a small mistake, the model would not be able to do that\nFor an alternative way to load the weights from the Hugging Face Hub, see ../02_alternative_weight_loading\nIf you are interested in seeing how the GPT architecture compares to the Llama architecture (a popular LLM developed by Meta AI), see the bonus content at ../07_gpt_to_llama"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#summary-and-takeaways-4",
    "href": "posts/LLM-From-Scratch/index.html#summary-and-takeaways-4",
    "title": "LLM From Scratch",
    "section": "Summary and takeaways",
    "text": "Summary and takeaways\n\nSee the ./gpt_class_finetune.py script, a self-contained script for classification finetuning\nYou can find the exercise solutions in ./exercise-solutions.ipynb\nIn addition, interested readers can find an introduction to parameter-efficient training with low-rank adaptation (LoRA) in appendix E"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#introduction-to-instruction-finetuning",
    "href": "posts/LLM-From-Scratch/index.html#introduction-to-instruction-finetuning",
    "title": "LLM From Scratch",
    "section": "7.1 Introduction to instruction finetuning",
    "text": "7.1 Introduction to instruction finetuning\n\nIn chapter 5, we saw that pretraining an LLM involves a training procedure where it learns to generate one word at a time\nHence, a pretrained LLM is good at text completion, but it is not good at following instructions\nIn this chapter, we teach the LLM to follow instructions better\n\n\n\nThe topics covered in this chapter are summarized in the figure below"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#preparing-a-dataset-for-supervised-instruction-finetuning",
    "href": "posts/LLM-From-Scratch/index.html#preparing-a-dataset-for-supervised-instruction-finetuning",
    "title": "LLM From Scratch",
    "section": "7.2 Preparing a dataset for supervised instruction finetuning",
    "text": "7.2 Preparing a dataset for supervised instruction finetuning\n\nWe will work with an instruction dataset I prepared for this chapter\n\n\n\nNumber of entries: 1100\n\n\n\nEach item in the data list we loaded from the JSON file above is a dictionary in the following form\n\n\n\nExample entry:\n {'instruction': 'Identify the correct spelling of the following word.', 'input': 'Ocassion', 'output': \"The correct spelling is 'Occasion.'\"}\n\n\n\nNote that the 'input' field can be empty:\n\n\n\nAnother example entry:\n {'instruction': \"What is an antonym of 'complicated'?\", 'input': '', 'output': \"An antonym of 'complicated' is 'simple'.\"}\n\n\n\nInstruction finetuning is often referred to as “supervised instruction finetuning” because it involves training a model on a dataset where the input-output pairs are explicitly provided\nThere are different ways to format the entries as inputs to the LLM; the figure below illustrates two example formats that were used for training the Alpaca (https://crfm.stanford.edu/2023/03/13/alpaca.html) and Phi-3 (https://arxiv.org/abs/2404.14219) LLMs, respectively\n\n\n\nIn this chapter, we use Alpaca-style prompt formatting, which was the original prompt template for instruction finetuning\nBelow, we format the input that we will pass as input to the LLM\nA formatted response with input field looks like as shown below\n\n\n\nBelow is an instruction that describes a task. Write a response that appropriately completes the request.\n\n### Instruction:\nIdentify the correct spelling of the following word.\n\n### Input:\nOcassion\n\n### Response:\nThe correct spelling is 'Occasion.'\n\n\n\nBelow is a formatted response without an input field\n\n\n\nBelow is an instruction that describes a task. Write a response that appropriately completes the request.\n\n### Instruction:\nWhat is an antonym of 'complicated'?\n\n### Response:\nAn antonym of 'complicated' is 'simple'.\n\n\n\nLastly, before we prepare the PyTorch data loaders in the next section, we divide the dataset into a training, validation, and test set\n\n\n\nTraining set length: 935\nValidation set length: 55\nTest set length: 110"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#organizing-data-into-training-batches",
    "href": "posts/LLM-From-Scratch/index.html#organizing-data-into-training-batches",
    "title": "LLM From Scratch",
    "section": "7.3 Organizing data into training batches",
    "text": "7.3 Organizing data into training batches\n\n\nWe tackle this dataset batching in several steps, as summarized in the figure below\n\n\n\nFirst, we implement an InstructionDataset class that pre-tokenizes all inputs in the dataset, similar to the SpamDataset in chapter 6\n\n\n\nSimilar to chapter 6, we want to collect multiple training examples in a batch to accelerate training; this requires padding all inputs to a similar length\nAlso similar to the previous chapter, we use the &lt;|endoftext|&gt; token as a padding token\n\n\n\n[50256]\n\n\n\nIn chapter 6, we padded all examples in a dataset to the same length\n\nHere, we take a more sophisticated approach and develop a custom “collate” function that we can pass to the data loader\nThis custom collate function pads the training examples in each batch to have the same length (but different batches can have different lengths)\n\n\n\n\n\ntensor([[    0,     1,     2,     3,     4],\n        [    5,     6, 50256, 50256, 50256],\n        [    7,     8,     9, 50256, 50256]])\n\n\n\n\nAbove, we only returned the inputs to the LLM; however, for LLM training, we also need the target values\nSimilar to pretraining an LLM, the targets are the inputs shifted by 1 position to the right, so the LLM learns to predict the next token\n\n\n\n\ntensor([[    0,     1,     2,     3,     4],\n        [    5,     6, 50256, 50256, 50256],\n        [    7,     8,     9, 50256, 50256]])\ntensor([[    1,     2,     3,     4, 50256],\n        [    6, 50256, 50256, 50256, 50256],\n        [    8,     9, 50256, 50256, 50256]])\n\n\n\nNext, we introduce an ignore_index value to replace all padding token IDs with a new value; the purpose of this ignore_index is that we can ignore padding values in the loss function (more on that later)\n\n\n\nConcretely, this means that we replace the token IDs corresponding to 50256 with -100 as illustrated below\n\n\n\n(In addition, we also introduce the allowed_max_length in case we want to limit the length of the samples; this will be useful if you plan to work with your own datasets that are longer than the 1024 token context size supported by the GPT-2 model)\n\n\n\ntensor([[    0,     1,     2,     3,     4],\n        [    5,     6, 50256, 50256, 50256],\n        [    7,     8,     9, 50256, 50256]])\ntensor([[    1,     2,     3,     4, 50256],\n        [    6, 50256,  -100,  -100,  -100],\n        [    8,     9, 50256,  -100,  -100]])\n\n\n\nLet’s see what this replacement by -100 accomplishes\nFor illustration purposes, let’s assume we have a small classification task with 2 class labels, 0 and 1, similar to chapter 6\nIf we have the following logits values (outputs of the last layer of the model), we calculate the following loss\n\n\n\ntensor(1.1269)\n\n\n\nNow, adding one more training example will, as expected, influence the loss\n\n\n\ntensor(0.7936)\n\n\n\nLet’s see what happens if we replace the class label of one of the examples with -100\n\n\n\ntensor(1.1269)\nloss_1 == loss_3: tensor(True)\n\n\n\nAs we can see, the resulting loss on these 3 training examples is the same as the loss we calculated from the 2 training examples, which means that the cross-entropy loss function ignored the training example with the -100 label\nBy default, PyTorch has the cross_entropy(..., ignore_index=-100) setting to ignore examples corresponding to the label -100\nUsing this -100 ignore_index, we can ignore the additional end-of-text (padding) tokens in the batches that we used to pad the training examples to equal length\nHowever, we don’t want to ignore the first instance of the end-of-text (padding) token (50256) because it can help signal to the LLM when the response is complete\nIn practice, it is also common to mask out the target token IDs that correspond to the instruction, as illustrated in the figure below (this is a recommended reader exercise after completing the chapter)"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#creating-data-loaders-for-an-instruction-dataset",
    "href": "posts/LLM-From-Scratch/index.html#creating-data-loaders-for-an-instruction-dataset",
    "title": "LLM From Scratch",
    "section": "7.4 Creating data loaders for an instruction dataset",
    "text": "7.4 Creating data loaders for an instruction dataset\n\nIn this section, we use the InstructionDataset class and custom_collate_fn function to instantiate the training, validation, and test data loaders\n\n\n\nAnother additional detail of the previous custom_collate_fn function is that we now directly move the data to the target device (e.g., GPU) instead of doing it in the main training loop, which improves efficiency because it can be carried out as a background process when we use the custom_collate_fn as part of the data loader\nUsing the partial function from Python’s functools standard library, we create a new function with the device argument of the original function pre-filled\n\n\n\nDevice: cuda\n\n\n\nNext, we instantiate the data loaders similar to previous chapters, except that we now provide our own collate function for the batching process\nLet’s see what the dimensions of the resulting input and target batches look like\n\n\n\nTrain loader:\ntorch.Size([8, 61]) torch.Size([8, 61])\ntorch.Size([8, 76]) torch.Size([8, 76])\ntorch.Size([8, 73]) torch.Size([8, 73])\ntorch.Size([8, 68]) torch.Size([8, 68])\ntorch.Size([8, 65]) torch.Size([8, 65])\ntorch.Size([8, 72]) torch.Size([8, 72])\ntorch.Size([8, 80]) torch.Size([8, 80])\ntorch.Size([8, 67]) torch.Size([8, 67])\ntorch.Size([8, 62]) torch.Size([8, 62])\ntorch.Size([8, 75]) torch.Size([8, 75])\ntorch.Size([8, 62]) torch.Size([8, 62])\ntorch.Size([8, 68]) torch.Size([8, 68])\ntorch.Size([8, 67]) torch.Size([8, 67])\ntorch.Size([8, 77]) torch.Size([8, 77])\ntorch.Size([8, 69]) torch.Size([8, 69])\ntorch.Size([8, 79]) torch.Size([8, 79])\ntorch.Size([8, 71]) torch.Size([8, 71])\ntorch.Size([8, 66]) torch.Size([8, 66])\ntorch.Size([8, 83]) torch.Size([8, 83])\ntorch.Size([8, 68]) torch.Size([8, 68])\ntorch.Size([8, 80]) torch.Size([8, 80])\ntorch.Size([8, 71]) torch.Size([8, 71])\ntorch.Size([8, 69]) torch.Size([8, 69])\ntorch.Size([8, 65]) torch.Size([8, 65])\ntorch.Size([8, 68]) torch.Size([8, 68])\ntorch.Size([8, 60]) torch.Size([8, 60])\ntorch.Size([8, 59]) torch.Size([8, 59])\ntorch.Size([8, 69]) torch.Size([8, 69])\ntorch.Size([8, 63]) torch.Size([8, 63])\ntorch.Size([8, 65]) torch.Size([8, 65])\ntorch.Size([8, 76]) torch.Size([8, 76])\ntorch.Size([8, 66]) torch.Size([8, 66])\ntorch.Size([8, 71]) torch.Size([8, 71])\ntorch.Size([8, 91]) torch.Size([8, 91])\ntorch.Size([8, 65]) torch.Size([8, 65])\ntorch.Size([8, 64]) torch.Size([8, 64])\ntorch.Size([8, 67]) torch.Size([8, 67])\ntorch.Size([8, 66]) torch.Size([8, 66])\ntorch.Size([8, 64]) torch.Size([8, 64])\ntorch.Size([8, 65]) torch.Size([8, 65])\ntorch.Size([8, 75]) torch.Size([8, 75])\ntorch.Size([8, 89]) torch.Size([8, 89])\ntorch.Size([8, 59]) torch.Size([8, 59])\ntorch.Size([8, 88]) torch.Size([8, 88])\ntorch.Size([8, 83]) torch.Size([8, 83])\ntorch.Size([8, 83]) torch.Size([8, 83])\ntorch.Size([8, 70]) torch.Size([8, 70])\ntorch.Size([8, 65]) torch.Size([8, 65])\ntorch.Size([8, 74]) torch.Size([8, 74])\ntorch.Size([8, 76]) torch.Size([8, 76])\ntorch.Size([8, 67]) torch.Size([8, 67])\ntorch.Size([8, 75]) torch.Size([8, 75])\ntorch.Size([8, 83]) torch.Size([8, 83])\ntorch.Size([8, 69]) torch.Size([8, 69])\ntorch.Size([8, 67]) torch.Size([8, 67])\ntorch.Size([8, 60]) torch.Size([8, 60])\ntorch.Size([8, 60]) torch.Size([8, 60])\ntorch.Size([8, 66]) torch.Size([8, 66])\ntorch.Size([8, 80]) torch.Size([8, 80])\ntorch.Size([8, 71]) torch.Size([8, 71])\ntorch.Size([8, 61]) torch.Size([8, 61])\ntorch.Size([8, 58]) torch.Size([8, 58])\ntorch.Size([8, 71]) torch.Size([8, 71])\ntorch.Size([8, 67]) torch.Size([8, 67])\ntorch.Size([8, 68]) torch.Size([8, 68])\ntorch.Size([8, 63]) torch.Size([8, 63])\ntorch.Size([8, 87]) torch.Size([8, 87])\ntorch.Size([8, 68]) torch.Size([8, 68])\ntorch.Size([8, 64]) torch.Size([8, 64])\ntorch.Size([8, 68]) torch.Size([8, 68])\ntorch.Size([8, 71]) torch.Size([8, 71])\ntorch.Size([8, 68]) torch.Size([8, 68])\ntorch.Size([8, 71]) torch.Size([8, 71])\ntorch.Size([8, 61]) torch.Size([8, 61])\ntorch.Size([8, 65]) torch.Size([8, 65])\ntorch.Size([8, 67]) torch.Size([8, 67])\ntorch.Size([8, 65]) torch.Size([8, 65])\ntorch.Size([8, 64]) torch.Size([8, 64])\ntorch.Size([8, 60]) torch.Size([8, 60])\ntorch.Size([8, 72]) torch.Size([8, 72])\ntorch.Size([8, 64]) torch.Size([8, 64])\ntorch.Size([8, 70]) torch.Size([8, 70])\ntorch.Size([8, 57]) torch.Size([8, 57])\ntorch.Size([8, 72]) torch.Size([8, 72])\ntorch.Size([8, 64]) torch.Size([8, 64])\ntorch.Size([8, 68]) torch.Size([8, 68])\ntorch.Size([8, 62]) torch.Size([8, 62])\ntorch.Size([8, 74]) torch.Size([8, 74])\ntorch.Size([8, 80]) torch.Size([8, 80])\ntorch.Size([8, 68]) torch.Size([8, 68])\ntorch.Size([8, 70]) torch.Size([8, 70])\ntorch.Size([8, 91]) torch.Size([8, 91])\ntorch.Size([8, 61]) torch.Size([8, 61])\ntorch.Size([8, 66]) torch.Size([8, 66])\ntorch.Size([8, 80]) torch.Size([8, 80])\ntorch.Size([8, 81]) torch.Size([8, 81])\ntorch.Size([8, 74]) torch.Size([8, 74])\ntorch.Size([8, 82]) torch.Size([8, 82])\ntorch.Size([8, 63]) torch.Size([8, 63])\ntorch.Size([8, 83]) torch.Size([8, 83])\ntorch.Size([8, 68]) torch.Size([8, 68])\ntorch.Size([8, 67]) torch.Size([8, 67])\ntorch.Size([8, 77]) torch.Size([8, 77])\ntorch.Size([8, 91]) torch.Size([8, 91])\ntorch.Size([8, 64]) torch.Size([8, 64])\ntorch.Size([8, 61]) torch.Size([8, 61])\ntorch.Size([8, 75]) torch.Size([8, 75])\ntorch.Size([8, 64]) torch.Size([8, 64])\ntorch.Size([8, 66]) torch.Size([8, 66])\ntorch.Size([8, 78]) torch.Size([8, 78])\ntorch.Size([8, 66]) torch.Size([8, 66])\ntorch.Size([8, 64]) torch.Size([8, 64])\ntorch.Size([8, 83]) torch.Size([8, 83])\ntorch.Size([8, 66]) torch.Size([8, 66])\ntorch.Size([8, 74]) torch.Size([8, 74])\ntorch.Size([8, 69]) torch.Size([8, 69])\n\n\n\nAs we can see based on the output above, all batches have a batch size of 8 but a different length, as expected\nLet’s also double-check that the inputs contain the &lt;|endoftext|&gt; padding tokens corresponding to token ID 50256 by printing the contents of the first training example in the inputs batch\n\n\n\ntensor([21106,   318,   281, 12064,   326,  8477,   257,  4876,    13, 19430,\n          257,  2882,   326, 20431, 32543,   262,  2581,    13,   198,   198,\n        21017, 46486,    25,   198, 30003,  6525,   262,  6827,  1262,   257,\n          985,   576,    13,   198,   198, 21017, 23412,    25,   198,   464,\n         5156,   318,   845, 13779,    13,   198,   198, 21017, 18261,    25,\n          198,   464,  5156,   318,   355, 13779,   355,   257,  4936,    13,\n        50256, 50256, 50256, 50256, 50256, 50256, 50256, 50256, 50256],\n       device='cuda:0')\n\n\n\nSimilarly, we visually double-check that the targets contain the -100 placeholder tokens\n\n\n\ntensor([  318,   281, 12064,   326,  8477,   257,  4876,    13, 19430,   257,\n         2882,   326, 20431, 32543,   262,  2581,    13,   198,   198, 21017,\n        46486,    25,   198, 30003,  6525,   262,  6827,  1262,   257,   985,\n          576,    13,   198,   198, 21017, 23412,    25,   198,   464,  5156,\n          318,   845, 13779,    13,   198,   198, 21017, 18261,    25,   198,\n          464,  5156,   318,   355, 13779,   355,   257,  4936,    13, 50256,\n         -100,  -100,  -100,  -100,  -100,  -100,  -100,  -100,  -100],\n       device='cuda:0')"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#loading-a-pretrained-llm",
    "href": "posts/LLM-From-Scratch/index.html#loading-a-pretrained-llm",
    "title": "LLM From Scratch",
    "section": "7.5 Loading a pretrained LLM",
    "text": "7.5 Loading a pretrained LLM\n\nIn this section, we load a pretrained GPT model using the same code that we used in section 5.5 of chapter 5 and section 6.4 in chapter 6\n\n\n\nHowever, instead of loading the smallest 124 million parameter model, we load the medium version with 355 million parameters since the 124 million model is too small for achieving qualitatively reasonable results via instruction finetuning\nBefore we start finetuning the model in the next section, let’s see how it performs on one of the validation tasks\n\n\n\nBelow is an instruction that describes a task. Write a response that appropriately completes the request.\n\n### Instruction:\nConvert the active sentence to passive: 'The chef cooks the meal every day.'\n\n\n\nNote that the generate function we used in previous chapters returns the combined input and output text, which was convenient in the previous section for creating legible text\nTo isolate the response, we can subtract the length of the instruction from the start of the generated_text\n\n\n\nThe chef cooks the meal every day.\n\n### Instruction:\n\nConvert the active sentence to passive: 'The chef cooks the\n\n\n\nAs we can see, the model is not capable of following the instructions, yet; it creates a “Response” section but it simply repeats the original input sentence as well as the instruction"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#finetuning-the-llm-on-instruction-data",
    "href": "posts/LLM-From-Scratch/index.html#finetuning-the-llm-on-instruction-data",
    "title": "LLM From Scratch",
    "section": "7.6 Finetuning the LLM on instruction data",
    "text": "7.6 Finetuning the LLM on instruction data\n\nIn this section, we finetune the model\n\n\n\nNote that we can reuse all the loss calculation and training functions that we used in previous chapters\nLet’s calculate the initial training and validation set loss before we start training (as in previous chapters, the goal is to minimize the loss)\n\n\n\nTraining loss: 3.8259087562561036\nValidation loss: 3.761933708190918\n\n\n\nNote that the training is a bit more expensive than in previous chapters since we are using a larger model (355 million instead of 124 million parameters)\nThe runtimes for various devices are shown for reference below (running this notebook on a compatible GPU device requires no changes to the code)\n\n\n\n\n\nModel\nDevice\nRuntime for 2 Epochs\n\n\n\n\ngpt2-medium (355M)\nCPU (M3 MacBook Air)\n15.78 minutes\n\n\ngpt2-medium (355M)\nGPU (M3 MacBook Air)\n10.77 minutes\n\n\ngpt2-medium (355M)\nGPU (L4)\n1.83 minutes\n\n\ngpt2-medium (355M)\nGPU (A100)\n0.86 minutes\n\n\ngpt2-small (124M)\nCPU (M3 MacBook Air)\n5.74 minutes\n\n\ngpt2-small (124M)\nGPU (M3 MacBook Air)\n3.73 minutes\n\n\ngpt2-small (124M)\nGPU (L4)\n0.69 minutes\n\n\ngpt2-small (124M)\nGPU (A100)\n0.39 minutes\n\n\n\n\n\nI ran this notebook using the \"gpt2-medium (355M)\" model\n\n\n\nEp 1 (Step 000000): Train loss 2.637, Val loss 2.626\nEp 1 (Step 000005): Train loss 1.174, Val loss 1.103\nEp 1 (Step 000010): Train loss 0.872, Val loss 0.944\nEp 1 (Step 000015): Train loss 0.857, Val loss 0.906\nEp 1 (Step 000020): Train loss 0.776, Val loss 0.881\nEp 1 (Step 000025): Train loss 0.754, Val loss 0.859\nEp 1 (Step 000030): Train loss 0.800, Val loss 0.836\nEp 1 (Step 000035): Train loss 0.714, Val loss 0.809\nEp 1 (Step 000040): Train loss 0.672, Val loss 0.806\nEp 1 (Step 000045): Train loss 0.633, Val loss 0.789\nEp 1 (Step 000050): Train loss 0.663, Val loss 0.782\nEp 1 (Step 000055): Train loss 0.760, Val loss 0.763\nEp 1 (Step 000060): Train loss 0.719, Val loss 0.743\nEp 1 (Step 000065): Train loss 0.653, Val loss 0.735\nEp 1 (Step 000070): Train loss 0.536, Val loss 0.732\nEp 1 (Step 000075): Train loss 0.569, Val loss 0.739\nEp 1 (Step 000080): Train loss 0.603, Val loss 0.734\nEp 1 (Step 000085): Train loss 0.518, Val loss 0.717\nEp 1 (Step 000090): Train loss 0.575, Val loss 0.699\nEp 1 (Step 000095): Train loss 0.505, Val loss 0.689\nEp 1 (Step 000100): Train loss 0.507, Val loss 0.683\nEp 1 (Step 000105): Train loss 0.570, Val loss 0.676\nEp 1 (Step 000110): Train loss 0.564, Val loss 0.671\nEp 1 (Step 000115): Train loss 0.522, Val loss 0.666\nBelow is an instruction that describes a task. Write a response that appropriately completes the request.  ### Instruction: Convert the active sentence to passive: 'The chef cooks the meal every day.'  ### Response: The meal is prepared every day by the chef.&lt;|endoftext|&gt;The following is an instruction that describes a task. Write a response that appropriately completes the request.  ### Instruction: Convert the active sentence to passive:\nEp 2 (Step 000120): Train loss 0.439, Val loss 0.671\nEp 2 (Step 000125): Train loss 0.454, Val loss 0.685\nEp 2 (Step 000130): Train loss 0.448, Val loss 0.681\nEp 2 (Step 000135): Train loss 0.406, Val loss 0.678\nEp 2 (Step 000140): Train loss 0.412, Val loss 0.678\nEp 2 (Step 000145): Train loss 0.372, Val loss 0.680\nEp 2 (Step 000150): Train loss 0.381, Val loss 0.674\nEp 2 (Step 000155): Train loss 0.419, Val loss 0.672\nEp 2 (Step 000160): Train loss 0.417, Val loss 0.680\nEp 2 (Step 000165): Train loss 0.383, Val loss 0.683\nEp 2 (Step 000170): Train loss 0.328, Val loss 0.679\nEp 2 (Step 000175): Train loss 0.334, Val loss 0.668\nEp 2 (Step 000180): Train loss 0.391, Val loss 0.656\nEp 2 (Step 000185): Train loss 0.418, Val loss 0.657\nEp 2 (Step 000190): Train loss 0.341, Val loss 0.648\nEp 2 (Step 000195): Train loss 0.330, Val loss 0.633\nEp 2 (Step 000200): Train loss 0.313, Val loss 0.631\nEp 2 (Step 000205): Train loss 0.354, Val loss 0.628\nEp 2 (Step 000210): Train loss 0.365, Val loss 0.629\nEp 2 (Step 000215): Train loss 0.394, Val loss 0.634\nEp 2 (Step 000220): Train loss 0.301, Val loss 0.647\nEp 2 (Step 000225): Train loss 0.347, Val loss 0.661\nEp 2 (Step 000230): Train loss 0.297, Val loss 0.659\nBelow is an instruction that describes a task. Write a response that appropriately completes the request.  ### Instruction: Convert the active sentence to passive: 'The chef cooks the meal every day.'  ### Response: The meal is cooked every day by the chef.&lt;|endoftext|&gt;The following is an instruction that describes a task. Write a response that appropriately completes the request.  ### Instruction: What is the capital of the United Kingdom\nTraining completed in 0.93 minutes.\n\n\n\nAs we can see based on the outputs above, the model trains well, as we can tell based on the decreasing training loss and validation loss values\nFurthermore, based on the response text printed after each epoch, we can see that the model correctly follows the instruction to convert the input sentence 'The chef cooks the meal every day.' into passive voice 'The meal is cooked every day by the chef.' (We will properly format and evaluate the responses in a later section)\nFinally, let’s take a look at the training and validation loss curves\n\n\n\n\n\n\n\n\n\n\n\nAs we can see, the loss decreases sharply at the beginning of the first epoch, which means the model starts learning quickly\nWe can see that slight overfitting sets in at around 1 training epoch"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#extracting-and-saving-responses",
    "href": "posts/LLM-From-Scratch/index.html#extracting-and-saving-responses",
    "title": "LLM From Scratch",
    "section": "7.7 Extracting and saving responses",
    "text": "7.7 Extracting and saving responses\n\n\nIn this section, we save the test set responses for scoring in the next section\nWe also save a copy of the model for future use\nBut first, let’s take a brief look at the responses generated by the finetuned model\n\n\n\nBelow is an instruction that describes a task. Write a response that appropriately completes the request.\n\n### Instruction:\nRewrite the sentence using a simile.\n\n### Input:\nThe car is very fast.\n\nCorrect response:\n&gt;&gt; The car is as fast as lightning.\n\nModel response:\n&gt;&gt; The car is as fast as a bullet.\n-------------------------------------\nBelow is an instruction that describes a task. Write a response that appropriately completes the request.\n\n### Instruction:\nWhat type of cloud is typically associated with thunderstorms?\n\nCorrect response:\n&gt;&gt; The type of cloud typically associated with thunderstorms is cumulonimbus.\n\nModel response:\n&gt;&gt; The type of cloud associated with thunderstorms is a cumulus cloud.\n-------------------------------------\nBelow is an instruction that describes a task. Write a response that appropriately completes the request.\n\n### Instruction:\nName the author of 'Pride and Prejudice'.\n\nCorrect response:\n&gt;&gt; Jane Austen.\n\nModel response:\n&gt;&gt; The author of 'Pride and Prejudice' is Jane Austen.\n-------------------------------------\n\n\n\nAs we can see based on the test set instructions, given responses, and the model’s responses, the model performs relatively well\nThe answers to the first and last instructions are clearly correct\nThe second answer is close; the model answers with “cumulus cloud” instead of “cumulonimbus” (however, note that cumulus clouds can develop into cumulonimbus clouds, which are capable of producing thunderstorms)\nMost importantly, we can see that model evaluation is not as straightforward as in the previous chapter, where we just had to calculate the percentage of correct spam/non-spam class labels to obtain the classification accuracy\nIn practice, instruction-finetuned LLMs such as chatbots are evaluated via multiple approaches\n\nshort-answer and multiple choice benchmarks such as MMLU (“Measuring Massive Multitask Language Understanding”, https://arxiv.org/abs/2009.03300), which test the knowledge of a model\nhuman preference comparison to other LLMs, such as LMSYS chatbot arena (https://arena.lmsys.org)\nautomated conversational benchmarks, where another LLM like GPT-4 is used to evaluate the responses, such as AlpacaEval (https://tatsu-lab.github.io/alpaca_eval/)\n\nIn the next section, we will use an approach similar to AlpacaEval and use another LLM to evaluate the responses of our model; however, we will use our own test set instead of using a publicly available benchmark dataset\nFor this, we add the model response to the test_data dictionary and save it as a \"instruction-data-with-response.json\" file for record-keeping so that we can load and analyze it in separate Python sessions if needed\nLet’s double-check one of the entries to see whether the responses have been added to the test_data dictionary correctly\n\n\n\n{'instruction': 'Rewrite the sentence using a simile.', 'input': 'The car is very fast.', 'output': 'The car is as fast as lightning.', 'model_response': 'The car is as fast as a bullet.'}\n\n\n\nFinally, we also save the model in case we want to reuse it in the future\n\n\n\nModel saved as gpt2-medium355M-sft.pth"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#evaluating-the-finetuned-llm",
    "href": "posts/LLM-From-Scratch/index.html#evaluating-the-finetuned-llm",
    "title": "LLM From Scratch",
    "section": "7.8 Evaluating the finetuned LLM",
    "text": "7.8 Evaluating the finetuned LLM\n\n\nIn this section, we automate the response evaluation of the finetuned LLM using another, larger LLM\nIn particular, we use an instruction-finetuned 8-billion-parameter Llama 3 model by Meta AI that can be run locally via ollama (https://ollama.com)\n(Alternatively, if you prefer using a more capable LLM like GPT-4 via the OpenAI API, please see the llm-instruction-eval-openai.ipynb notebook)\nOllama is an application to run LLMs efficiently\nIt is a wrapper around llama.cpp (https://github.com/ggerganov/llama.cpp), which implements LLMs in pure C/C++ to maximize efficiency\nNote that it is a tool for using LLMs to generate text (inference), not training or finetuning LLMs\nBefore running the code below, install ollama by visiting https://ollama.com and following the instructions (for instance, clicking on the “Download” button and downloading the ollama application for your operating system)\nFor macOS and Windows users, click on the ollama application you downloaded; if it prompts you to install the command line usage, say “yes”\nLinux users can use the installation command provided on the ollama website\nIn general, before we can use ollama from the command line, we have to either start the ollama application or run ollama serve in a separate terminal\n\n\n\nWith the ollama application or ollama serve running in a different terminal, on the command line, execute the following command to try out the 8-billion-parameter Llama 3 model (the model, which takes up 4.7 GB of storage space, will be automatically downloaded the first time you execute this command)\n\n# 8B model\nollama run llama3\nThe output looks like as follows\n$ ollama run llama3\npulling manifest\npulling 6a0746a1ec1a... 100% ▕████████████████▏ 4.7 GB\npulling 4fa551d4f938... 100% ▕████████████████▏  12 KB\npulling 8ab4849b038c... 100% ▕████████████████▏  254 B\npulling 577073ffcc6c... 100% ▕████████████████▏  110 B\npulling 3f8eb4da87fa... 100% ▕████████████████▏  485 B\nverifying sha256 digest\nwriting manifest\nremoving any unused layers\nsuccess\n\nNote that llama3 refers to the instruction finetuned 8-billion-parameter Llama 3 model\nUsing ollama with the \"llama3\" model (a 8B parameter model) requires 16 GB of RAM; if this is not supported by your machine, you can try the smaller model, such as the 3.8B parameter phi-3 model by setting model = \"phi-3\", which only requires 8 GB of RAM\nAlternatively, you can also use the larger 70-billion-parameter Llama 3 model, if your machine supports it, by replacing llama3 with llama3:70b\nAfter the download has been completed, you will see a command line prompt that allows you to chat with the model\nTry a prompt like “What do llamas eat?”, which should return an output similar to the following\n\n&gt;&gt;&gt; What do llamas eat?\nLlamas are ruminant animals, which means they have a four-chambered\nstomach and eat plants that are high in fiber. In the wild, llamas\ntypically feed on:\n1. Grasses: They love to graze on various types of grasses, including tall\ngrasses, wheat, oats, and barley.\n\nYou can end this session using the input /bye\nThe following code checks whether the ollama session is running correctly before proceeding to use ollama to evaluate the test set responses we generated in the previous section\n\n\n\nOllama running: True\n\n\n\nNow, an alternative way to the ollama run command we used earlier to interact with the model is via its REST API in Python via the following function\nBefore you run the next cells in this notebook, make sure that ollama is still running (the previous code cells should print \"Ollama running: True\")\nNext, run the following code cell to query the model\n\n\n\nLlamas are herbivores, which means they primarily feed on plant-based foods. Their diet typically consists of:\n\n1. Grasses: Llamas love to graze on various types of grasses, including tall grasses, short grasses, and even weeds.\n2. Hay: High-quality hay, such as alfalfa or timothy hay, is a staple in a llama's diet. They enjoy the sweet taste and texture of fresh hay.\n3. Grains: Llamas may receive grains like oats, barley, or corn as part of their daily ration. However, it's essential to provide these grains in moderation, as they can be high in calories.\n4. Fruits and vegetables: Llamas enjoy a variety of fruits and veggies, such as apples, carrots, sweet potatoes, and leafy greens like kale or spinach.\n5. Minerals: Llamas require access to mineral supplements, which help maintain their overall health and well-being.\n\nIn the wild, llamas might also eat:\n\n1. Leaves: They'll munch on leaves from trees and shrubs, including plants like willow, alder, and birch.\n2. Bark: In some cases, llamas may eat the bark of certain trees, like aspen or cottonwood.\n3. Mosses and lichens: These non-vascular plants can be a tasty snack for llamas.\n\nIn captivity, llama owners typically provide a balanced diet that includes a mix of hay, grains, and fruits/vegetables. It's essential to consult with a veterinarian or experienced llama breeder to determine the best feeding plan for your llama.\n\n\n\nNow, using the query_model function we defined above, we can evaluate the responses of our finetuned model; let’s try it out on the first 3 test set responses we looked at in a previous section\n\n\n\n\nDataset response:\n&gt;&gt; The car is as fast as lightning.\n\nModel response:\n&gt;&gt; The car is as fast as a bullet.\n\nScore:\n&gt;&gt; I'd rate the model response \"The car is as fast as a bullet.\" an 85 out of 100.\n\nHere's why:\n\n* The response uses a simile correctly, comparing the speed of the car to something else (in this case, a bullet).\n* The comparison is relevant and makes sense, as bullets are known for their high velocity.\n* The phrase \"as fast as\" is used correctly to introduce the simile.\n\nThe only reason I wouldn't give it a perfect score is that some people might find the comparison slightly less vivid or evocative than others. For example, comparing something to lightning (as in the original response) can be more dramatic and attention-grabbing. However, \"as fast as a bullet\" is still a strong and effective simile that effectively conveys the idea of the car's speed.\n\nOverall, I think the model did a great job!\n\n-------------------------\n\nDataset response:\n&gt;&gt; The type of cloud typically associated with thunderstorms is cumulonimbus.\n\nModel response:\n&gt;&gt; The type of cloud associated with thunderstorms is a cumulus cloud.\n\nScore:\n&gt;&gt; I'd score this model response as 40 out of 100.\n\nHere's why:\n\n* The model correctly identifies that thunderstorms are related to clouds (correctly identifying the type of phenomenon).\n* However, it incorrectly specifies the type of cloud associated with thunderstorms. Cumulus clouds are not typically associated with thunderstorms; cumulonimbus clouds are.\n* The response lacks precision and accuracy in its description.\n\nOverall, while the model attempts to address the instruction, it provides an incorrect answer, which is a significant error.\n\n-------------------------\n\nDataset response:\n&gt;&gt; Jane Austen.\n\nModel response:\n&gt;&gt; The author of 'Pride and Prejudice' is Jane Austen.\n\nScore:\n&gt;&gt; I'd rate my own response as 95 out of 100. Here's why:\n\n* The response accurately answers the question by naming the author of 'Pride and Prejudice' as Jane Austen.\n* The response is concise and clear, making it easy to understand.\n* There are no grammatical errors or ambiguities that could lead to confusion.\n\nThe only reason I wouldn't give myself a perfect score is that the response is slightly redundant - it's not necessary to rephrase the question in the answer. A more concise response would be simply \"Jane Austen.\"\n\n-------------------------\n\n\n\nNote: Better evaluation prompt\n\nA reader (Ayoosh Kathuria) suggested a longer, improved prompt that evaluates responses on a scale of 1–5 (instead of 1 to 100) and employs a grading rubric, resulting in more accurate and less noisy evaluations:\n\nprompt = \"\"\"\nYou are a fair judge assistant tasked with providing clear, objective feedback based on specific criteria, ensuring each assessment reflects the absolute standards set for performance.\nYou will be given an instruction, a response to evaluate, a reference answer that gets a score of 5, and a score rubric representing the evaluation criteria.\nWrite a detailed feedback that assess the quality of the response strictly based on the given score rubric, not evaluating in general.\nPlease do not generate any other opening, closing, and explanations.\n\nHere is the rubric you should use to build your answer:\n1: The response fails to address the instructions, providing irrelevant, incorrect, or excessively verbose information that detracts from the user's request.\n2: The response partially addresses the instructions but includes significant inaccuracies, irrelevant details, or excessive elaboration that detracts from the main task.\n3: The response follows the instructions with some minor inaccuracies or omissions. It is generally relevant and clear, but may include some unnecessary details or could be more concise.\n4: The response adheres to the instructions, offering clear, accurate, and relevant information in a concise manner, with only occasional, minor instances of excessive detail or slight lack of clarity.\n5: The response fully adheres to the instructions, providing a clear, accurate, and relevant answer in a concise and efficient manner. It addresses all aspects of the request without unnecessary details or elaboration\n\nProvide your feedback as follows:\n\nFeedback:::\nEvaluation: (your rationale for the rating, as a text)\nTotal rating: (your rating, as a number between 1 and 5)\n\nYou MUST provide values for 'Evaluation:' and 'Total rating:' in your answer.\n\nNow here is the instruction, the reference answer, and the response.\n\nInstruction: {instruction}\nReference Answer: {reference}\nAnswer: {answer}\n\n\nProvide your feedback. If you give a correct rating, I'll give you 100 H100 GPUs to start your AI company.\nFeedback:::\nEvaluation: \"\"\"\n\nFor more context and information, see this GitHub discussion\n\n\n\nAs we can see, the Llama 3 model provides a reasonable evaluation and also gives partial points if a model is not entirely correct, as we can see based on the “cumulus cloud” answer\nNote that the previous prompt returns very verbose evaluations; we can tweak the prompt to generate integer responses in the range between 0 and 100 (where 100 is best) to calculate an average score for our model\nThe evaluation of the 110 entries in the test set takes about 1 minute on an M3 MacBook Air laptop\n\n\n\nNumber of scores: 110 of 110\nAverage score: 50.32\n\n\n\n\nOur model achieves an average score of above 50, which we can use as a reference point to compare the model to other models or to try out other training settings that may improve the model\nNote that ollama is not fully deterministic across operating systems (as of this writing), so the numbers you are getting might slightly differ from the ones shown above\nFor reference, the original\n\nLlama 3 8B base model achieves a score of 58.51\nLlama 3 8B instruct model achieves a score of 82.65"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#conclusions",
    "href": "posts/LLM-From-Scratch/index.html#conclusions",
    "title": "LLM From Scratch",
    "section": "7.9 Conclusions",
    "text": "7.9 Conclusions\n\n7.9.1 What’s next\n\nThis marks the final chapter of this book\nWe covered the major steps of the LLM development cycle: implementing an LLM architecture, pretraining an LLM, and finetuning it\n\n\n\nAn optional step that is sometimes followed after instruction finetuning, as described in this chapter, is preference finetuning\nPreference finetuning process can be particularly useful for customizing a model to better align with specific user preferences; see the ../04_preference-tuning-with-dpo folder if you are interested in this\nThis GitHub repository also contains a large selection of additional bonus material you may enjoy; for more information, please see the Bonus Material section on this repository’s README page\n\n\n\n7.9.2 Staying up to date in a fast-moving field\n\nNo code in this section\n\n\n\n7.9.3 Final words\n\nI hope you enjoyed this journey of implementing an LLM from the ground up and coding the pretraining and finetuning functions\nIn my opinion, implementing an LLM from scratch is the best way to understand how LLMs work; I hope you gained a better understanding through this approach\nWhile this book serves educational purposes, you may be interested in using different and more powerful LLMs for real-world applications\n\nFor this, you may consider popular tools such as axolotl (https://github.com/OpenAccess-AI-Collective/axolotl) or LitGPT (https://github.com/Lightning-AI/litgpt), which I help developing"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#summary-and-takeaways-5",
    "href": "posts/LLM-From-Scratch/index.html#summary-and-takeaways-5",
    "title": "LLM From Scratch",
    "section": "Summary and takeaways",
    "text": "Summary and takeaways\n\nSee the ./gpt_instruction_finetuning.py script, a self-contained script for instruction finetuning\n./ollama_evaluate.py is a standalone script based on section 7.8 that evaluates a JSON file containing “output” and “response” keys via Ollama and Llama 3\nThe ./load-finetuned-model.ipynb notebook illustrates how to load the finetuned model in a new session\nYou can find the exercise solutions in ./exercise-solutions.ipynb"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#whats-next-1",
    "href": "posts/LLM-From-Scratch/index.html#whats-next-1",
    "title": "LLM From Scratch",
    "section": "What’s next?",
    "text": "What’s next?\n\nCongrats on completing the book; in case you are looking for additional resources, I added several bonus sections to this GitHub repository that you might find interesting\nThe complete list of bonus materials can be viewed in the main README’s Bonus Material section\nTo highlight a few of my favorites:\n\nDirect Preference Optimization (DPO) for LLM Alignment (From Scratch) implements a popular preference tuning mechanism to align the model from this chapter more closely with human preferences\nLlama 3.2 From Scratch (A Standalone Notebook), a from-scratch implementation of Meta AI’s popular Llama 3.2, including loading the official pretrained weights; if you are up to some additional experiments, you can replace the GPTModel model in each of the chapters with the Llama3Model class (it should work as a 1:1 replacement)\nConverting GPT to Llama contains code with step-by-step guides that explain the differences between GPT-2 and the various Llama models\nUnderstanding the Difference Between Embedding Layers and Linear Layers is a conceptual explanation illustrating that the Embedding layer in PyTorch, which we use at the input stage of an LLM, is mathematically equivalent to a linear layer applied to one-hot encoded data\n\nHappy further reading!"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#references",
    "href": "posts/LLM-From-Scratch/index.html#references",
    "title": "LLM From Scratch",
    "section": "References",
    "text": "References\n\nBook: Build a Large Language Model (From Scratch) by Sebastian Raschka\nPublisher: Manning Publications\nISBN: 9781633437166\nGitHub: https://github.com/rasbt/LLMs-from-scratch"
  },
  {
    "objectID": "posts/LLM-From-Scratch/index.html#fine-tuned-gpt-model-demo",
    "href": "posts/LLM-From-Scratch/index.html#fine-tuned-gpt-model-demo",
    "title": "LLM From Scratch",
    "section": "Fine-tuned GPT Model Demo",
    "text": "Fine-tuned GPT Model Demo\nThis interactive demo showcases a GPT model fine-tuned using techniques from “Build a Large Language Model From Scratch” by Sebastian Raschka. Try asking questions or giving it instructions to see the model in action.\n\n  \n  \n    Interactive demo could not be loaded\n    \n    \n      \n        Open the demo in Hugging Face Spaces\n      \n    \n  \n\n  \n  \n  \n  \n  \n    \n    Loading interactive demo...\n  \n\n  \n  \n    \n      Tips for using the model: \n      Try asking questions, requesting creative content, or giving specific instructions.\n    \n    \n      What is the capital of France?\n      Write a poem about AI\n      Explain neural networks\n      Supervised vs. unsupervised\n    \n  \n\n\n\n\n\n\nTry the demo above or visit the full Hugging Face Space for the best experience."
  }
]