<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Dipankar Baisya">
<meta name="dcterms.date" content="2025-10-29">

<title>LLM From Scratch – My Blogs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">My Blogs</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">LLM From Scratch</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">LLM</div>
                <div class="quarto-category">ML</div>
                <div class="quarto-category">Deep Learning</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Dipankar Baisya </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 29, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of Contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">0. Introduction</a></li>
  <li><a href="#prerequisites" id="toc-prerequisites" class="nav-link" data-scroll-target="#prerequisites">1. Prerequisites</a></li>
  <li><a href="#working-with-text-data" id="toc-working-with-text-data" class="nav-link" data-scroll-target="#working-with-text-data">2. Working with text data</a></li>
  <li><a href="#coding-attention-mechanisms" id="toc-coding-attention-mechanisms" class="nav-link" data-scroll-target="#coding-attention-mechanisms">3. Coding Attention Mechanisms</a></li>
  <li><a href="#implementing-a-gpt-model-from-scratch-to-generate-text" id="toc-implementing-a-gpt-model-from-scratch-to-generate-text" class="nav-link" data-scroll-target="#implementing-a-gpt-model-from-scratch-to-generate-text">4. Implementing a GPT model from Scratch To Generate Text</a></li>
  <li><a href="#pretraining-on-unlabeled-data" id="toc-pretraining-on-unlabeled-data" class="nav-link" data-scroll-target="#pretraining-on-unlabeled-data">5. Pretraining on Unlabeled Data</a></li>
  <li><a href="#chapter-5-pretraining-on-unlabeled-data" id="toc-chapter-5-pretraining-on-unlabeled-data" class="nav-link" data-scroll-target="#chapter-5-pretraining-on-unlabeled-data">Chapter 5: Pretraining on Unlabeled Data</a></li>
  <li><a href="#finetuning-for-text-classification" id="toc-finetuning-for-text-classification" class="nav-link" data-scroll-target="#finetuning-for-text-classification">6. Finetuning for Text Classification</a></li>
  <li><a href="#finetuning-to-follow-instruction" id="toc-finetuning-to-follow-instruction" class="nav-link" data-scroll-target="#finetuning-to-follow-instruction">7. Finetuning to Follow Instruction</a></li>
  <li><a href="#deployment-in-hf-hub-using-gradio" id="toc-deployment-in-hf-hub-using-gradio" class="nav-link" data-scroll-target="#deployment-in-hf-hub-using-gradio">8. Deployment in HF-Hub using Gradio</a></li>
  <li><a href="#key-technical-achievements" id="toc-key-technical-achievements" class="nav-link" data-scroll-target="#key-technical-achievements">9. Key Technical Achievements</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
<div class="quarto-alternate-notebooks"><h2>Notebooks</h2><ul><li><a href="chapters/ch02-preview.html"><i class="bi bi-journal-code"></i>2.1 Understanding word embeddings</a></li><li><a href="chapters/ch03-preview.html"><i class="bi bi-journal-code"></i>3.1 The problem with modeling long sequences</a></li><li><a href="chapters/ch04-preview.html"><i class="bi bi-journal-code"></i>4.1 Coding an LLM architecture</a></li><li><a href="chapters/ch06-preview.html"><i class="bi bi-journal-code"></i>6.1 Different categories of finetuning</a></li><li><a href="chapters/ch07-preview.html"><i class="bi bi-journal-code"></i>7.1 Introduction to instruction finetuning</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level1">
<h1>0. Introduction</h1>
<p>[Your existing introduction content here…]</p>
</section>
<section id="prerequisites" class="level1">
<h1>1. Prerequisites</h1>
<p>[Your existing prerequisites content here…]</p>
</section>
<section id="working-with-text-data" class="level1">
<h1>2. Working with text data</h1>
<p>This section explores techniques for processing and working with text data for language models.</p>
<div class="quarto-embed-nb-cell">
<p>Packages that are being used in this notebook:</p>
<div id="4d1305cf-12d5-46fe-a2c9-36fb71c5b3d3" class="cell" data-execution_count="1">
<div class="cell-output cell-output-stdout">
<pre><code>torch version: 2.5.1
tiktoken version: 0.7.0</code></pre>
</div>
</div>
<ul>
<li>This chapter covers data preparation and sampling to get input data “ready” for the LLM</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch02_compressed/01.webp?timestamp=1" width="500px"></p>
<section id="understanding-word-embeddings" class="level2">
<h2 class="anchored" data-anchor-id="understanding-word-embeddings">2.1 Understanding word embeddings</h2>
<ul>
<li><p>No code in this section</p></li>
<li><p>There are many forms of embeddings; we focus on text embeddings in this book</p></li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch02_compressed/02.webp" width="500px"></p>
<ul>
<li>LLMs work with embeddings in high-dimensional spaces (i.e., thousands of dimensions)</li>
<li>Since we can’t visualize such high-dimensional spaces (we humans think in 1, 2, or 3 dimensions), the figure below illustrates a 2-dimensional embedding space</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch02_compressed/03.webp" width="300px"></p>
</section>
<section id="tokenizing-text" class="level2">
<h2 class="anchored" data-anchor-id="tokenizing-text">2.2 Tokenizing text</h2>
<ul>
<li>In this section, we tokenize text, which means breaking text into smaller units, such as individual words and punctuation characters</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch02_compressed/04.webp" width="300px"></p>
<ul>
<li><p>Load raw text we want to work with</p></li>
<li><p><a href="https://en.wikisource.org/wiki/The_Verdict">The Verdict by Edith Wharton</a> is a public domain short story</p></li>
<li><p>(If you encounter an <code>ssl.SSLCertVerificationError</code> when executing the previous code cell, it might be due to using an outdated Python version; you can find <a href="https://github.com/rasbt/LLMs-from-scratch/pull/403">more information here on GitHub</a>)</p></li>
</ul>
<div id="8a769e87-470a-48b9-8bdb-12841b416198" class="cell" data-execution_count="3">
<div class="cell-output cell-output-stdout">
<pre><code>Total number of character: 20479
I HAD always thought Jack Gisburn rather a cheap genius--though a good fellow enough--so it was no </code></pre>
</div>
</div>
<ul>
<li>The goal is to tokenize and embed this text for an LLM</li>
<li>Let’s develop a simple tokenizer based on some simple sample text that we can then later apply to the text above</li>
<li>The following regular expression will split on whitespaces</li>
</ul>
<div id="737dd5b0-9dbb-4a97-9ae4-3482c8c04be7" class="cell" data-execution_count="4">
<div class="cell-output cell-output-stdout">
<pre><code>['Hello,', ' ', 'world.', ' ', 'This,', ' ', 'is', ' ', 'a', ' ', 'test.']</code></pre>
</div>
</div>
<ul>
<li>We don’t only want to split on whitespaces but also commas and periods, so let’s modify the regular expression to do that as well</li>
</ul>
<div id="ea02489d-01f9-4247-b7dd-a0d63f62ef07" class="cell" data-execution_count="5">
<div class="cell-output cell-output-stdout">
<pre><code>['Hello', ',', '', ' ', 'world', '.', '', ' ', 'This', ',', '', ' ', 'is', ' ', 'a', ' ', 'test', '.', '']</code></pre>
</div>
</div>
<ul>
<li>As we can see, this creates empty strings, let’s remove them</li>
</ul>
<div id="4d8a6fb7-2e62-4a12-ad06-ccb04f25fed7" class="cell" data-execution_count="6">
<div class="cell-output cell-output-stdout">
<pre><code>['Hello', ',', 'world', '.', 'This', ',', 'is', 'a', 'test', '.']</code></pre>
</div>
</div>
<ul>
<li>This looks pretty good, but let’s also handle other types of punctuation, such as periods, question marks, and so on</li>
</ul>
<div id="ed3a9467-04b4-49d9-96c5-b8042bcf8374" class="cell" data-execution_count="7">
<div class="cell-output cell-output-stdout">
<pre><code>['Hello', ',', 'world', '.', 'Is', 'this', '--', 'a', 'test', '?']</code></pre>
</div>
</div>
<ul>
<li>This is pretty good, and we are now ready to apply this tokenization to the raw text</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch02_compressed/05.webp" width="350px"></p>
<div id="8c567caa-8ff5-49a8-a5cc-d365b0a78a99" class="cell" data-execution_count="8">
<div class="cell-output cell-output-stdout">
<pre><code>['I', 'HAD', 'always', 'thought', 'Jack', 'Gisburn', 'rather', 'a', 'cheap', 'genius', '--', 'though', 'a', 'good', 'fellow', 'enough', '--', 'so', 'it', 'was', 'no', 'great', 'surprise', 'to', 'me', 'to', 'hear', 'that', ',', 'in']</code></pre>
</div>
</div>
<ul>
<li>Let’s calculate the total number of tokens</li>
</ul>
<div id="35db7b5e-510b-4c45-995f-f5ad64a8e19c" class="cell" data-execution_count="9">
<div class="cell-output cell-output-stdout">
<pre><code>4690</code></pre>
</div>
</div>
</section>
<section id="converting-tokens-into-token-ids" class="level2">
<h2 class="anchored" data-anchor-id="converting-tokens-into-token-ids">2.3 Converting tokens into token IDs</h2>
<ul>
<li>Next, we convert the text tokens into token IDs that we can process via embedding layers later</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch02_compressed/06.webp" width="500px"></p>
<ul>
<li>From these tokens, we can now build a vocabulary that consists of all the unique tokens</li>
</ul>
<div id="7fdf0533-5ab6-42a5-83fa-a3b045de6396" class="cell" data-execution_count="10">
<div class="cell-output cell-output-stdout">
<pre><code>1130</code></pre>
</div>
</div>
<ul>
<li>Below are the first 50 entries in this vocabulary:</li>
</ul>
<div id="e1c5de4a-aa4e-4aec-b532-10bb364039d6" class="cell" data-execution_count="12">
<div class="cell-output cell-output-stdout">
<pre><code>('!', 0)
('"', 1)
("'", 2)
('(', 3)
(')', 4)
(',', 5)
('--', 6)
('.', 7)
(':', 8)
(';', 9)
('?', 10)
('A', 11)
('Ah', 12)
('Among', 13)
('And', 14)
('Are', 15)
('Arrt', 16)
('As', 17)
('At', 18)
('Be', 19)
('Begin', 20)
('Burlington', 21)
('But', 22)
('By', 23)
('Carlo', 24)
('Chicago', 25)
('Claude', 26)
('Come', 27)
('Croft', 28)
('Destroyed', 29)
('Devonshire', 30)
('Don', 31)
('Dubarry', 32)
('Emperors', 33)
('Florence', 34)
('For', 35)
('Gallery', 36)
('Gideon', 37)
('Gisburn', 38)
('Gisburns', 39)
('Grafton', 40)
('Greek', 41)
('Grindle', 42)
('Grindles', 43)
('HAD', 44)
('Had', 45)
('Hang', 46)
('Has', 47)
('He', 48)
('Her', 49)
('Hermia', 50)</code></pre>
</div>
</div>
<ul>
<li>Below, we illustrate the tokenization of a short sample text using a small vocabulary:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch02_compressed/07.webp?123" width="500px"></p>
<ul>
<li><p>Putting it now all together into a tokenizer class</p></li>
<li><p>The <code>encode</code> function turns text into token IDs</p></li>
<li><p>The <code>decode</code> function turns token IDs back into text</p></li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch02_compressed/08.webp?123" width="500px"></p>
<ul>
<li>We can use the tokenizer to encode (that is, tokenize) texts into integers</li>
<li>These integers can then be embedded (later) as input of/for the LLM</li>
</ul>
<div id="647364ec-7995-4654-9b4a-7607ccf5f1e4" class="cell" data-execution_count="14">
<div class="cell-output cell-output-stdout">
<pre><code>[1, 56, 2, 850, 988, 602, 533, 746, 5, 1126, 596, 5, 1, 67, 7, 38, 851, 1108, 754, 793, 7]</code></pre>
</div>
</div>
<ul>
<li>We can decode the integers back into text</li>
</ul>
<div id="01d8c8fb-432d-4a49-b332-99f23b233746" class="cell" data-execution_count="15">
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>'" It\' s the last he painted, you know," Mrs. Gisburn said with pardonable pride.'</code></pre>
</div>
</div>
<div id="54f6aa8b-9827-412e-9035-e827296ab0fe" class="cell" data-execution_count="16">
<div class="cell-output cell-output-display" data-execution_count="16">
<pre><code>'" It\' s the last he painted, you know," Mrs. Gisburn said with pardonable pride.'</code></pre>
</div>
</div>
</section>
<section id="adding-special-context-tokens" class="level2">
<h2 class="anchored" data-anchor-id="adding-special-context-tokens">2.4 Adding special context tokens</h2>
<ul>
<li>It’s useful to add some “special” tokens for unknown words and to denote the end of a text</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch02_compressed/09.webp?123" width="500px"></p>
<ul>
<li><p>Some tokenizers use special tokens to help the LLM with additional context</p></li>
<li><p>Some of these special tokens are</p>
<ul>
<li><code>[BOS]</code> (beginning of sequence) marks the beginning of text</li>
<li><code>[EOS]</code> (end of sequence) marks where the text ends (this is usually used to concatenate multiple unrelated texts, e.g., two different Wikipedia articles or two different books, and so on)</li>
<li><code>[PAD]</code> (padding) if we train LLMs with a batch size greater than 1 (we may include multiple texts with different lengths; with the padding token we pad the shorter texts to the longest length so that all texts have an equal length)</li>
</ul></li>
<li><p><code>[UNK]</code> to represent words that are not included in the vocabulary</p></li>
<li><p>Note that GPT-2 does not need any of these tokens mentioned above but only uses an <code>&lt;|endoftext|&gt;</code> token to reduce complexity</p></li>
<li><p>The <code>&lt;|endoftext|&gt;</code> is analogous to the <code>[EOS]</code> token mentioned above</p></li>
<li><p>GPT also uses the <code>&lt;|endoftext|&gt;</code> for padding (since we typically use a mask when training on batched inputs, we would not attend padded tokens anyways, so it does not matter what these tokens are)</p></li>
<li><p>GPT-2 does not use an <code>&lt;UNK&gt;</code> token for out-of-vocabulary words; instead, GPT-2 uses a byte-pair encoding (BPE) tokenizer, which breaks down words into subword units which we will discuss in a later section</p></li>
<li><p>We use the <code>&lt;|endoftext|&gt;</code> tokens between two independent sources of text:</p></li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch02_compressed/10.webp" width="500px"></p>
<ul>
<li>Let’s see what happens if we tokenize the following text:</li>
</ul>
<div id="d5767eff-440c-4de1-9289-f789349d6b85" class="cell" data-execution_count="17">
<div class="cell-output cell-output-error">
<div class="ansi-escaped-output">
<pre><span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">KeyError</span>                                  Traceback (most recent call last)
Cell <span class="ansi-green-fg">In[17], line 5</span>
<span class="ansi-green-fg ansi-bold">      1</span> tokenizer <span style="color:rgb(98,98,98)">=</span> SimpleTokenizerV1(vocab)
<span class="ansi-green-fg ansi-bold">      3</span> text <span style="color:rgb(98,98,98)">=</span> <span style="color:rgb(175,0,0)">"</span><span style="color:rgb(175,0,0)">Hello, do you like tea. Is this-- a test?</span><span style="color:rgb(175,0,0)">"</span>
<span class="ansi-green-fg">----&gt; 5</span> tokenizer<span style="color:rgb(98,98,98)">.</span>encode(text)

Cell <span class="ansi-green-fg">In[13], line 12</span>, in <span class="ansi-cyan-fg">SimpleTokenizerV1.encode</span><span class="ansi-blue-fg">(self, text)</span>
<span class="ansi-green-fg ansi-bold">      7</span> preprocessed <span style="color:rgb(98,98,98)">=</span> re<span style="color:rgb(98,98,98)">.</span>split(<span style="color:rgb(175,0,0)">r</span><span style="color:rgb(175,0,0)">'</span><span style="color:rgb(175,0,0)">([,.:;?_!</span><span style="color:rgb(175,0,0)">"</span><span style="color:rgb(175,0,0)">()</span><span style="font-weight:bold;color:rgb(175,95,0)">\'</span><span style="color:rgb(175,0,0)">]|--|</span><span style="color:rgb(175,0,0)">\</span><span style="color:rgb(175,0,0)">s)</span><span style="color:rgb(175,0,0)">'</span>, text)
<span class="ansi-green-fg ansi-bold">      9</span> preprocessed <span style="color:rgb(98,98,98)">=</span> [
<span class="ansi-green-fg ansi-bold">     10</span>     item<span style="color:rgb(98,98,98)">.</span>strip() <span style="font-weight:bold;color:rgb(0,135,0)">for</span> item <span style="font-weight:bold;color:rgb(175,0,255)">in</span> preprocessed <span style="font-weight:bold;color:rgb(0,135,0)">if</span> item<span style="color:rgb(98,98,98)">.</span>strip()
<span class="ansi-green-fg ansi-bold">     11</span> ]
<span class="ansi-green-fg">---&gt; 12</span> ids <span style="color:rgb(98,98,98)">=</span> [<span style="color:rgb(0,135,0)">self</span><span style="color:rgb(98,98,98)">.</span>str_to_int[s] <span style="font-weight:bold;color:rgb(0,135,0)">for</span> s <span style="font-weight:bold;color:rgb(175,0,255)">in</span> preprocessed]
<span class="ansi-green-fg ansi-bold">     13</span> <span style="font-weight:bold;color:rgb(0,135,0)">return</span> ids

Cell <span class="ansi-green-fg">In[13], line 12</span>, in <span class="ansi-cyan-fg">&lt;listcomp&gt;</span><span class="ansi-blue-fg">(.0)</span>
<span class="ansi-green-fg ansi-bold">      7</span> preprocessed <span style="color:rgb(98,98,98)">=</span> re<span style="color:rgb(98,98,98)">.</span>split(<span style="color:rgb(175,0,0)">r</span><span style="color:rgb(175,0,0)">'</span><span style="color:rgb(175,0,0)">([,.:;?_!</span><span style="color:rgb(175,0,0)">"</span><span style="color:rgb(175,0,0)">()</span><span style="font-weight:bold;color:rgb(175,95,0)">\'</span><span style="color:rgb(175,0,0)">]|--|</span><span style="color:rgb(175,0,0)">\</span><span style="color:rgb(175,0,0)">s)</span><span style="color:rgb(175,0,0)">'</span>, text)
<span class="ansi-green-fg ansi-bold">      9</span> preprocessed <span style="color:rgb(98,98,98)">=</span> [
<span class="ansi-green-fg ansi-bold">     10</span>     item<span style="color:rgb(98,98,98)">.</span>strip() <span style="font-weight:bold;color:rgb(0,135,0)">for</span> item <span style="font-weight:bold;color:rgb(175,0,255)">in</span> preprocessed <span style="font-weight:bold;color:rgb(0,135,0)">if</span> item<span style="color:rgb(98,98,98)">.</span>strip()
<span class="ansi-green-fg ansi-bold">     11</span> ]
<span class="ansi-green-fg">---&gt; 12</span> ids <span style="color:rgb(98,98,98)">=</span> [<span style="color:rgb(0,135,0)">self</span><span style="color:rgb(98,98,98)">.</span>str_to_int[s] <span style="font-weight:bold;color:rgb(0,135,0)">for</span> s <span style="font-weight:bold;color:rgb(175,0,255)">in</span> preprocessed]
<span class="ansi-green-fg ansi-bold">     13</span> <span style="font-weight:bold;color:rgb(0,135,0)">return</span> ids

<span class="ansi-red-fg">KeyError</span>: 'Hello'</pre>
</div>
</div>
</div>
<ul>
<li>The above produces an error because the word “Hello” is not contained in the vocabulary</li>
<li>To deal with such cases, we can add special tokens like <code>"&lt;|unk|&gt;"</code> to the vocabulary to represent unknown words</li>
<li>Since we are already extending the vocabulary, let’s add another token called <code>"&lt;|endoftext|&gt;"</code> which is used in GPT-2 training to denote the end of a text (and it’s also used between concatenated text, like if our training datasets consists of multiple articles, books, etc.)</li>
</ul>
<div id="57c3143b-e860-4d3b-a22a-de22b547a6a9" class="cell" data-execution_count="19">
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>1132</code></pre>
</div>
</div>
<div id="50e51bb1-ae05-4aa8-a9ff-455b65ed1959" class="cell" data-execution_count="20">
<div class="cell-output cell-output-stdout">
<pre><code>('younger', 1127)
('your', 1128)
('yourself', 1129)
('&lt;|endoftext|&gt;', 1130)
('&lt;|unk|&gt;', 1131)</code></pre>
</div>
</div>
<ul>
<li>We also need to adjust the tokenizer accordingly so that it knows when and how to use the new <code>&lt;unk&gt;</code> token</li>
</ul>
<p>Let’s try to tokenize text with the modified tokenizer:</p>
<div id="4133c502-18ac-4412-9f43-01caf4efa3dc" class="cell" data-execution_count="22">
<div class="cell-output cell-output-stdout">
<pre><code>Hello, do you like tea? &lt;|endoftext|&gt; In the sunlit terraces of the palace.</code></pre>
</div>
</div>
<div id="7ed395fe-dc1b-4ed2-b85b-457cc35aab60" class="cell" data-execution_count="23">
<div class="cell-output cell-output-display" data-execution_count="23">
<pre><code>[1131, 5, 355, 1126, 628, 975, 10, 1130, 55, 988, 956, 984, 722, 988, 1131, 7]</code></pre>
</div>
</div>
<div id="059367f9-7a60-4c0d-8a00-7c4c766d0ebc" class="cell" data-execution_count="24">
<div class="cell-output cell-output-display" data-execution_count="24">
<pre><code>'&lt;|unk|&gt;, do you like tea? &lt;|endoftext|&gt; In the sunlit terraces of the &lt;|unk|&gt;.'</code></pre>
</div>
</div>
</section>
<section id="bytepair-encoding" class="level2">
<h2 class="anchored" data-anchor-id="bytepair-encoding">2.5 BytePair encoding</h2>
<ul>
<li>GPT-2 used BytePair encoding (BPE) as its tokenizer</li>
<li>it allows the model to break down words that aren’t in its predefined vocabulary into smaller subword units or even individual characters, enabling it to handle out-of-vocabulary words</li>
<li>For instance, if GPT-2’s vocabulary doesn’t have the word “unfamiliarword,” it might tokenize it as [“unfam”, “iliar”, “word”] or some other subword breakdown, depending on its trained BPE merges</li>
<li>The original BPE tokenizer can be found here: <a href="https://github.com/openai/gpt-2/blob/master/src/encoder.py">https://github.com/openai/gpt-2/blob/master/src/encoder.py</a></li>
<li>In this chapter, we are using the BPE tokenizer from OpenAI’s open-source <a href="https://github.com/openai/tiktoken">tiktoken</a> library, which implements its core algorithms in Rust to improve computational performance</li>
<li>I created a notebook in the <a href="../02_bonus_bytepair-encoder">./bytepair_encoder</a> that compares these two implementations side-by-side (tiktoken was about 5x faster on the sample text)</li>
</ul>
<div id="48967a77-7d17-42bf-9e92-fc619d63a59e" class="cell" data-execution_count="26">
<div class="cell-output cell-output-stdout">
<pre><code>tiktoken version: 0.7.0</code></pre>
</div>
</div>
<div id="5ff2cd85-7cfb-4325-b390-219938589428" class="cell" data-execution_count="28">
<div class="cell-output cell-output-stdout">
<pre><code>[15496, 11, 466, 345, 588, 8887, 30, 220, 50256, 554, 262, 4252, 18250, 8812, 2114, 1659, 617, 34680, 27271, 13]</code></pre>
</div>
</div>
<div id="d26a48bb-f82e-41a8-a955-a1c9cf9d50ab" class="cell" data-execution_count="29">
<div class="cell-output cell-output-stdout">
<pre><code>Hello, do you like tea? &lt;|endoftext|&gt; In the sunlit terracesof someunknownPlace.</code></pre>
</div>
</div>
<ul>
<li>BPE tokenizers break down unknown words into subwords and individual characters:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch02_compressed/11.webp" width="300px"></p>
</section>
<section id="data-sampling-with-a-sliding-window" class="level2">
<h2 class="anchored" data-anchor-id="data-sampling-with-a-sliding-window">2.6 Data sampling with a sliding window</h2>
<ul>
<li>We train LLMs to generate one word at a time, so we want to prepare the training data accordingly where the next word in a sequence represents the target to predict:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch02_compressed/12.webp" width="400px"></p>
<div id="848d5ade-fd1f-46c3-9e31-1426e315c71b" class="cell" data-execution_count="30">
<div class="cell-output cell-output-stdout">
<pre><code>5145</code></pre>
</div>
</div>
<ul>
<li>For each text chunk, we want the inputs and targets</li>
<li>Since we want the model to predict the next word, the targets are the inputs shifted by one position to the right</li>
</ul>
<div id="dfbff852-a92f-48c8-a46d-143a0f109f40" class="cell" data-execution_count="32">
<div class="cell-output cell-output-stdout">
<pre><code>x: [290, 4920, 2241, 287]
y:      [4920, 2241, 287, 257]</code></pre>
</div>
</div>
<ul>
<li>One by one, the prediction would look like as follows:</li>
</ul>
<div id="d97b031e-ed55-409d-95f2-aeb38c6fe366" class="cell" data-execution_count="33">
<div class="cell-output cell-output-stdout">
<pre><code>[290] ----&gt; 4920
[290, 4920] ----&gt; 2241
[290, 4920, 2241] ----&gt; 287
[290, 4920, 2241, 287] ----&gt; 257</code></pre>
</div>
</div>
<div id="f57bd746-dcbf-4433-8e24-ee213a8c34a1" class="cell" data-execution_count="34">
<div class="cell-output cell-output-stdout">
<pre><code> and ----&gt;  established
 and established ----&gt;  himself
 and established himself ----&gt;  in
 and established himself in ----&gt;  a</code></pre>
</div>
</div>
<ul>
<li><p>We will take care of the next-word prediction in a later chapter after we covered the attention mechanism</p></li>
<li><p>For now, we implement a simple data loader that iterates over the input dataset and returns the inputs and targets shifted by one</p></li>
<li><p>Install and import PyTorch (see Appendix A for installation tips)</p></li>
</ul>
<div id="e1770134-e7f3-4725-a679-e04c3be48cac" class="cell" data-execution_count="35">
<div class="cell-output cell-output-stdout">
<pre><code>PyTorch version: 2.5.1</code></pre>
</div>
</div>
<ul>
<li>We use a sliding window approach, changing the position by +1:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch02_compressed/13.webp?123" width="500px"></p>
<ul>
<li><p>Create dataset and dataloader that extract chunks from the input text dataset</p></li>
<li><p>Let’s test the dataloader with a batch size of 1 for an LLM with a context size of 4:</p></li>
</ul>
<div id="9226d00c-ad9a-4949-a6e4-9afccfc7214f" class="cell" data-execution_count="39">
<div class="cell-output cell-output-stdout">
<pre><code>[tensor([[  40,  367, 2885, 1464]]), tensor([[ 367, 2885, 1464, 1807]])]</code></pre>
</div>
</div>
<div id="10deb4bc-4de1-4d20-921e-4b1c7a0e1a6d" class="cell" data-execution_count="40">
<div class="cell-output cell-output-stdout">
<pre><code>[tensor([[ 367, 2885, 1464, 1807]]), tensor([[2885, 1464, 1807, 3619]])]</code></pre>
</div>
</div>
<ul>
<li>An example using stride equal to the context length (here: 4) as shown below:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch02_compressed/14.webp" width="500px"></p>
<ul>
<li>We can also create batched outputs</li>
<li>Note that we increase the stride here so that we don’t have overlaps between the batches, since more overlap could lead to increased overfitting</li>
</ul>
<div id="1916e7a6-f03d-4f09-91a6-d0bdbac5a58c" class="cell" data-execution_count="41">
<div class="cell-output cell-output-stdout">
<pre><code>Inputs:
 tensor([[   40,   367,  2885,  1464],
        [ 1807,  3619,   402,   271],
        [10899,  2138,   257,  7026],
        [15632,   438,  2016,   257],
        [  922,  5891,  1576,   438],
        [  568,   340,   373,   645],
        [ 1049,  5975,   284,   502],
        [  284,  3285,   326,    11]])

Targets:
 tensor([[  367,  2885,  1464,  1807],
        [ 3619,   402,   271, 10899],
        [ 2138,   257,  7026, 15632],
        [  438,  2016,   257,   922],
        [ 5891,  1576,   438,   568],
        [  340,   373,   645,  1049],
        [ 5975,   284,   502,   284],
        [ 3285,   326,    11,   287]])</code></pre>
</div>
</div>
</section>
<section id="creating-token-embeddings" class="level2">
<h2 class="anchored" data-anchor-id="creating-token-embeddings">2.7 Creating token embeddings</h2>
<ul>
<li>The data is already almost ready for an LLM</li>
<li>But lastly let us embed the tokens in a continuous vector representation using an embedding layer</li>
<li>Usually, these embedding layers are part of the LLM itself and are updated (trained) during model training</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch02_compressed/15.webp" width="400px"></p>
<ul>
<li><p>Suppose we have the following four input examples with input ids 2, 3, 5, and 1 (after tokenization):</p></li>
<li><p>For the sake of simplicity, suppose we have a small vocabulary of only 6 words and we want to create embeddings of size 3:</p></li>
<li><p>This would result in a 6x3 weight matrix:</p></li>
</ul>
<div id="a686eb61-e737-4351-8f1c-222913d47468" class="cell" data-execution_count="44">
<div class="cell-output cell-output-stdout">
<pre><code>Parameter containing:
tensor([[ 0.3374, -0.1778, -0.1690],
        [ 0.9178,  1.5810,  1.3010],
        [ 1.2753, -0.2010, -0.1606],
        [-0.4015,  0.9666, -1.1481],
        [-1.1589,  0.3255, -0.6315],
        [-2.8400, -0.7849, -1.4096]], requires_grad=True)</code></pre>
</div>
</div>
<ul>
<li><p>For those who are familiar with one-hot encoding, the embedding layer approach above is essentially just a more efficient way of implementing one-hot encoding followed by matrix multiplication in a fully-connected layer, which is described in the supplementary code in <a href="../03_bonus_embedding-vs-matmul">./embedding_vs_matmul</a></p></li>
<li><p>Because the embedding layer is just a more efficient implementation that is equivalent to the one-hot encoding and matrix-multiplication approach it can be seen as a neural network layer that can be optimized via backpropagation</p></li>
<li><p>To convert a token with id 3 into a 3-dimensional vector, we do the following:</p></li>
</ul>
<div id="e43600ba-f287-4746-8ddf-d0f71a9023ca" class="cell" data-execution_count="45">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[-0.4015,  0.9666, -1.1481]], grad_fn=&lt;EmbeddingBackward0&gt;)</code></pre>
</div>
</div>
<ul>
<li>Note that the above is the 4th row in the <code>embedding_layer</code> weight matrix</li>
<li>To embed all four <code>input_ids</code> values above, we do</li>
</ul>
<div id="50280ead-0363-44c8-8c35-bb885d92c8b7" class="cell" data-execution_count="46">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[ 1.2753, -0.2010, -0.1606],
        [-0.4015,  0.9666, -1.1481],
        [-2.8400, -0.7849, -1.4096],
        [ 0.9178,  1.5810,  1.3010]], grad_fn=&lt;EmbeddingBackward0&gt;)</code></pre>
</div>
</div>
<ul>
<li>An embedding layer is essentially a look-up operation:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch02_compressed/16.webp?123" width="500px"></p>
<ul>
<li><strong>You may be interested in the bonus content comparing embedding layers with regular linear layers: <a href="../03_bonus_embedding-vs-matmul">../03_bonus_embedding-vs-matmul</a></strong></li>
</ul>
</section>
<section id="encoding-word-positions" class="level2">
<h2 class="anchored" data-anchor-id="encoding-word-positions">2.8 Encoding word positions</h2>
<ul>
<li>Embedding layer convert IDs into identical vector representations regardless of where they are located in the input sequence:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch02_compressed/17.webp" width="400px"></p>
<ul>
<li>Positional embeddings are combined with the token embedding vector to form the input embeddings for a large language model:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch02_compressed/18.webp" width="500px"></p>
<ul>
<li><p>The BytePair encoder has a vocabulary size of 50,257:</p></li>
<li><p>Suppose we want to encode the input tokens into a 256-dimensional vector representation:</p></li>
<li><p>If we sample data from the dataloader, we embed the tokens in each batch into a 256-dimensional vector</p></li>
<li><p>If we have a batch size of 8 with 4 tokens each, this results in a 8 x 4 x 256 tensor:</p></li>
</ul>
<div id="84416b60-3707-4370-bcbc-da0b62f2b64d" class="cell" data-execution_count="49">
<div class="cell-output cell-output-stdout">
<pre><code>Token IDs:
 tensor([[   40,   367,  2885,  1464],
        [ 1807,  3619,   402,   271],
        [10899,  2138,   257,  7026],
        [15632,   438,  2016,   257],
        [  922,  5891,  1576,   438],
        [  568,   340,   373,   645],
        [ 1049,  5975,   284,   502],
        [  284,  3285,   326,    11]])

Inputs shape:
 torch.Size([8, 4])</code></pre>
</div>
</div>
<div id="7766ec38-30d0-4128-8c31-f49f063c43d1" class="cell" data-execution_count="50">
<div class="cell-output cell-output-stdout">
<pre><code>torch.Size([8, 4, 256])</code></pre>
</div>
</div>
<ul>
<li>GPT-2 uses absolute position embeddings, so we just create another embedding layer:</li>
</ul>
<div id="c369a1e7-d566-4b53-b398-d6adafb44105" class="cell" data-execution_count="52">
<div class="cell-output cell-output-stdout">
<pre><code>torch.Size([4, 256])</code></pre>
</div>
</div>
<ul>
<li>To create the input embeddings used in an LLM, we simply add the token and the positional embeddings:</li>
</ul>
<div id="b22fab89-526e-43c8-9035-5b7018e34288" class="cell" data-execution_count="53">
<div class="cell-output cell-output-stdout">
<pre><code>torch.Size([8, 4, 256])</code></pre>
</div>
</div>
<ul>
<li>In the initial phase of the input processing workflow, the input text is segmented into separate tokens</li>
<li>Following this segmentation, these tokens are transformed into token IDs based on a predefined vocabulary:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch02_compressed/19.webp" width="400px"></p>
</section>
<section id="summary-and-takeaways" class="level1">
<h1>Summary and takeaways</h1>
<p>See the <a href="./dataloader.ipynb">./dataloader.ipynb</a> code notebook, which is a concise version of the data loader that we implemented in this chapter and will need for training the GPT model in upcoming chapters.</p>
<p>See <a href="./exercise-solutions.ipynb">./exercise-solutions.ipynb</a> for the exercise solutions.</p>
<p>See the <a href="../02_bonus_bytepair-encoder/compare-bpe-tiktoken.ipynb">Byte Pair Encoding (BPE) Tokenizer From Scratch</a> notebook if you are interested in learning how the GPT-2 tokenizer can be implemented and trained from scratch.</p>
</section>
<a class="quarto-notebook-link" id="nblink-1" href="chapters/ch02-preview.html#76d5d2c0-cba8-404e-9bf3-71a218cae3cf">Source: 2.1 Understanding word embeddings</a></div>
</section>
<section id="coding-attention-mechanisms" class="level1">
<h1>3. Coding Attention Mechanisms</h1>
<div class="quarto-embed-nb-cell">
<p>Packages that are being used in this notebook:</p>
<div id="e58f33e8-5dc9-4dd5-ab84-5a011fa11d92" class="cell" data-execution_count="1">
<div class="cell-output cell-output-stdout">
<pre><code>torch version: 2.4.0</code></pre>
</div>
</div>
<ul>
<li>This chapter covers attention mechanisms, the engine of LLMs:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/01.webp?123" width="500px"></p>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/02.webp" width="600px"></p>
<section id="the-problem-with-modeling-long-sequences" class="level2">
<h2 class="anchored" data-anchor-id="the-problem-with-modeling-long-sequences">3.1 The problem with modeling long sequences</h2>
<ul>
<li>No code in this section</li>
<li>Translating a text word by word isn’t feasible due to the differences in grammatical structures between the source and target languages:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/03.webp" width="400px"></p>
<ul>
<li>Prior to the introduction of transformer models, encoder-decoder RNNs were commonly used for machine translation tasks</li>
<li>In this setup, the encoder processes a sequence of tokens from the source language, using a hidden state—a kind of intermediate layer within the neural network—to generate a condensed representation of the entire input sequence:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/04.webp" width="500px"></p>
</section>
<section id="capturing-data-dependencies-with-attention-mechanisms" class="level2">
<h2 class="anchored" data-anchor-id="capturing-data-dependencies-with-attention-mechanisms">3.2 Capturing data dependencies with attention mechanisms</h2>
<ul>
<li>No code in this section</li>
<li>Through an attention mechanism, the text-generating decoder segment of the network is capable of selectively accessing all input tokens, implying that certain input tokens hold more significance than others in the generation of a specific output token:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/05.webp" width="500px"></p>
<ul>
<li>Self-attention in transformers is a technique designed to enhance input representations by enabling each position in a sequence to engage with and determine the relevance of every other position within the same sequence</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/06.webp" width="300px"></p>
</section>
<section id="attending-to-different-parts-of-the-input-with-self-attention" class="level2">
<h2 class="anchored" data-anchor-id="attending-to-different-parts-of-the-input-with-self-attention">3.3 Attending to different parts of the input with self-attention</h2>
<section id="a-simple-self-attention-mechanism-without-trainable-weights" class="level3">
<h3 class="anchored" data-anchor-id="a-simple-self-attention-mechanism-without-trainable-weights">3.3.1 A simple self-attention mechanism without trainable weights</h3>
<ul>
<li>This section explains a very simplified variant of self-attention, which does not contain any trainable weights</li>
<li>This is purely for illustration purposes and NOT the attention mechanism that is used in transformers</li>
<li>The next section, section 3.3.2, will extend this simple attention mechanism to implement the real self-attention mechanism</li>
<li>Suppose we are given an input sequence <span class="math inline">\(x^{(1)}\)</span> to <span class="math inline">\(x^{(T)}\)</span>
<ul>
<li>The input is a text (for example, a sentence like “Your journey starts with one step”) that has already been converted into token embeddings as described in chapter 2</li>
<li>For instance, <span class="math inline">\(x^{(1)}\)</span> is a d-dimensional vector representing the word “Your”, and so forth</li>
</ul></li>
<li><strong>Goal:</strong> compute context vectors <span class="math inline">\(z^{(i)}\)</span> for each input sequence element <span class="math inline">\(x^{(i)}\)</span> in <span class="math inline">\(x^{(1)}\)</span> to <span class="math inline">\(x^{(T)}\)</span> (where <span class="math inline">\(z\)</span> and <span class="math inline">\(x\)</span> have the same dimension)
<ul>
<li>A context vector <span class="math inline">\(z^{(i)}\)</span> is a weighted sum over the inputs <span class="math inline">\(x^{(1)}\)</span> to <span class="math inline">\(x^{(T)}\)</span></li>
<li>The context vector is “context”-specific to a certain input
<ul>
<li>Instead of <span class="math inline">\(x^{(i)}\)</span> as a placeholder for an arbitrary input token, let’s consider the second input, <span class="math inline">\(x^{(2)}\)</span></li>
<li>And to continue with a concrete example, instead of the placeholder <span class="math inline">\(z^{(i)}\)</span>, we consider the second output context vector, <span class="math inline">\(z^{(2)}\)</span></li>
<li>The second context vector, <span class="math inline">\(z^{(2)}\)</span>, is a weighted sum over all inputs <span class="math inline">\(x^{(1)}\)</span> to <span class="math inline">\(x^{(T)}\)</span> weighted with respect to the second input element, <span class="math inline">\(x^{(2)}\)</span></li>
<li>The attention weights are the weights that determine how much each of the input elements contributes to the weighted sum when computing <span class="math inline">\(z^{(2)}\)</span></li>
<li>In short, think of <span class="math inline">\(z^{(2)}\)</span> as a modified version of <span class="math inline">\(x^{(2)}\)</span> that also incorporates information about all other input elements that are relevant to a given task at hand</li>
</ul></li>
</ul></li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/07.webp" width="400px"></p>
<ul>
<li><p>(Please note that the numbers in this figure are truncated to one digit after the decimal point to reduce visual clutter; similarly, other figures may also contain truncated values)</p></li>
<li><p>By convention, the unnormalized attention weights are referred to as <strong>“attention scores”</strong> whereas the normalized attention scores, which sum to 1, are referred to as <strong>“attention weights”</strong></p></li>
<li><p>The code below walks through the figure above step by step</p></li>
</ul>
<p><br></p>
<ul>
<li><p><strong>Step 1:</strong> compute unnormalized attention scores <span class="math inline">\(\omega\)</span></p></li>
<li><p>Suppose we use the second input token as the query, that is, <span class="math inline">\(q^{(2)} = x^{(2)}\)</span>, we compute the unnormalized attention scores via dot products:</p>
<ul>
<li><span class="math inline">\(\omega_{21} = x^{(1)} q^{(2)\top}\)</span></li>
<li><span class="math inline">\(\omega_{22} = x^{(2)} q^{(2)\top}\)</span></li>
<li><span class="math inline">\(\omega_{23} = x^{(3)} q^{(2)\top}\)</span></li>
<li>…</li>
<li><span class="math inline">\(\omega_{2T} = x^{(T)} q^{(2)\top}\)</span></li>
</ul></li>
<li><p>Above, <span class="math inline">\(\omega\)</span> is the Greek letter “omega” used to symbolize the unnormalized attention scores</p>
<ul>
<li>The subscript “21” in <span class="math inline">\(\omega_{21}\)</span> means that input sequence element 2 was used as a query against input sequence element 1</li>
</ul></li>
<li><p>Suppose we have the following input sentence that is already embedded in 3-dimensional vectors as described in chapter 3 (we use a very small embedding dimension here for illustration purposes, so that it fits onto the page without line breaks):</p></li>
<li><p>(In this book, we follow the common machine learning and deep learning convention where training examples are represented as rows and feature values as columns; in the case of the tensor shown above, each row represents a word, and each column represents an embedding dimension)</p></li>
<li><p>The primary objective of this section is to demonstrate how the context vector <span class="math inline">\(z^{(2)}\)</span> is calculated using the second input sequence, <span class="math inline">\(x^{(2)}\)</span>, as a query</p></li>
<li><p>The figure depicts the initial step in this process, which involves calculating the attention scores ω between <span class="math inline">\(x^{(2)}\)</span> and all other input elements through a dot product operation</p></li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/08.webp" width="400px"></p>
<ul>
<li>We use input sequence element 2, <span class="math inline">\(x^{(2)}\)</span>, as an example to compute context vector <span class="math inline">\(z^{(2)}\)</span>; later in this section, we will generalize this to compute all context vectors.</li>
<li>The first step is to compute the unnormalized attention scores by computing the dot product between the query <span class="math inline">\(x^{(2)}\)</span> and all other input tokens:</li>
</ul>
<div id="6fb5b2f8-dd2c-4a6d-94ef-a0e9ad163951" class="cell" data-execution_count="3">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([0.9544, 1.4950, 1.4754, 0.8434, 0.7070, 1.0865])</code></pre>
</div>
</div>
<ul>
<li>Side note: a dot product is essentially a shorthand for multiplying two vectors elements-wise and summing the resulting products:</li>
</ul>
<div id="9842f39b-1654-410e-88bf-d1b899bf0241" class="cell" data-execution_count="4">
<div class="cell-output cell-output-stdout">
<pre><code>tensor(0.9544)
tensor(0.9544)</code></pre>
</div>
</div>
<ul>
<li><strong>Step 2:</strong> normalize the unnormalized attention scores (“omegas”, <span class="math inline">\(\omega\)</span>) so that they sum up to 1</li>
<li>Here is a simple way to normalize the unnormalized attention scores to sum up to 1 (a convention, useful for interpretation, and important for training stability):</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/09.webp" width="500px"></p>
<div id="e3ccc99c-33ce-4f11-b7f2-353cf1cbdaba" class="cell" data-execution_count="5">
<div class="cell-output cell-output-stdout">
<pre><code>Attention weights: tensor([0.1455, 0.2278, 0.2249, 0.1285, 0.1077, 0.1656])
Sum: tensor(1.0000)</code></pre>
</div>
</div>
<ul>
<li>However, in practice, using the softmax function for normalization, which is better at handling extreme values and has more desirable gradient properties during training, is common and recommended.</li>
<li>Here’s a naive implementation of a softmax function for scaling, which also normalizes the vector elements such that they sum up to 1:</li>
</ul>
<div id="07b2e58d-a6ed-49f0-a1cd-2463e8d53a20" class="cell" data-execution_count="6">
<div class="cell-output cell-output-stdout">
<pre><code>Attention weights: tensor([0.1385, 0.2379, 0.2333, 0.1240, 0.1082, 0.1581])
Sum: tensor(1.)</code></pre>
</div>
</div>
<ul>
<li>The naive implementation above can suffer from numerical instability issues for large or small input values due to overflow and underflow issues</li>
<li>Hence, in practice, it’s recommended to use the PyTorch implementation of softmax instead, which has been highly optimized for performance:</li>
</ul>
<div id="2d99cac4-45ea-46b3-b3c1-e000ad16e158" class="cell" data-execution_count="7">
<div class="cell-output cell-output-stdout">
<pre><code>Attention weights: tensor([0.1385, 0.2379, 0.2333, 0.1240, 0.1082, 0.1581])
Sum: tensor(1.)</code></pre>
</div>
</div>
<ul>
<li><strong>Step 3</strong>: compute the context vector <span class="math inline">\(z^{(2)}\)</span> by multiplying the embedded input tokens, <span class="math inline">\(x^{(i)}\)</span> with the attention weights and sum the resulting vectors:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/10.webp" width="500px"></p>
<div id="8fcb96f0-14e5-4973-a50e-79ea7c6af99f" class="cell" data-execution_count="8">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([0.4419, 0.6515, 0.5683])</code></pre>
</div>
</div>
</section>
<section id="computing-attention-weights-for-all-input-tokens" class="level3">
<h3 class="anchored" data-anchor-id="computing-attention-weights-for-all-input-tokens">3.3.2 Computing attention weights for all input tokens</h3>
<section id="generalize-to-all-input-sequence-tokens" class="level4">
<h4 class="anchored" data-anchor-id="generalize-to-all-input-sequence-tokens">Generalize to all input sequence tokens:</h4>
<ul>
<li>Above, we computed the attention weights and context vector for input 2 (as illustrated in the highlighted row in the figure below)</li>
<li>Next, we are generalizing this computation to compute all attention weights and context vectors</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/11.webp" width="400px"></p>
<ul>
<li><p>(Please note that the numbers in this figure are truncated to two digits after the decimal point to reduce visual clutter; the values in each row should add up to 1.0 or 100%; similarly, digits in other figures are truncated)</p></li>
<li><p>In self-attention, the process starts with the calculation of attention scores, which are subsequently normalized to derive attention weights that total 1</p></li>
<li><p>These attention weights are then utilized to generate the context vectors through a weighted summation of the inputs</p></li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/12.webp" width="400px"></p>
<ul>
<li>Apply previous <strong>step 1</strong> to all pairwise elements to compute the unnormalized attention score matrix:</li>
</ul>
<div id="04004be8-07a1-468b-ab33-32e16a551b45" class="cell" data-execution_count="9">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[0.9995, 0.9544, 0.9422, 0.4753, 0.4576, 0.6310],
        [0.9544, 1.4950, 1.4754, 0.8434, 0.7070, 1.0865],
        [0.9422, 1.4754, 1.4570, 0.8296, 0.7154, 1.0605],
        [0.4753, 0.8434, 0.8296, 0.4937, 0.3474, 0.6565],
        [0.4576, 0.7070, 0.7154, 0.3474, 0.6654, 0.2935],
        [0.6310, 1.0865, 1.0605, 0.6565, 0.2935, 0.9450]])</code></pre>
</div>
</div>
<ul>
<li>We can achieve the same as above more efficiently via matrix multiplication:</li>
</ul>
<div id="2cea69d0-9a47-45da-8d5a-47ceef2df673" class="cell" data-execution_count="10">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[0.9995, 0.9544, 0.9422, 0.4753, 0.4576, 0.6310],
        [0.9544, 1.4950, 1.4754, 0.8434, 0.7070, 1.0865],
        [0.9422, 1.4754, 1.4570, 0.8296, 0.7154, 1.0605],
        [0.4753, 0.8434, 0.8296, 0.4937, 0.3474, 0.6565],
        [0.4576, 0.7070, 0.7154, 0.3474, 0.6654, 0.2935],
        [0.6310, 1.0865, 1.0605, 0.6565, 0.2935, 0.9450]])</code></pre>
</div>
</div>
<ul>
<li>Similar to <strong>step 2</strong> previously, we normalize each row so that the values in each row sum to 1:</li>
</ul>
<div id="fa4ef062-de81-47ee-8415-bfe1708c81b8" class="cell" data-execution_count="11">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[0.2098, 0.2006, 0.1981, 0.1242, 0.1220, 0.1452],
        [0.1385, 0.2379, 0.2333, 0.1240, 0.1082, 0.1581],
        [0.1390, 0.2369, 0.2326, 0.1242, 0.1108, 0.1565],
        [0.1435, 0.2074, 0.2046, 0.1462, 0.1263, 0.1720],
        [0.1526, 0.1958, 0.1975, 0.1367, 0.1879, 0.1295],
        [0.1385, 0.2184, 0.2128, 0.1420, 0.0988, 0.1896]])</code></pre>
</div>
</div>
<ul>
<li>Quick verification that the values in each row indeed sum to 1:</li>
</ul>
<div id="112b492c-fb6f-4e6d-8df5-518ae83363d5" class="cell" data-execution_count="12">
<div class="cell-output cell-output-stdout">
<pre><code>Row 2 sum: 1.0
All row sums: tensor([1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000])</code></pre>
</div>
</div>
<ul>
<li>Apply previous <strong>step 3</strong> to compute all context vectors:</li>
</ul>
<div id="ba8eafcf-f7f7-4989-b8dc-61b50c4f81dc" class="cell" data-execution_count="13">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[0.4421, 0.5931, 0.5790],
        [0.4419, 0.6515, 0.5683],
        [0.4431, 0.6496, 0.5671],
        [0.4304, 0.6298, 0.5510],
        [0.4671, 0.5910, 0.5266],
        [0.4177, 0.6503, 0.5645]])</code></pre>
</div>
</div>
<ul>
<li>As a sanity check, the previously computed context vector <span class="math inline">\(z^{(2)} = [0.4419, 0.6515, 0.5683]\)</span> can be found in the 2nd row in above:</li>
</ul>
<div id="2570eb7d-aee1-457a-a61e-7544478219fa" class="cell" data-execution_count="14">
<div class="cell-output cell-output-stdout">
<pre><code>Previous 2nd context vector: tensor([0.4419, 0.6515, 0.5683])</code></pre>
</div>
</div>
</section>
</section>
</section>
<section id="implementing-self-attention-with-trainable-weights" class="level2">
<h2 class="anchored" data-anchor-id="implementing-self-attention-with-trainable-weights">3.4 Implementing self-attention with trainable weights</h2>
<ul>
<li>A conceptual framework illustrating how the self-attention mechanism developed in this section integrates into the overall narrative and structure of this book and chapter</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/13.webp" width="400px"></p>
<section id="computing-the-attention-weights-step-by-step" class="level3">
<h3 class="anchored" data-anchor-id="computing-the-attention-weights-step-by-step">3.4.1 Computing the attention weights step by step</h3>
<ul>
<li>In this section, we are implementing the self-attention mechanism that is used in the original transformer architecture, the GPT models, and most other popular LLMs</li>
<li>This self-attention mechanism is also called “scaled dot-product attention”</li>
<li>The overall idea is similar to before:
<ul>
<li>We want to compute context vectors as weighted sums over the input vectors specific to a certain input element</li>
<li>For the above, we need attention weights</li>
</ul></li>
<li>As you will see, there are only slight differences compared to the basic attention mechanism introduced earlier:
<ul>
<li>The most notable difference is the introduction of weight matrices that are updated during model training</li>
<li>These trainable weight matrices are crucial so that the model (specifically, the attention module inside the model) can learn to produce “good” context vectors</li>
</ul></li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/14.webp" width="600px"></p>
<ul>
<li><p>Implementing the self-attention mechanism step by step, we will start by introducing the three training weight matrices <span class="math inline">\(W_q\)</span>, <span class="math inline">\(W_k\)</span>, and <span class="math inline">\(W_v\)</span></p></li>
<li><p>These three matrices are used to project the embedded input tokens, <span class="math inline">\(x^{(i)}\)</span>, into query, key, and value vectors via matrix multiplication:</p>
<ul>
<li>Query vector: $q^{(i)} = x^{(i)},W_q $</li>
<li>Key vector: $k^{(i)} = x^{(i)},W_k $</li>
<li>Value vector: $v^{(i)} = x^{(i)},W_v $</li>
</ul></li>
<li><p>The embedding dimensions of the input <span class="math inline">\(x\)</span> and the query vector <span class="math inline">\(q\)</span> can be the same or different, depending on the model’s design and specific implementation</p></li>
<li><p>In GPT models, the input and output dimensions are usually the same, but for illustration purposes, to better follow the computation, we choose different input and output dimensions here:</p></li>
<li><p>Below, we initialize the three weight matrices; note that we are setting <code>requires_grad=False</code> to reduce clutter in the outputs for illustration purposes, but if we were to use the weight matrices for model training, we would set <code>requires_grad=True</code> to update these matrices during model training</p></li>
<li><p>Next we compute the query, key, and value vectors:</p></li>
</ul>
<div id="73cedd62-01e1-4196-a575-baecc6095601" class="cell" data-execution_count="17">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([0.4306, 1.4551])</code></pre>
</div>
</div>
<ul>
<li>As we can see below, we successfully projected the 6 input tokens from a 3D onto a 2D embedding space:</li>
</ul>
<div id="8c1c3949-fc08-4d19-a41e-1c235b4e631b" class="cell" data-execution_count="18">
<div class="cell-output cell-output-stdout">
<pre><code>keys.shape: torch.Size([6, 2])
values.shape: torch.Size([6, 2])</code></pre>
</div>
</div>
<ul>
<li>In the next step, <strong>step 2</strong>, we compute the unnormalized attention scores by computing the dot product between the query and each key vector:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/15.webp" width="600px"></p>
<div id="64cbc253-a182-4490-a765-246979ea0a28" class="cell" data-execution_count="19">
<div class="cell-output cell-output-stdout">
<pre><code>tensor(1.8524)</code></pre>
</div>
</div>
<ul>
<li>Since we have 6 inputs, we have 6 attention scores for the given query vector:</li>
</ul>
<div id="b14e44b5-d170-40f9-8847-8990804af26d" class="cell" data-execution_count="20">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([1.2705, 1.8524, 1.8111, 1.0795, 0.5577, 1.5440])</code></pre>
</div>
</div>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/16.webp" width="600px"></p>
<ul>
<li>Next, in <strong>step 3</strong>, we compute the attention weights (normalized attention scores that sum up to 1) using the softmax function we used earlier</li>
<li>The difference to earlier is that we now scale the attention scores by dividing them by the square root of the embedding dimension, <span class="math inline">\(\sqrt{d_k}\)</span> (i.e., <code>d_k**0.5</code>):</li>
</ul>
<div id="146f5587-c845-4e30-9894-c7ed3a248153" class="cell" data-execution_count="21">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([0.1500, 0.2264, 0.2199, 0.1311, 0.0906, 0.1820])</code></pre>
</div>
</div>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/17.webp" width="600px"></p>
<ul>
<li>In <strong>step 4</strong>, we now compute the context vector for input query vector 2:</li>
</ul>
<div id="e138f033-fa7e-4e3a-8764-b53a96b26397" class="cell" data-execution_count="22">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([0.3061, 0.8210])</code></pre>
</div>
</div>
</section>
<section id="implementing-a-compact-selfattention-class" class="level3">
<h3 class="anchored" data-anchor-id="implementing-a-compact-selfattention-class">3.4.2 Implementing a compact SelfAttention class</h3>
<ul>
<li>Putting it all together, we can implement the self-attention mechanism as follows:</li>
</ul>
<div id="51590326-cdbe-4e62-93b1-17df71c11ee4" class="cell" data-execution_count="23">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[0.2996, 0.8053],
        [0.3061, 0.8210],
        [0.3058, 0.8203],
        [0.2948, 0.7939],
        [0.2927, 0.7891],
        [0.2990, 0.8040]], grad_fn=&lt;MmBackward0&gt;)</code></pre>
</div>
</div>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/18.webp" width="400px"></p>
<ul>
<li>We can streamline the implementation above using PyTorch’s Linear layers, which are equivalent to a matrix multiplication if we disable the bias units</li>
<li>Another big advantage of using <code>nn.Linear</code> over our manual <code>nn.Parameter(torch.rand(...)</code> approach is that <code>nn.Linear</code> has a preferred weight initialization scheme, which leads to more stable model training</li>
</ul>
<div id="73f411e3-e231-464a-89fe-0a9035e5f839" class="cell" data-execution_count="24">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[-0.0739,  0.0713],
        [-0.0748,  0.0703],
        [-0.0749,  0.0702],
        [-0.0760,  0.0685],
        [-0.0763,  0.0679],
        [-0.0754,  0.0693]], grad_fn=&lt;MmBackward0&gt;)</code></pre>
</div>
</div>
<ul>
<li>Note that <code>SelfAttention_v1</code> and <code>SelfAttention_v2</code> give different outputs because they use different initial weights for the weight matrices</li>
</ul>
</section>
</section>
<section id="hiding-future-words-with-causal-attention" class="level2">
<h2 class="anchored" data-anchor-id="hiding-future-words-with-causal-attention">3.5 Hiding future words with causal attention</h2>
<ul>
<li>In causal attention, the attention weights above the diagonal are masked, ensuring that for any given input, the LLM is unable to utilize future tokens while calculating the context vectors with the attention weight</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/19.webp" width="400px"></p>
<section id="applying-a-causal-attention-mask" class="level3">
<h3 class="anchored" data-anchor-id="applying-a-causal-attention-mask">3.5.1 Applying a causal attention mask</h3>
<ul>
<li>In this section, we are converting the previous self-attention mechanism into a causal self-attention mechanism</li>
<li>Causal self-attention ensures that the model’s prediction for a certain position in a sequence is only dependent on the known outputs at previous positions, not on future positions</li>
<li>In simpler words, this ensures that each next word prediction should only depend on the preceding words</li>
<li>To achieve this, for each given token, we mask out the future tokens (the ones that come after the current token in the input text):</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/20.webp" width="600px"></p>
<ul>
<li>To illustrate and implement causal self-attention, let’s work with the attention scores and weights from the previous section:</li>
</ul>
<div id="1933940d-0fa5-4b17-a3ce-388e5314a1bb" class="cell" data-execution_count="25">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[0.1921, 0.1646, 0.1652, 0.1550, 0.1721, 0.1510],
        [0.2041, 0.1659, 0.1662, 0.1496, 0.1665, 0.1477],
        [0.2036, 0.1659, 0.1662, 0.1498, 0.1664, 0.1480],
        [0.1869, 0.1667, 0.1668, 0.1571, 0.1661, 0.1564],
        [0.1830, 0.1669, 0.1670, 0.1588, 0.1658, 0.1585],
        [0.1935, 0.1663, 0.1666, 0.1542, 0.1666, 0.1529]],
       grad_fn=&lt;SoftmaxBackward0&gt;)</code></pre>
</div>
</div>
<ul>
<li>The simplest way to mask out future attention weights is by creating a mask via PyTorch’s tril function with elements below the main diagonal (including the diagonal itself) set to 1 and above the main diagonal set to 0:</li>
</ul>
<div id="43f3d2e3-185b-4184-9f98-edde5e6df746" class="cell" data-execution_count="26">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[1., 0., 0., 0., 0., 0.],
        [1., 1., 0., 0., 0., 0.],
        [1., 1., 1., 0., 0., 0.],
        [1., 1., 1., 1., 0., 0.],
        [1., 1., 1., 1., 1., 0.],
        [1., 1., 1., 1., 1., 1.]])</code></pre>
</div>
</div>
<ul>
<li>Then, we can multiply the attention weights with this mask to zero out the attention scores above the diagonal:</li>
</ul>
<div id="9f531e2e-f4d2-4fea-a87f-4c132e48b9e7" class="cell" data-execution_count="27">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[0.1921, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
        [0.2041, 0.1659, 0.0000, 0.0000, 0.0000, 0.0000],
        [0.2036, 0.1659, 0.1662, 0.0000, 0.0000, 0.0000],
        [0.1869, 0.1667, 0.1668, 0.1571, 0.0000, 0.0000],
        [0.1830, 0.1669, 0.1670, 0.1588, 0.1658, 0.0000],
        [0.1935, 0.1663, 0.1666, 0.1542, 0.1666, 0.1529]],
       grad_fn=&lt;MulBackward0&gt;)</code></pre>
</div>
</div>
<ul>
<li><p>However, if the mask were applied after softmax, like above, it would disrupt the probability distribution created by softmax</p></li>
<li><p>Softmax ensures that all output values sum to 1</p></li>
<li><p>Masking after softmax would require re-normalizing the outputs to sum to 1 again, which complicates the process and might lead to unintended effects</p></li>
<li><p>To make sure that the rows sum to 1, we can normalize the attention weights as follows:</p></li>
</ul>
<div id="6d392083-fd81-4f70-9bdf-8db985e673d6" class="cell" data-execution_count="28">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
        [0.5517, 0.4483, 0.0000, 0.0000, 0.0000, 0.0000],
        [0.3800, 0.3097, 0.3103, 0.0000, 0.0000, 0.0000],
        [0.2758, 0.2460, 0.2462, 0.2319, 0.0000, 0.0000],
        [0.2175, 0.1983, 0.1984, 0.1888, 0.1971, 0.0000],
        [0.1935, 0.1663, 0.1666, 0.1542, 0.1666, 0.1529]],
       grad_fn=&lt;DivBackward0&gt;)</code></pre>
</div>
</div>
<ul>
<li>While we are technically done with coding the causal attention mechanism now, let’s briefly look at a more efficient approach to achieve the same as above</li>
<li>So, instead of zeroing out attention weights above the diagonal and renormalizing the results, we can mask the unnormalized attention scores above the diagonal with negative infinity before they enter the softmax function:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/21.webp" width="450px"></p>
<div id="a2be2f43-9cf0-44f6-8d8b-68ef2fb3cc39" class="cell" data-execution_count="29">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[0.2899,   -inf,   -inf,   -inf,   -inf,   -inf],
        [0.4656, 0.1723,   -inf,   -inf,   -inf,   -inf],
        [0.4594, 0.1703, 0.1731,   -inf,   -inf,   -inf],
        [0.2642, 0.1024, 0.1036, 0.0186,   -inf,   -inf],
        [0.2183, 0.0874, 0.0882, 0.0177, 0.0786,   -inf],
        [0.3408, 0.1270, 0.1290, 0.0198, 0.1290, 0.0078]],
       grad_fn=&lt;MaskedFillBackward0&gt;)</code></pre>
</div>
</div>
<ul>
<li>As we can see below, now the attention weights in each row correctly sum to 1 again:</li>
</ul>
<div id="b1cd6d7f-16f2-43c1-915e-0824f1a4bc52" class="cell" data-execution_count="30">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
        [0.5517, 0.4483, 0.0000, 0.0000, 0.0000, 0.0000],
        [0.3800, 0.3097, 0.3103, 0.0000, 0.0000, 0.0000],
        [0.2758, 0.2460, 0.2462, 0.2319, 0.0000, 0.0000],
        [0.2175, 0.1983, 0.1984, 0.1888, 0.1971, 0.0000],
        [0.1935, 0.1663, 0.1666, 0.1542, 0.1666, 0.1529]],
       grad_fn=&lt;SoftmaxBackward0&gt;)</code></pre>
</div>
</div>
</section>
<section id="masking-additional-attention-weights-with-dropout" class="level3">
<h3 class="anchored" data-anchor-id="masking-additional-attention-weights-with-dropout">3.5.2 Masking additional attention weights with dropout</h3>
<ul>
<li><p>In addition, we also apply dropout to reduce overfitting during training</p></li>
<li><p>Dropout can be applied in several places:</p>
<ul>
<li>for example, after computing the attention weights;</li>
<li>or after multiplying the attention weights with the value vectors</li>
</ul></li>
<li><p>Here, we will apply the dropout mask after computing the attention weights because it’s more common</p></li>
<li><p>Furthermore, in this specific example, we use a dropout rate of 50%, which means randomly masking out half of the attention weights. (When we train the GPT model later, we will use a lower dropout rate, such as 0.1 or 0.2</p></li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/22.webp" width="400px"></p>
<ul>
<li>If we apply a dropout rate of 0.5 (50%), the non-dropped values will be scaled accordingly by a factor of 1/0.5 = 2</li>
<li>The scaling is calculated by the formula 1 / (1 - <code>dropout_rate</code>)</li>
</ul>
<div id="0de578db-8289-41d6-b377-ef645751e33f" class="cell" data-execution_count="31">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[2., 2., 0., 2., 2., 0.],
        [0., 0., 0., 2., 0., 2.],
        [2., 2., 2., 2., 0., 2.],
        [0., 2., 2., 0., 0., 2.],
        [0., 2., 0., 2., 0., 2.],
        [0., 2., 2., 2., 2., 0.]])</code></pre>
</div>
</div>
<div id="b16c5edb-942b-458c-8e95-25e4e355381e" class="cell" data-execution_count="32">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[2.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
        [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
        [0.7599, 0.6194, 0.6206, 0.0000, 0.0000, 0.0000],
        [0.0000, 0.4921, 0.4925, 0.0000, 0.0000, 0.0000],
        [0.0000, 0.3966, 0.0000, 0.3775, 0.0000, 0.0000],
        [0.0000, 0.3327, 0.3331, 0.3084, 0.3331, 0.0000]],
       grad_fn=&lt;MulBackward0&gt;)</code></pre>
</div>
</div>
<ul>
<li>Note that the resulting dropout outputs may look different depending on your operating system; you can read more about this inconsistency <a href="https://github.com/pytorch/pytorch/issues/121595">here on the PyTorch issue tracker</a></li>
</ul>
</section>
<section id="implementing-a-compact-causal-self-attention-class" class="level3">
<h3 class="anchored" data-anchor-id="implementing-a-compact-causal-self-attention-class">3.5.3 Implementing a compact causal self-attention class</h3>
<ul>
<li>Now, we are ready to implement a working implementation of self-attention, including the causal and dropout masks</li>
<li>One more thing is to implement the code to handle batches consisting of more than one input so that our <code>CausalAttention</code> class supports the batch outputs produced by the data loader we implemented in chapter 2</li>
<li>For simplicity, to simulate such batch input, we duplicate the input text example:</li>
</ul>
<div id="977a5fa7-a9d5-4e2e-8a32-8e0331ccfe28" class="cell" data-execution_count="33">
<div class="cell-output cell-output-stdout">
<pre><code>torch.Size([2, 6, 3])</code></pre>
</div>
</div>
<div id="60d8c2eb-2d8e-4d2c-99bc-9eef8cc53ca0" class="cell" data-execution_count="34">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[[-0.4519,  0.2216],
         [-0.5874,  0.0058],
         [-0.6300, -0.0632],
         [-0.5675, -0.0843],
         [-0.5526, -0.0981],
         [-0.5299, -0.1081]],

        [[-0.4519,  0.2216],
         [-0.5874,  0.0058],
         [-0.6300, -0.0632],
         [-0.5675, -0.0843],
         [-0.5526, -0.0981],
         [-0.5299, -0.1081]]], grad_fn=&lt;UnsafeViewBackward0&gt;)
context_vecs.shape: torch.Size([2, 6, 2])</code></pre>
</div>
</div>
<ul>
<li>Note that dropout is only applied during training, not during inference</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/23.webp" width="500px"></p>
</section>
</section>
<section id="extending-single-head-attention-to-multi-head-attention" class="level2">
<h2 class="anchored" data-anchor-id="extending-single-head-attention-to-multi-head-attention">3.6 Extending single-head attention to multi-head attention</h2>
<section id="stacking-multiple-single-head-attention-layers" class="level3">
<h3 class="anchored" data-anchor-id="stacking-multiple-single-head-attention-layers">3.6.1 Stacking multiple single-head attention layers</h3>
<ul>
<li><p>Below is a summary of the self-attention implemented previously (causal and dropout masks not shown for simplicity)</p></li>
<li><p>This is also called single-head attention:</p></li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/24.webp" width="400px"></p>
<ul>
<li>We simply stack multiple single-head attention modules to obtain a multi-head attention module:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/25.webp" width="400px"></p>
<ul>
<li>The main idea behind multi-head attention is to run the attention mechanism multiple times (in parallel) with different, learned linear projections. This allows the model to jointly attend to information from different representation subspaces at different positions.</li>
</ul>
<div id="b9a66e11-7105-4bb4-be84-041f1a1f3bd2" class="cell" data-execution_count="35">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[[-0.4519,  0.2216,  0.4772,  0.1063],
         [-0.5874,  0.0058,  0.5891,  0.3257],
         [-0.6300, -0.0632,  0.6202,  0.3860],
         [-0.5675, -0.0843,  0.5478,  0.3589],
         [-0.5526, -0.0981,  0.5321,  0.3428],
         [-0.5299, -0.1081,  0.5077,  0.3493]],

        [[-0.4519,  0.2216,  0.4772,  0.1063],
         [-0.5874,  0.0058,  0.5891,  0.3257],
         [-0.6300, -0.0632,  0.6202,  0.3860],
         [-0.5675, -0.0843,  0.5478,  0.3589],
         [-0.5526, -0.0981,  0.5321,  0.3428],
         [-0.5299, -0.1081,  0.5077,  0.3493]]], grad_fn=&lt;CatBackward0&gt;)
context_vecs.shape: torch.Size([2, 6, 4])</code></pre>
</div>
</div>
<ul>
<li>In the implementation above, the embedding dimension is 4, because we <code>d_out=2</code> as the embedding dimension for the key, query, and value vectors as well as the context vector. And since we have 2 attention heads, we have the output embedding dimension 2*2=4</li>
</ul>
</section>
<section id="implementing-multi-head-attention-with-weight-splits" class="level3">
<h3 class="anchored" data-anchor-id="implementing-multi-head-attention-with-weight-splits">3.6.2 Implementing multi-head attention with weight splits</h3>
<ul>
<li><p>While the above is an intuitive and fully functional implementation of multi-head attention (wrapping the single-head attention <code>CausalAttention</code> implementation from earlier), we can write a stand-alone class called <code>MultiHeadAttention</code> to achieve the same</p></li>
<li><p>We don’t concatenate single attention heads for this stand-alone <code>MultiHeadAttention</code> class</p></li>
<li><p>Instead, we create single W_query, W_key, and W_value weight matrices and then split those into individual matrices for each attention head:</p></li>
</ul>
<div id="110b0188-6e9e-4e56-a988-10523c6c8538" class="cell" data-execution_count="36">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[[0.3190, 0.4858],
         [0.2943, 0.3897],
         [0.2856, 0.3593],
         [0.2693, 0.3873],
         [0.2639, 0.3928],
         [0.2575, 0.4028]],

        [[0.3190, 0.4858],
         [0.2943, 0.3897],
         [0.2856, 0.3593],
         [0.2693, 0.3873],
         [0.2639, 0.3928],
         [0.2575, 0.4028]]], grad_fn=&lt;ViewBackward0&gt;)
context_vecs.shape: torch.Size([2, 6, 2])</code></pre>
</div>
</div>
<ul>
<li>Note that the above is essentially a rewritten version of <code>MultiHeadAttentionWrapper</code> that is more efficient</li>
<li>The resulting output looks a bit different since the random weight initializations differ, but both are fully functional implementations that can be used in the GPT class we will implement in the upcoming chapters</li>
<li>Note that in addition, we added a linear projection layer (<code>self.out_proj</code>) to the <code>MultiHeadAttention</code> class above. This is simply a linear transformation that doesn’t change the dimensions. It’s a standard convention to use such a projection layer in LLM implementation, but it’s not strictly necessary (recent research has shown that it can be removed without affecting the modeling performance; see the further reading section at the end of this chapter)</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch03_compressed/26.webp" width="400px"></p>
<ul>
<li><p>Note that if you are interested in a compact and efficient implementation of the above, you can also consider the <a href="https://pytorch.org/docs/stable/generated/torch.nn.MultiheadAttention.html"><code>torch.nn.MultiheadAttention</code></a> class in PyTorch</p></li>
<li><p>Since the above implementation may look a bit complex at first glance, let’s look at what happens when executing <code>attn_scores = queries @ keys.transpose(2, 3)</code>:</p></li>
</ul>
<div id="e8cfc1ae-78ab-4faa-bc73-98bd054806c9" class="cell" data-execution_count="37">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[[[1.3208, 1.1631, 1.2879],
          [1.1631, 2.2150, 1.8424],
          [1.2879, 1.8424, 2.0402]],

         [[0.4391, 0.7003, 0.5903],
          [0.7003, 1.3737, 1.0620],
          [0.5903, 1.0620, 0.9912]]]])</code></pre>
</div>
</div>
<ul>
<li><p>In this case, the matrix multiplication implementation in PyTorch will handle the 4-dimensional input tensor so that the matrix multiplication is carried out between the 2 last dimensions (num_tokens, head_dim) and then repeated for the individual heads</p></li>
<li><p>For instance, the following becomes a more compact way to compute the matrix multiplication for each head separately:</p></li>
</ul>
<div id="053760f1-1a02-42f0-b3bf-3d939e407039" class="cell" data-execution_count="38">
<div class="cell-output cell-output-stdout">
<pre><code>First head:
 tensor([[1.3208, 1.1631, 1.2879],
        [1.1631, 2.2150, 1.8424],
        [1.2879, 1.8424, 2.0402]])

Second head:
 tensor([[0.4391, 0.7003, 0.5903],
        [0.7003, 1.3737, 1.0620],
        [0.5903, 1.0620, 0.9912]])</code></pre>
</div>
</div>
</section>
</section>
<section id="summary-and-takeaways-1" class="level1">
<h1>Summary and takeaways</h1>
<ul>
<li>See the <a href="./multihead-attention.ipynb">./multihead-attention.ipynb</a> code notebook, which is a concise version of the data loader (chapter 2) plus the multi-head attention class that we implemented in this chapter and will need for training the GPT model in upcoming chapters</li>
<li>You can find the exercise solutions in <a href="./exercise-solutions.ipynb">./exercise-solutions.ipynb</a></li>
</ul>
</section>
<a class="quarto-notebook-link" id="nblink-2" href="chapters/ch03-preview.html#c29bcbe8-a034-43a2-b557-997b03c9882d">Source: 3.1 The problem with modeling long sequences</a></div>
</section>
<section id="implementing-a-gpt-model-from-scratch-to-generate-text" class="level1">
<h1>4. Implementing a GPT model from Scratch To Generate Text</h1>
<div class="quarto-embed-nb-cell">
<div id="f9eac223-a125-40f7-bacc-bd0d890450c7" class="cell" data-execution_count="1">
<div class="cell-output cell-output-stdout">
<pre><code>matplotlib version: 3.10.0
torch version: 2.6.0
tiktoken version: 0.9.0</code></pre>
</div>
</div>
<ul>
<li>In this chapter, we implement a GPT-like LLM architecture; the next chapter will focus on training this LLM</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch04_compressed/01.webp" width="500px"></p>
<section id="coding-an-llm-architecture" class="level2">
<h2 class="anchored" data-anchor-id="coding-an-llm-architecture">4.1 Coding an LLM architecture</h2>
<ul>
<li>Chapter 1 discussed models like GPT and Llama, which generate words sequentially and are based on the decoder part of the original transformer architecture</li>
<li>Therefore, these LLMs are often referred to as “decoder-like” LLMs</li>
<li>Compared to conventional deep learning models, LLMs are larger, mainly due to their vast number of parameters, not the amount of code</li>
<li>We’ll see that many elements are repeated in an LLM’s architecture</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch04_compressed/02.webp" width="400px"></p>
<ul>
<li><p>In previous chapters, we used small embedding dimensions for token inputs and outputs for ease of illustration, ensuring they fit on a single page</p></li>
<li><p>In this chapter, we consider embedding and model sizes akin to a small GPT-2 model</p></li>
<li><p>We’ll specifically code the architecture of the smallest GPT-2 model (124 million parameters), as outlined in Radford et al.’s <a href="https://cdn.openai.com/better-language-models/language_models_are_unsupervised_multitask_learners.pdf">Language Models are Unsupervised Multitask Learners</a> (note that the initial report lists it as 117M parameters, but this was later corrected in the model weight repository)</p></li>
<li><p>Chapter 6 will show how to load pretrained weights into our implementation, which will be compatible with model sizes of 345, 762, and 1542 million parameters</p></li>
<li><p>Configuration details for the 124 million parameter GPT-2 model include:</p></li>
<li><p>We use short variable names to avoid long lines of code later</p></li>
<li><p><code>"vocab_size"</code> indicates a vocabulary size of 50,257 words, supported by the BPE tokenizer discussed in Chapter 2</p></li>
<li><p><code>"context_length"</code> represents the model’s maximum input token count, as enabled by positional embeddings covered in Chapter 2</p></li>
<li><p><code>"emb_dim"</code> is the embedding size for token inputs, converting each input token into a 768-dimensional vector</p></li>
<li><p><code>"n_heads"</code> is the number of attention heads in the multi-head attention mechanism implemented in Chapter 3</p></li>
<li><p><code>"n_layers"</code> is the number of transformer blocks within the model, which we’ll implement in upcoming sections</p></li>
<li><p><code>"drop_rate"</code> is the dropout mechanism’s intensity, discussed in Chapter 3; 0.1 means dropping 10% of hidden units during training to mitigate overfitting</p></li>
<li><p><code>"qkv_bias"</code> decides if the <code>Linear</code> layers in the multi-head attention mechanism (from Chapter 3) should include a bias vector when computing query (Q), key (K), and value (V) tensors; we’ll disable this option, which is standard practice in modern LLMs; however, we’ll revisit this later when loading pretrained GPT-2 weights from OpenAI into our reimplementation in chapter 5</p></li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch04_compressed/03.webp" width="500px"></p>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch04_compressed/04.webp?123" width="500px"></p>
<div id="794b6b6c-d36f-411e-a7db-8ac566a87fee" class="cell" data-execution_count="4">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[6109, 3626, 6100,  345],
        [6109, 1110, 6622,  257]])</code></pre>
</div>
</div>
<div id="009238cd-0160-4834-979c-309710986bb0" class="cell" data-execution_count="5">
<div class="cell-output cell-output-stdout">
<pre><code>Output shape: torch.Size([2, 4, 50257])
tensor([[[-1.2034,  0.3201, -0.7130,  ..., -1.5548, -0.2390, -0.4667],
         [-0.1192,  0.4539, -0.4432,  ...,  0.2392,  1.3469,  1.2430],
         [ 0.5307,  1.6720, -0.4695,  ...,  1.1966,  0.0111,  0.5835],
         [ 0.0139,  1.6754, -0.3388,  ...,  1.1586, -0.0435, -1.0400]],

        [[-1.0908,  0.1798, -0.9484,  ..., -1.6047,  0.2439, -0.4530],
         [-0.7860,  0.5581, -0.0610,  ...,  0.4835, -0.0077,  1.6621],
         [ 0.3567,  1.2698, -0.6398,  ..., -0.0162, -0.1296,  0.3717],
         [-0.2407, -0.7349, -0.5102,  ...,  2.0057, -0.3694,  0.1814]]],
       grad_fn=&lt;UnsafeViewBackward0&gt;)</code></pre>
</div>
</div>
<hr>
<p><strong>Note</strong></p>
<ul>
<li>If you are running this code on Windows or Linux, the resulting values above may look like as follows:</li>
</ul>
<pre><code>Output shape: torch.Size([2, 4, 50257])
tensor([[[-0.9289,  0.2748, -0.7557,  ..., -1.6070,  0.2702, -0.5888],
         [-0.4476,  0.1726,  0.5354,  ..., -0.3932,  1.5285,  0.8557],
         [ 0.5680,  1.6053, -0.2155,  ...,  1.1624,  0.1380,  0.7425],
         [ 0.0447,  2.4787, -0.8843,  ...,  1.3219, -0.0864, -0.5856]],

        [[-1.5474, -0.0542, -1.0571,  ..., -1.8061, -0.4494, -0.6747],
         [-0.8422,  0.8243, -0.1098,  ..., -0.1434,  0.2079,  1.2046],
         [ 0.1355,  1.1858, -0.1453,  ...,  0.0869, -0.1590,  0.1552],
         [ 0.1666, -0.8138,  0.2307,  ...,  2.5035, -0.3055, -0.3083]]],
       grad_fn=&lt;UnsafeViewBackward0&gt;)</code></pre>
<ul>
<li>Since these are just random numbers, this is not a reason for concern, and you can proceed with the remainder of the chapter without issues</li>
<li>One possible reason for this discrepancy is the differing behavior of <code>nn.Dropout</code> across operating systems, depending on how PyTorch was compiled, as discussed <a href="https://github.com/pytorch/pytorch/issues/121595">here on the PyTorch issue tracker</a></li>
</ul>
<hr>
</section>
<section id="normalizing-activations-with-layer-normalization" class="level2">
<h2 class="anchored" data-anchor-id="normalizing-activations-with-layer-normalization">4.2 Normalizing activations with layer normalization</h2>
<ul>
<li>Layer normalization, also known as LayerNorm (<a href="https://arxiv.org/abs/1607.06450">Ba et al.&nbsp;2016</a>), centers the activations of a neural network layer around a mean of 0 and normalizes their variance to 1</li>
<li>This stabilizes training and enables faster convergence to effective weights</li>
<li>Layer normalization is applied both before and after the multi-head attention module within the transformer block, which we will implement later; it’s also applied before the final output layer</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch04_compressed/05.webp" width="400px"></p>
<ul>
<li>Let’s see how layer normalization works by passing a small input sample through a simple neural network layer:</li>
</ul>
<div id="79e1b463-dc3f-44ac-9cdb-9d5b6f64eb9d" class="cell" data-execution_count="6">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[0.2260, 0.3470, 0.0000, 0.2216, 0.0000, 0.0000],
        [0.2133, 0.2394, 0.0000, 0.5198, 0.3297, 0.0000]],
       grad_fn=&lt;ReluBackward0&gt;)</code></pre>
</div>
</div>
<ul>
<li>Let’s compute the mean and variance for each of the 2 inputs above:</li>
</ul>
<div id="9888f79e-8e69-44aa-8a19-cd34292adbf5" class="cell" data-execution_count="7">
<div class="cell-output cell-output-stdout">
<pre><code>Mean:
 tensor([[0.1324],
        [0.2170]], grad_fn=&lt;MeanBackward1&gt;)
Variance:
 tensor([[0.0231],
        [0.0398]], grad_fn=&lt;VarBackward0&gt;)</code></pre>
</div>
</div>
<ul>
<li>The normalization is applied to each of the two inputs (rows) independently; using dim=-1 applies the calculation across the last dimension (in this case, the feature dimension) instead of the row dimension</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch04_compressed/06.webp" width="400px"></p>
<ul>
<li>Subtracting the mean and dividing by the square-root of the variance (standard deviation) centers the inputs to have a mean of 0 and a variance of 1 across the column (feature) dimension:</li>
</ul>
<div id="9a1d1bb9-3341-4c9a-bc2a-d2489bf89cda" class="cell" data-execution_count="8">
<div class="cell-output cell-output-stdout">
<pre><code>Normalized layer outputs:
 tensor([[ 0.6159,  1.4126, -0.8719,  0.5872, -0.8719, -0.8719],
        [-0.0189,  0.1121, -1.0876,  1.5173,  0.5647, -1.0876]],
       grad_fn=&lt;DivBackward0&gt;)
Mean:
 tensor([[-5.9605e-08],
        [ 1.9868e-08]], grad_fn=&lt;MeanBackward1&gt;)
Variance:
 tensor([[1.0000],
        [1.0000]], grad_fn=&lt;VarBackward0&gt;)</code></pre>
</div>
</div>
<ul>
<li>Each input is centered at 0 and has a unit variance of 1; to improve readability, we can disable PyTorch’s scientific notation:</li>
</ul>
<div id="3e06c34b-c68a-4b36-afbe-b30eda4eca39" class="cell" data-execution_count="9">
<div class="cell-output cell-output-stdout">
<pre><code>Mean:
 tensor([[    -0.0000],
        [     0.0000]], grad_fn=&lt;MeanBackward1&gt;)
Variance:
 tensor([[1.0000],
        [1.0000]], grad_fn=&lt;VarBackward0&gt;)</code></pre>
</div>
</div>
<ul>
<li>Above, we normalized the features of each input</li>
<li>Now, using the same idea, we can implement a <code>LayerNorm</code> class:</li>
</ul>
<p><strong>Scale and shift</strong></p>
<ul>
<li>Note that in addition to performing the normalization by subtracting the mean and dividing by the variance, we added two trainable parameters, a <code>scale</code> and a <code>shift</code> parameter</li>
<li>The initial <code>scale</code> (multiplying by 1) and <code>shift</code> (adding 0) values don’t have any effect; however, <code>scale</code> and <code>shift</code> are trainable parameters that the LLM automatically adjusts during training if it is determined that doing so would improve the model’s performance on its training task</li>
<li>This allows the model to learn appropriate scaling and shifting that best suit the data it is processing</li>
<li>Note that we also add a smaller value (<code>eps</code>) before computing the square root of the variance; this is to avoid division-by-zero errors if the variance is 0</li>
</ul>
<p><strong>Biased variance</strong> - In the variance calculation above, setting <code>unbiased=False</code> means using the formula <span class="math inline">\(\frac{\sum_i (x_i - \bar{x})^2}{n}\)</span> to compute the variance where n is the sample size (here, the number of features or columns); this formula does not include Bessel’s correction (which uses <code>n-1</code> in the denominator), thus providing a biased estimate of the variance - For LLMs, where the embedding dimension <code>n</code> is very large, the difference between using n and <code>n-1</code> is negligible - However, GPT-2 was trained with a biased variance in the normalization layers, which is why we also adopted this setting for compatibility reasons with the pretrained weights that we will load in later chapters</p>
<ul>
<li>Let’s now try out <code>LayerNorm</code> in practice:</li>
</ul>
<div id="94c12de2-1cab-46e0-a099-e2e470353bff" class="cell" data-execution_count="12">
<div class="cell-output cell-output-stdout">
<pre><code>Mean:
 tensor([[    -0.0000],
        [     0.0000]], grad_fn=&lt;MeanBackward1&gt;)
Variance:
 tensor([[1.0000],
        [1.0000]], grad_fn=&lt;VarBackward0&gt;)</code></pre>
</div>
</div>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch04_compressed/07.webp" width="400px"></p>
</section>
<section id="implementing-a-feed-forward-network-with-gelu-activations" class="level2">
<h2 class="anchored" data-anchor-id="implementing-a-feed-forward-network-with-gelu-activations">4.3 Implementing a feed forward network with GELU activations</h2>
<ul>
<li><p>In this section, we implement a small neural network submodule that is used as part of the transformer block in LLMs</p></li>
<li><p>We start with the activation function</p></li>
<li><p>In deep learning, ReLU (Rectified Linear Unit) activation functions are commonly used due to their simplicity and effectiveness in various neural network architectures</p></li>
<li><p>In LLMs, various other types of activation functions are used beyond the traditional ReLU; two notable examples are GELU (Gaussian Error Linear Unit) and SwiGLU (Swish-Gated Linear Unit)</p></li>
<li><p>GELU and SwiGLU are more complex, smooth activation functions incorporating Gaussian and sigmoid-gated linear units, respectively, offering better performance for deep learning models, unlike the simpler, piecewise linear function of ReLU</p></li>
<li><p>GELU (<a href="https://arxiv.org/abs/1606.08415">Hendrycks and Gimpel 2016</a>) can be implemented in several ways; the exact version is defined as GELU(x)=x⋅Φ(x), where Φ(x) is the cumulative distribution function of the standard Gaussian distribution.</p></li>
<li><p>In practice, it’s common to implement a computationally cheaper approximation: <span class="math inline">\(\text{GELU}(x) \approx 0.5 \cdot x \cdot \left(1 + \tanh\left[\sqrt{\frac{2}{\pi}} \cdot \left(x + 0.044715 \cdot x^3\right)\right]\right)\)</span> (the original GPT-2 model was also trained with this approximation)</p></li>
</ul>
<div id="fc5487d2-2576-4118-80a7-56c4caac2e71" class="cell" data-execution_count="14">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/chapters-ch04-cell-15-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<ul>
<li><p>As we can see, ReLU is a piecewise linear function that outputs the input directly if it is positive; otherwise, it outputs zero</p></li>
<li><p>GELU is a smooth, non-linear function that approximates ReLU but with a non-zero gradient for negative values (except at approximately -0.75)</p></li>
<li><p>Next, let’s implement the small neural network module, <code>FeedForward</code>, that we will be using in the LLM’s transformer block later:</p></li>
</ul>
<div id="7c4976e2-0261-418e-b042-c5be98c2ccaf" class="cell" data-execution_count="16">
<div class="cell-output cell-output-stdout">
<pre><code>768</code></pre>
</div>
</div>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch04_compressed/09.webp?12" width="400px"></p>
<div id="928e7f7c-d0b1-499f-8d07-4cadb428a6f9" class="cell" data-execution_count="17">
<div class="cell-output cell-output-stdout">
<pre><code>torch.Size([2, 3, 768])</code></pre>
</div>
</div>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch04_compressed/10.webp" width="400px"></p>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch04_compressed/11.webp" width="400px"></p>
</section>
<section id="adding-shortcut-connections" class="level2">
<h2 class="anchored" data-anchor-id="adding-shortcut-connections">4.4 Adding shortcut connections</h2>
<ul>
<li>Next, let’s talk about the concept behind shortcut connections, also called skip or residual connections</li>
<li>Originally, shortcut connections were proposed in deep networks for computer vision (residual networks) to mitigate vanishing gradient problems</li>
<li>A shortcut connection creates an alternative shorter path for the gradient to flow through the network</li>
<li>This is achieved by adding the output of one layer to the output of a later layer, usually skipping one or more layers in between</li>
<li>Let’s illustrate this idea with a small example network:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch04_compressed/12.webp?123" width="400px"></p>
<ul>
<li><p>In code, it looks like this:</p></li>
<li><p>Let’s print the gradient values first <strong>without</strong> shortcut connections:</p></li>
</ul>
<div id="c75f43cc-6923-4018-b980-26023086572c" class="cell" data-execution_count="19">
<div class="cell-output cell-output-stdout">
<pre><code>layers.0.0.weight has gradient mean of 0.00020173587836325169
layers.1.0.weight has gradient mean of 0.00012011159560643137
layers.2.0.weight has gradient mean of 0.0007152039906941354
layers.3.0.weight has gradient mean of 0.0013988736318424344
layers.4.0.weight has gradient mean of 0.005049645435065031</code></pre>
</div>
</div>
<ul>
<li>Next, let’s print the gradient values <strong>with</strong> shortcut connections:</li>
</ul>
<div id="11b7c0c2-f9dd-4dd5-b096-a05c48c5f6d6" class="cell" data-execution_count="20">
<div class="cell-output cell-output-stdout">
<pre><code>layers.0.0.weight has gradient mean of 0.22169792652130127
layers.1.0.weight has gradient mean of 0.20694106817245483
layers.2.0.weight has gradient mean of 0.32896995544433594
layers.3.0.weight has gradient mean of 0.2665732204914093
layers.4.0.weight has gradient mean of 1.3258540630340576</code></pre>
</div>
</div>
<ul>
<li>As we can see based on the output above, shortcut connections prevent the gradients from vanishing in the early layers (towards <code>layer.0</code>)</li>
<li>We will use this concept of a shortcut connection next when we implement a transformer block</li>
</ul>
</section>
<section id="connecting-attention-and-linear-layers-in-a-transformer-block" class="level2">
<h2 class="anchored" data-anchor-id="connecting-attention-and-linear-layers-in-a-transformer-block">4.5 Connecting attention and linear layers in a transformer block</h2>
<ul>
<li>In this section, we now combine the previous concepts into a so-called transformer block</li>
<li>A transformer block combines the causal multi-head attention module from the previous chapter with the linear layers, the feed forward neural network we implemented in an earlier section</li>
<li>In addition, the transformer block also uses dropout and shortcut connections</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch04_compressed/13.webp?1" width="400px"></p>
<ul>
<li>Suppose we have 2 input samples with 6 tokens each, where each token is a 768-dimensional embedding vector; then this transformer block applies self-attention, followed by linear layers, to produce an output of similar size</li>
<li>You can think of the output as an augmented version of the context vectors we discussed in the previous chapter</li>
</ul>
<div id="3fb45a63-b1f3-4b08-b525-dafbc8228405" class="cell" data-execution_count="22">
<div class="cell-output cell-output-stdout">
<pre><code>Input shape: torch.Size([2, 4, 768])
Output shape: torch.Size([2, 4, 768])</code></pre>
</div>
</div>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch04_compressed/14.webp?1" width="400px"></p>
</section>
<section id="coding-the-gpt-model" class="level2">
<h2 class="anchored" data-anchor-id="coding-the-gpt-model">4.6 Coding the GPT model</h2>
<ul>
<li>We are almost there: now let’s plug in the transformer block into the architecture we coded at the very beginning of this chapter so that we obtain a usable GPT architecture</li>
<li>Note that the transformer block is repeated multiple times; in the case of the smallest 124M GPT-2 model, we repeat it 12 times:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch04_compressed/15.webp" width="400px"></p>
<ul>
<li><p>The corresponding code implementation, where <code>cfg["n_layers"] = 12</code>:</p></li>
<li><p>Using the configuration of the 124M parameter model, we can now instantiate this GPT model with random initial weights as follows:</p></li>
</ul>
<div id="ef94fd9c-4e9d-470d-8f8e-dd23d1bb1f64" class="cell" data-execution_count="24">
<div class="cell-output cell-output-stdout">
<pre><code>Input batch:
 tensor([[6109, 3626, 6100,  345],
        [6109, 1110, 6622,  257]])

Output shape: torch.Size([2, 4, 50257])
tensor([[[ 0.3613,  0.4222, -0.0711,  ...,  0.3483,  0.4661, -0.2838],
         [-0.1792, -0.5660, -0.9485,  ...,  0.0477,  0.5181, -0.3168],
         [ 0.7120,  0.0332,  0.1085,  ...,  0.1018, -0.4327, -0.2553],
         [-1.0076,  0.3418, -0.1190,  ...,  0.7195,  0.4023,  0.0532]],

        [[-0.2564,  0.0900,  0.0335,  ...,  0.2659,  0.4454, -0.6806],
         [ 0.1230,  0.3653, -0.2074,  ...,  0.7705,  0.2710,  0.2246],
         [ 1.0558,  1.0318, -0.2800,  ...,  0.6936,  0.3205, -0.3178],
         [-0.1565,  0.3926,  0.3288,  ...,  1.2630, -0.1858,  0.0388]]],
       grad_fn=&lt;UnsafeViewBackward0&gt;)</code></pre>
</div>
</div>
<ul>
<li>We will train this model in the next chapter</li>
<li>However, a quick note about its size: we previously referred to it as a 124M parameter model; we can double check this number as follows:</li>
</ul>
<div id="84fb8be4-9d3b-402b-b3da-86b663aac33a" class="cell" data-execution_count="25">
<div class="cell-output cell-output-stdout">
<pre><code>Total number of parameters: 163,009,536</code></pre>
</div>
</div>
<ul>
<li>As we see above, this model has 163M, not 124M parameters; why?</li>
<li>In the original GPT-2 paper, the researchers applied weight tying, which means that they reused the token embedding layer (<code>tok_emb</code>) as the output layer, which means setting <code>self.out_head.weight = self.tok_emb.weight</code></li>
<li>The token embedding layer projects the 50,257-dimensional one-hot encoded input tokens to a 768-dimensional embedding representation</li>
<li>The output layer projects 768-dimensional embeddings back into a 50,257-dimensional representation so that we can convert these back into words (more about that in the next section)</li>
<li>So, the embedding and output layer have the same number of weight parameters, as we can see based on the shape of their weight matrices</li>
<li>However, a quick note about its size: we previously referred to it as a 124M parameter model; we can double check this number as follows:</li>
</ul>
<div id="e3b43233-e9b8-4f5a-b72b-a263ec686982" class="cell" data-execution_count="26">
<div class="cell-output cell-output-stdout">
<pre><code>Token embedding layer shape: torch.Size([50257, 768])
Output layer shape: torch.Size([50257, 768])</code></pre>
</div>
</div>
<ul>
<li>In the original GPT-2 paper, the researchers reused the token embedding matrix as an output matrix</li>
<li>Correspondingly, if we subtracted the number of parameters of the output layer, we’d get a 124M parameter model:</li>
</ul>
<div id="95a22e02-50d3-48b3-a4e0-d9863343c164" class="cell" data-execution_count="27">
<div class="cell-output cell-output-stdout">
<pre><code>Number of trainable parameters considering weight tying: 124,412,160</code></pre>
</div>
</div>
<ul>
<li>In practice, I found it easier to train the model without weight-tying, which is why we didn’t implement it here</li>
<li>However, we will revisit and apply this weight-tying idea later when we load the pretrained weights in chapter 5</li>
<li>Lastly, we can compute the memory requirements of the model as follows, which can be a helpful reference point:</li>
</ul>
<div id="5131a752-fab8-4d70-a600-e29870b33528" class="cell" data-execution_count="28">
<div class="cell-output cell-output-stdout">
<pre><code>Total size of the model: 621.83 MB</code></pre>
</div>
</div>
<ul>
<li><p>Exercise: you can try the following other configurations, which are referenced in the <a href="https://scholar.google.com/citations?view_op=view_citation&amp;hl=en&amp;user=dOad5HoAAAAJ&amp;citation_for_view=dOad5HoAAAAJ:YsMSGLbcyi4C">GPT-2 paper</a>, as well.</p>
<ul>
<li><strong>GPT2-small</strong> (the 124M configuration we already implemented):
<ul>
<li>“emb_dim” = 768</li>
<li>“n_layers” = 12</li>
<li>“n_heads” = 12</li>
</ul></li>
<li><strong>GPT2-medium:</strong>
<ul>
<li>“emb_dim” = 1024</li>
<li>“n_layers” = 24</li>
<li>“n_heads” = 16</li>
</ul></li>
<li><strong>GPT2-large:</strong>
<ul>
<li>“emb_dim” = 1280</li>
<li>“n_layers” = 36</li>
<li>“n_heads” = 20</li>
</ul></li>
<li><strong>GPT2-XL:</strong>
<ul>
<li>“emb_dim” = 1600</li>
<li>“n_layers” = 48</li>
<li>“n_heads” = 25</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="generating-text" class="level2">
<h2 class="anchored" data-anchor-id="generating-text">4.7 Generating text</h2>
<ul>
<li>LLMs like the GPT model we implemented above are used to generate one word at a time</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch04_compressed/16.webp" width="400px"></p>
<ul>
<li>The following <code>generate_text_simple</code> function implements greedy decoding, which is a simple and fast method to generate text</li>
<li>In greedy decoding, at each step, the model chooses the word (or token) with the highest probability as its next output (the highest logit corresponds to the highest probability, so we technically wouldn’t even have to compute the softmax function explicitly)</li>
<li>In the next chapter, we will implement a more advanced <code>generate_text</code> function</li>
<li>The figure below depicts how the GPT model, given an input context, generates the next word token</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch04_compressed/17.webp" width="600px"></p>
<ul>
<li>The <code>generate_text_simple</code> above implements an iterative process, where it creates one token at a time</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch04_compressed/18.webp" width="600px"></p>
<ul>
<li>Let’s prepare an input example:</li>
</ul>
<div id="3d7e3e94-df0f-4c0f-a6a1-423f500ac1d3" class="cell" data-execution_count="30">
<div class="cell-output cell-output-stdout">
<pre><code>encoded: [15496, 11, 314, 716]
encoded_tensor.shape: torch.Size([1, 4])</code></pre>
</div>
</div>
<div id="a72a9b60-de66-44cf-b2f9-1e638934ada4" class="cell" data-execution_count="31">
<div class="cell-output cell-output-stdout">
<pre><code>Output: tensor([[15496,    11,   314,   716, 27018, 24086, 47843, 30961, 42348,  7267]])
Output length: 10</code></pre>
</div>
</div>
<ul>
<li>Remove batch dimension and convert back into text:</li>
</ul>
<div id="053d99f6-5710-4446-8d52-117fb34ea9f6" class="cell" data-execution_count="32">
<div class="cell-output cell-output-stdout">
<pre><code>Hello, I am Featureiman Byeswickattribute argue</code></pre>
</div>
</div>
<ul>
<li>Note that the model is untrained; hence the random output texts above</li>
<li>We will train the model in the next chapter</li>
</ul>
</section>
<section id="summary-and-takeaways-2" class="level2">
<h2 class="anchored" data-anchor-id="summary-and-takeaways-2">Summary and takeaways</h2>
<ul>
<li>See the <a href="./gpt.py">./gpt.py</a> script, a self-contained script containing the GPT model we implement in this Jupyter notebook</li>
<li>You can find the exercise solutions in <a href="./exercise-solutions.ipynb">./exercise-solutions.ipynb</a></li>
</ul>
</section>
<a class="quarto-notebook-link" id="nblink-3" href="chapters/ch04-preview.html#f9eac223-a125-40f7-bacc-bd0d890450c7">Source: 4.1 Coding an LLM architecture</a></div>
</section>
<section id="pretraining-on-unlabeled-data" class="level1">
<h1>5. Pretraining on Unlabeled Data</h1>
</section>
<section id="chapter-5-pretraining-on-unlabeled-data" class="level1">
<h1>Chapter 5: Pretraining on Unlabeled Data</h1>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb94"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> importlib.metadata <span class="im">import</span> version</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>pkgs <span class="op">=</span> [<span class="st">"matplotlib"</span>, </span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"numpy"</span>, </span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"tiktoken"</span>, </span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"torch"</span>,</span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">"tensorflow"</span> <span class="co"># For OpenAI's pretrained weights</span></span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>       ]</span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> p <span class="kw">in</span> pkgs:</span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>p<span class="sc">}</span><span class="ss"> version: </span><span class="sc">{</span>version(p)<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>matplotlib version: 3.10.1
numpy version: 2.0.2
tiktoken version: 0.9.0
torch version: 2.6.0
tensorflow version: 2.18.0</code></pre>
<ul>
<li>In this chapter, we implement the training loop and code for basic model evaluation to pretrain an LLM</li>
<li>At the end of this chapter, we also load openly available pretrained weights from OpenAI into our model</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch05_compressed/chapter-overview.webp" width="500px"></p>
<ul>
<li>The topics covered in this chapter are shown below</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch05_compressed/mental-model--0.webp" width="400px"></p>
<section id="evaluating-generative-text-models" class="level2">
<h2 class="anchored" data-anchor-id="evaluating-generative-text-models">5.1 Evaluating generative text models</h2>
<ul>
<li>We start this section with a brief recap of initializing a GPT model using the code from the previous chapter</li>
<li>Then, we discuss basic evaluation metrics for LLMs</li>
<li>Lastly, in this section, we apply these evaluation metrics to a training and validation dataset</li>
</ul>
<section id="using-gpt-to-generate-text" class="level3">
<h3 class="anchored" data-anchor-id="using-gpt-to-generate-text">5.1.1 Using GPT to generate text</h3>
<ul>
<li>We initialize a GPT model using the code from the previous chapter</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb96"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> previous_chapters <span class="im">import</span> GPTModel</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="co"># If the `previous_chapters.py` file is not available locally,</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a><span class="co"># you can import it from the `llms-from-scratch` PyPI package.</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a><span class="co"># For details, see: https://github.com/rasbt/LLMs-from-scratch/tree/main/pkg</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a><span class="co"># E.g.,</span></span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a><span class="co"># from llms_from_scratch.ch04 import GPTModel</span></span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a>GPT_CONFIG_124M <span class="op">=</span> {</span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">"vocab_size"</span>: <span class="dv">50257</span>,   <span class="co"># Vocabulary size</span></span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">"context_length"</span>: <span class="dv">256</span>, <span class="co"># Shortened context length (orig: 1024)</span></span>
<span id="cb96-12"><a href="#cb96-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">"emb_dim"</span>: <span class="dv">768</span>,        <span class="co"># Embedding dimension</span></span>
<span id="cb96-13"><a href="#cb96-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">"n_heads"</span>: <span class="dv">12</span>,         <span class="co"># Number of attention heads</span></span>
<span id="cb96-14"><a href="#cb96-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">"n_layers"</span>: <span class="dv">12</span>,        <span class="co"># Number of layers</span></span>
<span id="cb96-15"><a href="#cb96-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">"drop_rate"</span>: <span class="fl">0.1</span>,      <span class="co"># Dropout rate</span></span>
<span id="cb96-16"><a href="#cb96-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">"qkv_bias"</span>: <span class="va">False</span>      <span class="co"># Query-key-value bias</span></span>
<span id="cb96-17"><a href="#cb96-17" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb96-18"><a href="#cb96-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-19"><a href="#cb96-19" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">123</span>)</span>
<span id="cb96-20"><a href="#cb96-20" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> GPTModel(GPT_CONFIG_124M)</span>
<span id="cb96-21"><a href="#cb96-21" aria-hidden="true" tabindex="-1"></a>model.<span class="bu">eval</span>()<span class="op">;</span>  <span class="co"># Disable dropout during inference</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ul>
<li>We use dropout of 0.1 above, but it’s relatively common to train LLMs without dropout nowadays</li>
<li>Modern LLMs also don’t use bias vectors in the <code>nn.Linear</code> layers for the query, key, and value matrices (unlike earlier GPT models), which is achieved by setting <code>"qkv_bias": False</code></li>
<li>We reduce the context length (<code>context_length</code>) of only 256 tokens to reduce the computational resource requirements for training the model, whereas the original 124 million parameter GPT-2 model used 1024 tokens
<ul>
<li>This is so that more readers will be able to follow and execute the code examples on their laptop computer</li>
<li>However, please feel free to increase the <code>context_length</code> to 1024 tokens (this would not require any code changes)</li>
<li>We will also load a model with a 1024 <code>context_length</code> later from pretrained weights</li>
</ul></li>
<li>Next, we use the <code>generate_text_simple</code> function from the previous chapter to generate text</li>
<li>In addition, we define two convenience functions, <code>text_to_token_ids</code> and <code>token_ids_to_text</code>, for converting between token and text representations that we use throughout this chapter</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch05_compressed/gpt-process.webp" width="500px"></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tiktoken</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> previous_chapters <span class="im">import</span> generate_text_simple</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Alternatively:</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a><span class="co"># from llms_from_scratch.ch04 import generate_text_simple</span></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> text_to_token_ids(text, tokenizer):</span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>    encoded <span class="op">=</span> tokenizer.encode(text, allowed_special<span class="op">=</span>{<span class="st">'&lt;|endoftext|&gt;'</span>})</span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a>    encoded_tensor <span class="op">=</span> torch.tensor(encoded).unsqueeze(<span class="dv">0</span>) <span class="co"># add batch dimension</span></span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> encoded_tensor</span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-12"><a href="#cb97-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> token_ids_to_text(token_ids, tokenizer):</span>
<span id="cb97-13"><a href="#cb97-13" aria-hidden="true" tabindex="-1"></a>    flat <span class="op">=</span> token_ids.squeeze(<span class="dv">0</span>) <span class="co"># remove batch dimension</span></span>
<span id="cb97-14"><a href="#cb97-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tokenizer.decode(flat.tolist())</span>
<span id="cb97-15"><a href="#cb97-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-16"><a href="#cb97-16" aria-hidden="true" tabindex="-1"></a>start_context <span class="op">=</span> <span class="st">"Every effort moves you"</span></span>
<span id="cb97-17"><a href="#cb97-17" aria-hidden="true" tabindex="-1"></a>tokenizer <span class="op">=</span> tiktoken.get_encoding(<span class="st">"gpt2"</span>)</span>
<span id="cb97-18"><a href="#cb97-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-19"><a href="#cb97-19" aria-hidden="true" tabindex="-1"></a>token_ids <span class="op">=</span> generate_text_simple(</span>
<span id="cb97-20"><a href="#cb97-20" aria-hidden="true" tabindex="-1"></a>    model<span class="op">=</span>model,</span>
<span id="cb97-21"><a href="#cb97-21" aria-hidden="true" tabindex="-1"></a>    idx<span class="op">=</span>text_to_token_ids(start_context, tokenizer),</span>
<span id="cb97-22"><a href="#cb97-22" aria-hidden="true" tabindex="-1"></a>    max_new_tokens<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb97-23"><a href="#cb97-23" aria-hidden="true" tabindex="-1"></a>    context_size<span class="op">=</span>GPT_CONFIG_124M[<span class="st">"context_length"</span>]</span>
<span id="cb97-24"><a href="#cb97-24" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb97-25"><a href="#cb97-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-26"><a href="#cb97-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Output text:</span><span class="ch">\n</span><span class="st">"</span>, token_ids_to_text(token_ids, tokenizer))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>Output text:
 Every effort moves you rentingetic wasnم refres RexMeCHicular stren</code></pre>
<ul>
<li>As we can see above, the model does not produce good text because it has not been trained yet</li>
<li>How do we measure or capture what “good text” is, in a numeric form, to track it during training?</li>
<li>The next subsection introduces metrics to calculate a loss metric for the generated outputs that we can use to measure the training progress</li>
<li>The next chapters on finetuning LLMs will also introduce additional ways to measure model quality</li>
</ul>
<p><br></p>
</section>
<section id="calculating-the-text-generation-loss-cross-entropy-and-perplexity" class="level3">
<h3 class="anchored" data-anchor-id="calculating-the-text-generation-loss-cross-entropy-and-perplexity">5.1.2 Calculating the text generation loss: cross-entropy and perplexity</h3>
<ul>
<li>Suppose we have an <code>inputs</code> tensor containing the token IDs for 2 training examples (rows)</li>
<li>Corresponding to the <code>inputs</code>, the <code>targets</code> contain the desired token IDs that we want the model to generate</li>
<li>Notice that the <code>targets</code> are the <code>inputs</code> shifted by 1 position, as explained in chapter 2 when we implemented the data loader</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>inputs <span class="op">=</span> torch.tensor([[<span class="dv">16833</span>, <span class="dv">3626</span>, <span class="dv">6100</span>],   <span class="co"># ["every effort moves",</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>                       [<span class="dv">40</span>,    <span class="dv">1107</span>, <span class="dv">588</span>]])   <span class="co">#  "I really like"]</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>targets <span class="op">=</span> torch.tensor([[<span class="dv">3626</span>, <span class="dv">6100</span>, <span class="dv">345</span>  ],  <span class="co"># [" effort moves you",</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>                        [<span class="dv">1107</span>,  <span class="dv">588</span>, <span class="dv">11311</span>]]) <span class="co">#  " really like chocolate"]</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ul>
<li>Feeding the <code>inputs</code> to the model, we obtain the logits vector for the 2 input examples that consist of 3 tokens each</li>
<li>Each of the tokens is a 50,257-dimensional vector corresponding to the size of the vocabulary</li>
<li>Applying the softmax function, we can turn the logits tensor into a tensor of the same dimension containing probability scores</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>    logits <span class="op">=</span> model(inputs)</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>probas <span class="op">=</span> torch.softmax(logits, dim<span class="op">=-</span><span class="dv">1</span>) <span class="co"># Probability of each token in vocabulary</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(probas.shape) <span class="co"># Shape: (batch_size, num_tokens, vocab_size)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>torch.Size([2, 3, 50257])</code></pre>
<ul>
<li>The figure below, using a very small vocabulary for illustration purposes, outlines how we convert the probability scores back into text, which we discussed at the end of the previous chapter</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch05_compressed/proba-to-text.webp" width="500px"></p>
<ul>
<li><p>As discussed in the previous chapter, we can apply the <code>argmax</code> function to convert the probability scores into predicted token IDs</p></li>
<li><p>The softmax function above produced a 50,257-dimensional vector for each token; the <code>argmax</code> function returns the position of the highest probability score in this vector, which is the predicted token ID for the given token</p></li>
<li><p>Since we have 2 input batches with 3 tokens each, we obtain 2 by 3 predicted token IDs:</p></li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>token_ids <span class="op">=</span> torch.argmax(probas, dim<span class="op">=-</span><span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Token IDs:</span><span class="ch">\n</span><span class="st">"</span>, token_ids)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>Token IDs:
 tensor([[[16657],
         [  339],
         [42826]],

        [[49906],
         [29669],
         [41751]]])</code></pre>
<ul>
<li>If we decode these tokens, we find that these are quite different from the tokens we want the model to predict, namely the target tokens:</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb104"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Targets batch 1: </span><span class="sc">{</span>token_ids_to_text(targets[<span class="dv">0</span>], tokenizer)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Outputs batch 1: </span><span class="sc">{</span>token_ids_to_text(token_ids[<span class="dv">0</span>].flatten(), tokenizer)<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>Targets batch 1:  effort moves you
Outputs batch 1:  Armed heNetflix</code></pre>
<ul>
<li>That’s because the model wasn’t trained yet</li>
<li>To train the model, we need to know how far it is away from the correct predictions (targets)</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch05_compressed/proba-index.webp" width="500px"></p>
<ul>
<li>The token probabilities corresponding to the target indices are as follows:</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb106"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>text_idx <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>target_probas_1 <span class="op">=</span> probas[text_idx, [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>], targets[text_idx]]</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Text 1:"</span>, target_probas_1)</span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>text_idx <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>target_probas_2 <span class="op">=</span> probas[text_idx, [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>], targets[text_idx]]</span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Text 2:"</span>, target_probas_2)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>Text 1: tensor([7.4541e-05, 3.1061e-05, 1.1563e-05])
Text 2: tensor([1.0337e-05, 5.6776e-05, 4.7559e-06])</code></pre>
<ul>
<li>We want to maximize all these values, bringing them close to a probability of 1</li>
<li>In mathematical optimization, it is easier to maximize the logarithm of the probability score than the probability score itself; this is out of the scope of this book, but I have recorded a lecture with more details here: <a href="https://www.youtube.com/watch?v=GxJe0DZvydM">L8.2 Logistic Regression Loss Function</a></li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb108"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute logarithm of all token probabilities</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>log_probas <span class="op">=</span> torch.log(torch.cat((target_probas_1, target_probas_2)))</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(log_probas)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>tensor([ -9.5042, -10.3796, -11.3677, -11.4798,  -9.7764, -12.2561])</code></pre>
<ul>
<li>Next, we compute the average log probability:</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb110"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the average probability for each token</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>avg_log_probas <span class="op">=</span> torch.mean(log_probas)</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(avg_log_probas)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>tensor(-10.7940)</code></pre>
<ul>
<li><p>The goal is to make this average log probability as large as possible by optimizing the model weights</p></li>
<li><p>Due to the log, the largest possible value is 0, and we are currently far away from 0</p></li>
<li><p>In deep learning, instead of maximizing the average log-probability, it’s a standard convention to minimize the <em>negative</em> average log-probability value; in our case, instead of maximizing -10.7722 so that it approaches 0, in deep learning, we would minimize 10.7722 so that it approaches 0</p></li>
<li><p>The value negative of -10.7722, i.e., 10.7722, is also called cross-entropy loss in deep learning</p></li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb112"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>neg_avg_log_probas <span class="op">=</span> avg_log_probas <span class="op">*</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(neg_avg_log_probas)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>tensor(10.7940)</code></pre>
<ul>
<li>PyTorch already implements a <code>cross_entropy</code> function that carries out the previous steps</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch05_compressed/cross-entropy.webp?123" width="400px"></p>
<ul>
<li>Before we apply the <code>cross_entropy</code> function, let’s check the shape of the logits and targets</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb114"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Logits have shape (batch_size, num_tokens, vocab_size)</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Logits shape:"</span>, logits.shape)</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Targets have shape (batch_size, num_tokens)</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Targets shape:"</span>, targets.shape)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>Logits shape: torch.Size([2, 3, 50257])
Targets shape: torch.Size([2, 3])</code></pre>
<ul>
<li>For the <code>cross_entropy</code> function in PyTorch, we want to flatten these tensors by combining them over the batch dimension:</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb116"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>logits_flat <span class="op">=</span> logits.flatten(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>targets_flat <span class="op">=</span> targets.flatten()</span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Flattened logits:"</span>, logits_flat.shape)</span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Flattened targets:"</span>, targets_flat.shape)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>Flattened logits: torch.Size([6, 50257])
Flattened targets: torch.Size([6])</code></pre>
<ul>
<li>Note that the targets are the token IDs, which also represent the index positions in the logits tensors that we want to maximize</li>
<li>The <code>cross_entropy</code> function in PyTorch will automatically take care of applying the softmax and log-probability computation internally over those token indices in the logits that are to be maximized</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb118"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>loss <span class="op">=</span> torch.nn.functional.cross_entropy(logits_flat, targets_flat)</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(loss)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>tensor(10.7940)</code></pre>
<ul>
<li>A concept related to the cross-entropy loss is the perplexity of an LLM</li>
<li>The perplexity is simply the exponential of the cross-entropy loss</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb120"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>perplexity <span class="op">=</span> torch.exp(loss)</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(perplexity)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>tensor(48725.8203)</code></pre>
<ul>
<li>The perplexity is often considered more interpretable because it can be understood as the effective vocabulary size that the model is uncertain about at each step (in the example above, that’d be 48,725 words or tokens)</li>
<li>In other words, perplexity provides a measure of how well the probability distribution predicted by the model matches the actual distribution of the words in the dataset</li>
<li>Similar to the loss, a lower perplexity indicates that the model predictions are closer to the actual distribution</li>
</ul>
</section>
<section id="calculating-the-training-and-validation-set-losses" class="level3">
<h3 class="anchored" data-anchor-id="calculating-the-training-and-validation-set-losses">5.1.3 Calculating the training and validation set losses</h3>
<ul>
<li>We use a relatively small dataset for training the LLM (in fact, only one short story)</li>
<li>The reasons are:
<ul>
<li>You can run the code examples in a few minutes on a laptop computer without a suitable GPU</li>
<li>The training finishes relatively fast (minutes instead of weeks), which is good for educational purposes</li>
<li>We use a text from the public domain, which can be included in this GitHub repository without violating any usage rights or bloating the repository size</li>
</ul></li>
<li>For example, Llama 2 7B required 184,320 GPU hours on A100 GPUs to be trained on 2 trillion tokens
<ul>
<li>At the time of this writing, the hourly cost of an 8xA100 cloud server at AWS is approximately \$30</li>
<li>So, via an off-the-envelope calculation, training this LLM would cost 184,320 / 8 * \$30 = \$690,000</li>
</ul></li>
<li>Below, we use the same dataset we used in chapter 2</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb122"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> urllib.request</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>file_path <span class="op">=</span> <span class="st">"the-verdict.txt"</span></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"https://raw.githubusercontent.com/rasbt/LLMs-from-scratch/main/ch02/01_main-chapter-code/the-verdict.txt"</span></span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> os.path.exists(file_path):</span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> urllib.request.urlopen(url) <span class="im">as</span> response:</span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a>        text_data <span class="op">=</span> response.read().decode(<span class="st">'utf-8'</span>)</span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(file_path, <span class="st">"w"</span>, encoding<span class="op">=</span><span class="st">"utf-8"</span>) <span class="im">as</span> <span class="bu">file</span>:</span>
<span id="cb122-11"><a href="#cb122-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">file</span>.write(text_data)</span>
<span id="cb122-12"><a href="#cb122-12" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb122-13"><a href="#cb122-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(file_path, <span class="st">"r"</span>, encoding<span class="op">=</span><span class="st">"utf-8"</span>) <span class="im">as</span> <span class="bu">file</span>:</span>
<span id="cb122-14"><a href="#cb122-14" aria-hidden="true" tabindex="-1"></a>        text_data <span class="op">=</span> <span class="bu">file</span>.read()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ul>
<li>A quick check that the text loaded ok by printing the first and last 99 characters</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb123"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="co"># First 99 characters</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(text_data[:<span class="dv">99</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>I HAD always thought Jack Gisburn rather a cheap genius--though a good fellow enough--so it was no </code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb125"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Last 99 characters</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(text_data[<span class="op">-</span><span class="dv">99</span>:])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>it for me! The Strouds stand alone, and happen once--but there's no exterminating our kind of art."</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb127"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>total_characters <span class="op">=</span> <span class="bu">len</span>(text_data)</span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>total_tokens <span class="op">=</span> <span class="bu">len</span>(tokenizer.encode(text_data))</span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Characters:"</span>, total_characters)</span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Tokens:"</span>, total_tokens)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>Characters: 20479
Tokens: 5145</code></pre>
<ul>
<li><p>With 5,145 tokens, the text is very short for training an LLM, but again, it’s for educational purposes (we will also load pretrained weights later)</p></li>
<li><p>Next, we divide the dataset into a training and a validation set and use the data loaders from chapter 2 to prepare the batches for LLM training</p></li>
<li><p>For visualization purposes, the figure below assumes a <code>max_length=6</code>, but for the training loader, we set the <code>max_length</code> equal to the context length that the LLM supports</p></li>
<li><p>The figure below only shows the input tokens for simplicity</p>
<ul>
<li>Since we train the LLM to predict the next word in the text, the targets look the same as these inputs, except that the targets are shifted by one position</li>
</ul></li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch05_compressed/batching.webp" width="500px"></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb129"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> previous_chapters <span class="im">import</span> create_dataloader_v1</span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Alternatively:</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a><span class="co"># from llms_from_scratch.ch02 import create_dataloader_v1</span></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Train/validation ratio</span></span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a>train_ratio <span class="op">=</span> <span class="fl">0.90</span></span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a>split_idx <span class="op">=</span> <span class="bu">int</span>(train_ratio <span class="op">*</span> <span class="bu">len</span>(text_data))</span>
<span id="cb129-8"><a href="#cb129-8" aria-hidden="true" tabindex="-1"></a>train_data <span class="op">=</span> text_data[:split_idx]</span>
<span id="cb129-9"><a href="#cb129-9" aria-hidden="true" tabindex="-1"></a>val_data <span class="op">=</span> text_data[split_idx:]</span>
<span id="cb129-10"><a href="#cb129-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-11"><a href="#cb129-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-12"><a href="#cb129-12" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">123</span>)</span>
<span id="cb129-13"><a href="#cb129-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-14"><a href="#cb129-14" aria-hidden="true" tabindex="-1"></a>train_loader <span class="op">=</span> create_dataloader_v1(</span>
<span id="cb129-15"><a href="#cb129-15" aria-hidden="true" tabindex="-1"></a>    train_data,</span>
<span id="cb129-16"><a href="#cb129-16" aria-hidden="true" tabindex="-1"></a>    batch_size<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb129-17"><a href="#cb129-17" aria-hidden="true" tabindex="-1"></a>    max_length<span class="op">=</span>GPT_CONFIG_124M[<span class="st">"context_length"</span>],</span>
<span id="cb129-18"><a href="#cb129-18" aria-hidden="true" tabindex="-1"></a>    stride<span class="op">=</span>GPT_CONFIG_124M[<span class="st">"context_length"</span>],</span>
<span id="cb129-19"><a href="#cb129-19" aria-hidden="true" tabindex="-1"></a>    drop_last<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb129-20"><a href="#cb129-20" aria-hidden="true" tabindex="-1"></a>    shuffle<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb129-21"><a href="#cb129-21" aria-hidden="true" tabindex="-1"></a>    num_workers<span class="op">=</span><span class="dv">0</span></span>
<span id="cb129-22"><a href="#cb129-22" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb129-23"><a href="#cb129-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-24"><a href="#cb129-24" aria-hidden="true" tabindex="-1"></a>val_loader <span class="op">=</span> create_dataloader_v1(</span>
<span id="cb129-25"><a href="#cb129-25" aria-hidden="true" tabindex="-1"></a>    val_data,</span>
<span id="cb129-26"><a href="#cb129-26" aria-hidden="true" tabindex="-1"></a>    batch_size<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb129-27"><a href="#cb129-27" aria-hidden="true" tabindex="-1"></a>    max_length<span class="op">=</span>GPT_CONFIG_124M[<span class="st">"context_length"</span>],</span>
<span id="cb129-28"><a href="#cb129-28" aria-hidden="true" tabindex="-1"></a>    stride<span class="op">=</span>GPT_CONFIG_124M[<span class="st">"context_length"</span>],</span>
<span id="cb129-29"><a href="#cb129-29" aria-hidden="true" tabindex="-1"></a>    drop_last<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb129-30"><a href="#cb129-30" aria-hidden="true" tabindex="-1"></a>    shuffle<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb129-31"><a href="#cb129-31" aria-hidden="true" tabindex="-1"></a>    num_workers<span class="op">=</span><span class="dv">0</span></span>
<span id="cb129-32"><a href="#cb129-32" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb130"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Sanity check</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> total_tokens <span class="op">*</span> (train_ratio) <span class="op">&lt;</span> GPT_CONFIG_124M[<span class="st">"context_length"</span>]:</span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Not enough tokens for the training loader. "</span></span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a>          <span class="st">"Try to lower the `GPT_CONFIG_124M['context_length']` or "</span></span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a>          <span class="st">"increase the `training_ratio`"</span>)</span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> total_tokens <span class="op">*</span> (<span class="dv">1</span><span class="op">-</span>train_ratio) <span class="op">&lt;</span> GPT_CONFIG_124M[<span class="st">"context_length"</span>]:</span>
<span id="cb130-9"><a href="#cb130-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Not enough tokens for the validation loader. "</span></span>
<span id="cb130-10"><a href="#cb130-10" aria-hidden="true" tabindex="-1"></a>          <span class="st">"Try to lower the `GPT_CONFIG_124M['context_length']` or "</span></span>
<span id="cb130-11"><a href="#cb130-11" aria-hidden="true" tabindex="-1"></a>          <span class="st">"decrease the `training_ratio`"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ul>
<li><p>We use a relatively small batch size to reduce the computational resource demand, and because the dataset is very small to begin with</p></li>
<li><p>Llama 2 7B was trained with a batch size of 1024, for example</p></li>
<li><p>An optional check that the data was loaded correctly:</p></li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb131"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Train loader:"</span>)</span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x, y <span class="kw">in</span> train_loader:</span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(x.shape, y.shape)</span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Validation loader:"</span>)</span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x, y <span class="kw">in</span> val_loader:</span>
<span id="cb131-7"><a href="#cb131-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(x.shape, y.shape)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>Train loader:
torch.Size([2, 256]) torch.Size([2, 256])
torch.Size([2, 256]) torch.Size([2, 256])
torch.Size([2, 256]) torch.Size([2, 256])
torch.Size([2, 256]) torch.Size([2, 256])
torch.Size([2, 256]) torch.Size([2, 256])
torch.Size([2, 256]) torch.Size([2, 256])
torch.Size([2, 256]) torch.Size([2, 256])
torch.Size([2, 256]) torch.Size([2, 256])
torch.Size([2, 256]) torch.Size([2, 256])

Validation loader:
torch.Size([2, 256]) torch.Size([2, 256])</code></pre>
<ul>
<li>Another optional check that the token sizes are in the expected ballpark:</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb133"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>train_tokens <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> input_batch, target_batch <span class="kw">in</span> train_loader:</span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>    train_tokens <span class="op">+=</span> input_batch.numel()</span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a>val_tokens <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> input_batch, target_batch <span class="kw">in</span> val_loader:</span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a>    val_tokens <span class="op">+=</span> input_batch.numel()</span>
<span id="cb133-8"><a href="#cb133-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-9"><a href="#cb133-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Training tokens:"</span>, train_tokens)</span>
<span id="cb133-10"><a href="#cb133-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Validation tokens:"</span>, val_tokens)</span>
<span id="cb133-11"><a href="#cb133-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"All tokens:"</span>, train_tokens <span class="op">+</span> val_tokens)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>Training tokens: 4608
Validation tokens: 512
All tokens: 5120</code></pre>
<ul>
<li>Next, we implement a utility function to calculate the cross-entropy loss of a given batch</li>
<li>In addition, we implement a second utility function to compute the loss for a user-specified number of batches in a data loader</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb135"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calc_loss_batch(input_batch, target_batch, model, device):</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>    input_batch, target_batch <span class="op">=</span> input_batch.to(device), target_batch.to(device)</span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>    logits <span class="op">=</span> model(input_batch)</span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a>    loss <span class="op">=</span> torch.nn.functional.cross_entropy(logits.flatten(<span class="dv">0</span>, <span class="dv">1</span>), target_batch.flatten())</span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> loss</span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-7"><a href="#cb135-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-8"><a href="#cb135-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calc_loss_loader(data_loader, model, device, num_batches<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb135-9"><a href="#cb135-9" aria-hidden="true" tabindex="-1"></a>    total_loss <span class="op">=</span> <span class="fl">0.</span></span>
<span id="cb135-10"><a href="#cb135-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(data_loader) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb135-11"><a href="#cb135-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">float</span>(<span class="st">"nan"</span>)</span>
<span id="cb135-12"><a href="#cb135-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> num_batches <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb135-13"><a href="#cb135-13" aria-hidden="true" tabindex="-1"></a>        num_batches <span class="op">=</span> <span class="bu">len</span>(data_loader)</span>
<span id="cb135-14"><a href="#cb135-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb135-15"><a href="#cb135-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Reduce the number of batches to match the total number of batches in the data loader</span></span>
<span id="cb135-16"><a href="#cb135-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># if num_batches exceeds the number of batches in the data loader</span></span>
<span id="cb135-17"><a href="#cb135-17" aria-hidden="true" tabindex="-1"></a>        num_batches <span class="op">=</span> <span class="bu">min</span>(num_batches, <span class="bu">len</span>(data_loader))</span>
<span id="cb135-18"><a href="#cb135-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (input_batch, target_batch) <span class="kw">in</span> <span class="bu">enumerate</span>(data_loader):</span>
<span id="cb135-19"><a href="#cb135-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&lt;</span> num_batches:</span>
<span id="cb135-20"><a href="#cb135-20" aria-hidden="true" tabindex="-1"></a>            loss <span class="op">=</span> calc_loss_batch(input_batch, target_batch, model, device)</span>
<span id="cb135-21"><a href="#cb135-21" aria-hidden="true" tabindex="-1"></a>            total_loss <span class="op">+=</span> loss.item()</span>
<span id="cb135-22"><a href="#cb135-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb135-23"><a href="#cb135-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb135-24"><a href="#cb135-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_loss <span class="op">/</span> num_batches</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ul>
<li>If you have a machine with a CUDA-supported GPU, the LLM will train on the GPU without making any changes to the code</li>
<li>Via the <code>device</code> setting, we ensure that the data is loaded onto the same device as the LLM model</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb136"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">"cuda"</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">"cpu"</span>)</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Note:</span></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Uncommenting the following lines will allow the code to run on Apple Silicon chips, if applicable,</span></span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a><span class="co"># which is approximately 2x faster than on an Apple CPU (as measured on an M3 MacBook Air).</span></span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a><span class="co"># However, the resulting loss values may be slightly different.</span></span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-8"><a href="#cb136-8" aria-hidden="true" tabindex="-1"></a><span class="co">#if torch.cuda.is_available():</span></span>
<span id="cb136-9"><a href="#cb136-9" aria-hidden="true" tabindex="-1"></a><span class="co">#    device = torch.device("cuda")</span></span>
<span id="cb136-10"><a href="#cb136-10" aria-hidden="true" tabindex="-1"></a><span class="co">#elif torch.backends.mps.is_available():</span></span>
<span id="cb136-11"><a href="#cb136-11" aria-hidden="true" tabindex="-1"></a><span class="co">#    device = torch.device("mps")</span></span>
<span id="cb136-12"><a href="#cb136-12" aria-hidden="true" tabindex="-1"></a><span class="co">#else:</span></span>
<span id="cb136-13"><a href="#cb136-13" aria-hidden="true" tabindex="-1"></a><span class="co">#    device = torch.device("cpu")</span></span>
<span id="cb136-14"><a href="#cb136-14" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb136-15"><a href="#cb136-15" aria-hidden="true" tabindex="-1"></a><span class="co"># print(f"Using {device} device.")</span></span>
<span id="cb136-16"><a href="#cb136-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-17"><a href="#cb136-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-18"><a href="#cb136-18" aria-hidden="true" tabindex="-1"></a>model.to(device) <span class="co"># no assignment model = model.to(device) necessary for nn.Module classes</span></span>
<span id="cb136-19"><a href="#cb136-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-20"><a href="#cb136-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-21"><a href="#cb136-21" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">123</span>) <span class="co"># For reproducibility due to the shuffling in the data loader</span></span>
<span id="cb136-22"><a href="#cb136-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-23"><a href="#cb136-23" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad(): <span class="co"># Disable gradient tracking for efficiency because we are not training, yet</span></span>
<span id="cb136-24"><a href="#cb136-24" aria-hidden="true" tabindex="-1"></a>    train_loss <span class="op">=</span> calc_loss_loader(train_loader, model, device)</span>
<span id="cb136-25"><a href="#cb136-25" aria-hidden="true" tabindex="-1"></a>    val_loss <span class="op">=</span> calc_loss_loader(val_loader, model, device)</span>
<span id="cb136-26"><a href="#cb136-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-27"><a href="#cb136-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Training loss:"</span>, train_loss)</span>
<span id="cb136-28"><a href="#cb136-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Validation loss:"</span>, val_loss)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>Training loss: 10.98758347829183
Validation loss: 10.98110580444336</code></pre>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch05_compressed/mental-model-1.webp" width="400px"></p>
</section>
</section>
<section id="training-an-llm" class="level2">
<h2 class="anchored" data-anchor-id="training-an-llm">5.2 Training an LLM</h2>
<ul>
<li>In this section, we finally implement the code for training the LLM</li>
<li>We focus on a simple training function (if you are interested in augmenting this training function with more advanced techniques, such as learning rate warmup, cosine annealing, and gradient clipping, please refer to <a href="../../appendix-D/01_main-chapter-code">Appendix D</a>)</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch05_compressed/train-steps.webp" width="300px"></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb138"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> train_model_simple(model, train_loader, val_loader, optimizer, device, num_epochs,</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>                       eval_freq, eval_iter, start_context, tokenizer):</span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize lists to track losses and tokens seen</span></span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a>    train_losses, val_losses, track_tokens_seen <span class="op">=</span> [], [], []</span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a>    tokens_seen, global_step <span class="op">=</span> <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span></span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Main training loop</span></span>
<span id="cb138-8"><a href="#cb138-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(num_epochs):</span>
<span id="cb138-9"><a href="#cb138-9" aria-hidden="true" tabindex="-1"></a>        model.train()  <span class="co"># Set model to training mode</span></span>
<span id="cb138-10"><a href="#cb138-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb138-11"><a href="#cb138-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> input_batch, target_batch <span class="kw">in</span> train_loader:</span>
<span id="cb138-12"><a href="#cb138-12" aria-hidden="true" tabindex="-1"></a>            optimizer.zero_grad() <span class="co"># Reset loss gradients from previous batch iteration</span></span>
<span id="cb138-13"><a href="#cb138-13" aria-hidden="true" tabindex="-1"></a>            loss <span class="op">=</span> calc_loss_batch(input_batch, target_batch, model, device)</span>
<span id="cb138-14"><a href="#cb138-14" aria-hidden="true" tabindex="-1"></a>            loss.backward() <span class="co"># Calculate loss gradients</span></span>
<span id="cb138-15"><a href="#cb138-15" aria-hidden="true" tabindex="-1"></a>            optimizer.step() <span class="co"># Update model weights using loss gradients</span></span>
<span id="cb138-16"><a href="#cb138-16" aria-hidden="true" tabindex="-1"></a>            tokens_seen <span class="op">+=</span> input_batch.numel()</span>
<span id="cb138-17"><a href="#cb138-17" aria-hidden="true" tabindex="-1"></a>            global_step <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb138-18"><a href="#cb138-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-19"><a href="#cb138-19" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Optional evaluation step</span></span>
<span id="cb138-20"><a href="#cb138-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> global_step <span class="op">%</span> eval_freq <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb138-21"><a href="#cb138-21" aria-hidden="true" tabindex="-1"></a>                train_loss, val_loss <span class="op">=</span> evaluate_model(</span>
<span id="cb138-22"><a href="#cb138-22" aria-hidden="true" tabindex="-1"></a>                    model, train_loader, val_loader, device, eval_iter)</span>
<span id="cb138-23"><a href="#cb138-23" aria-hidden="true" tabindex="-1"></a>                train_losses.append(train_loss)</span>
<span id="cb138-24"><a href="#cb138-24" aria-hidden="true" tabindex="-1"></a>                val_losses.append(val_loss)</span>
<span id="cb138-25"><a href="#cb138-25" aria-hidden="true" tabindex="-1"></a>                track_tokens_seen.append(tokens_seen)</span>
<span id="cb138-26"><a href="#cb138-26" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f"Ep </span><span class="sc">{</span>epoch<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> (Step </span><span class="sc">{</span>global_step<span class="sc">:06d}</span><span class="ss">): "</span></span>
<span id="cb138-27"><a href="#cb138-27" aria-hidden="true" tabindex="-1"></a>                      <span class="ss">f"Train loss </span><span class="sc">{</span>train_loss<span class="sc">:.3f}</span><span class="ss">, Val loss </span><span class="sc">{</span>val_loss<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb138-28"><a href="#cb138-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-29"><a href="#cb138-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Print a sample text after each epoch</span></span>
<span id="cb138-30"><a href="#cb138-30" aria-hidden="true" tabindex="-1"></a>        generate_and_print_sample(</span>
<span id="cb138-31"><a href="#cb138-31" aria-hidden="true" tabindex="-1"></a>            model, tokenizer, device, start_context</span>
<span id="cb138-32"><a href="#cb138-32" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb138-33"><a href="#cb138-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-34"><a href="#cb138-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> train_losses, val_losses, track_tokens_seen</span>
<span id="cb138-35"><a href="#cb138-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-36"><a href="#cb138-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-37"><a href="#cb138-37" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate_model(model, train_loader, val_loader, device, eval_iter):</span>
<span id="cb138-38"><a href="#cb138-38" aria-hidden="true" tabindex="-1"></a>    model.<span class="bu">eval</span>()</span>
<span id="cb138-39"><a href="#cb138-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> torch.no_grad():</span>
<span id="cb138-40"><a href="#cb138-40" aria-hidden="true" tabindex="-1"></a>        train_loss <span class="op">=</span> calc_loss_loader(train_loader, model, device, num_batches<span class="op">=</span>eval_iter)</span>
<span id="cb138-41"><a href="#cb138-41" aria-hidden="true" tabindex="-1"></a>        val_loss <span class="op">=</span> calc_loss_loader(val_loader, model, device, num_batches<span class="op">=</span>eval_iter)</span>
<span id="cb138-42"><a href="#cb138-42" aria-hidden="true" tabindex="-1"></a>    model.train()</span>
<span id="cb138-43"><a href="#cb138-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> train_loss, val_loss</span>
<span id="cb138-44"><a href="#cb138-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-45"><a href="#cb138-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-46"><a href="#cb138-46" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_and_print_sample(model, tokenizer, device, start_context):</span>
<span id="cb138-47"><a href="#cb138-47" aria-hidden="true" tabindex="-1"></a>    model.<span class="bu">eval</span>()</span>
<span id="cb138-48"><a href="#cb138-48" aria-hidden="true" tabindex="-1"></a>    context_size <span class="op">=</span> model.pos_emb.weight.shape[<span class="dv">0</span>]</span>
<span id="cb138-49"><a href="#cb138-49" aria-hidden="true" tabindex="-1"></a>    encoded <span class="op">=</span> text_to_token_ids(start_context, tokenizer).to(device)</span>
<span id="cb138-50"><a href="#cb138-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> torch.no_grad():</span>
<span id="cb138-51"><a href="#cb138-51" aria-hidden="true" tabindex="-1"></a>        token_ids <span class="op">=</span> generate_text_simple(</span>
<span id="cb138-52"><a href="#cb138-52" aria-hidden="true" tabindex="-1"></a>            model<span class="op">=</span>model, idx<span class="op">=</span>encoded,</span>
<span id="cb138-53"><a href="#cb138-53" aria-hidden="true" tabindex="-1"></a>            max_new_tokens<span class="op">=</span><span class="dv">50</span>, context_size<span class="op">=</span>context_size</span>
<span id="cb138-54"><a href="#cb138-54" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb138-55"><a href="#cb138-55" aria-hidden="true" tabindex="-1"></a>    decoded_text <span class="op">=</span> token_ids_to_text(token_ids, tokenizer)</span>
<span id="cb138-56"><a href="#cb138-56" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(decoded_text.replace(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>, <span class="st">" "</span>))  <span class="co"># Compact print format</span></span>
<span id="cb138-57"><a href="#cb138-57" aria-hidden="true" tabindex="-1"></a>    model.train()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ul>
<li>Now, let’s train the LLM using the training function defined above:</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb139"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Note:</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Uncomment the following code to calculate the execution time</span></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a><span class="co"># import time</span></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a><span class="co"># start_time = time.time()</span></span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">123</span>)</span>
<span id="cb139-7"><a href="#cb139-7" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> GPTModel(GPT_CONFIG_124M)</span>
<span id="cb139-8"><a href="#cb139-8" aria-hidden="true" tabindex="-1"></a>model.to(device)</span>
<span id="cb139-9"><a href="#cb139-9" aria-hidden="true" tabindex="-1"></a>optimizer <span class="op">=</span> torch.optim.AdamW(model.parameters(), lr<span class="op">=</span><span class="fl">0.0004</span>, weight_decay<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb139-10"><a href="#cb139-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-11"><a href="#cb139-11" aria-hidden="true" tabindex="-1"></a>num_epochs <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb139-12"><a href="#cb139-12" aria-hidden="true" tabindex="-1"></a>train_losses, val_losses, tokens_seen <span class="op">=</span> train_model_simple(</span>
<span id="cb139-13"><a href="#cb139-13" aria-hidden="true" tabindex="-1"></a>    model, train_loader, val_loader, optimizer, device,</span>
<span id="cb139-14"><a href="#cb139-14" aria-hidden="true" tabindex="-1"></a>    num_epochs<span class="op">=</span>num_epochs, eval_freq<span class="op">=</span><span class="dv">5</span>, eval_iter<span class="op">=</span><span class="dv">5</span>,</span>
<span id="cb139-15"><a href="#cb139-15" aria-hidden="true" tabindex="-1"></a>    start_context<span class="op">=</span><span class="st">"Every effort moves you"</span>, tokenizer<span class="op">=</span>tokenizer</span>
<span id="cb139-16"><a href="#cb139-16" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb139-17"><a href="#cb139-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-18"><a href="#cb139-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Note:</span></span>
<span id="cb139-19"><a href="#cb139-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Uncomment the following code to show the execution time</span></span>
<span id="cb139-20"><a href="#cb139-20" aria-hidden="true" tabindex="-1"></a><span class="co"># end_time = time.time()</span></span>
<span id="cb139-21"><a href="#cb139-21" aria-hidden="true" tabindex="-1"></a><span class="co"># execution_time_minutes = (end_time - start_time) / 60</span></span>
<span id="cb139-22"><a href="#cb139-22" aria-hidden="true" tabindex="-1"></a><span class="co"># print(f"Training completed in {execution_time_minutes:.2f} minutes.")</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>Ep 1 (Step 000000): Train loss 9.781, Val loss 9.933
Ep 1 (Step 000005): Train loss 8.111, Val loss 8.339
Every effort moves you,,,,,,,,,,,,.                                     
Ep 2 (Step 000010): Train loss 6.661, Val loss 7.048
Ep 2 (Step 000015): Train loss 5.961, Val loss 6.616
Every effort moves you, and, and, and, and, and, and, and, and, and, and, and, and, and, and, and, and, and, and, and, and, and, and,, and, and,
Ep 3 (Step 000020): Train loss 5.726, Val loss 6.600
Ep 3 (Step 000025): Train loss 5.201, Val loss 6.348
Every effort moves you, and I had been.                                            
Ep 4 (Step 000030): Train loss 4.417, Val loss 6.278
Ep 4 (Step 000035): Train loss 4.069, Val loss 6.226
Every effort moves you know the                          "I he had the donkey and I had the and I had the donkey and down the room, I had
Ep 5 (Step 000040): Train loss 3.732, Val loss 6.160
Every effort moves you know it was not that the picture--I had the fact by the last I had been--his, and in the            "Oh, and he said, and down the room, and in
Ep 6 (Step 000045): Train loss 2.850, Val loss 6.179
Ep 6 (Step 000050): Train loss 2.427, Val loss 6.141
Every effort moves you know," was one of the picture. The--I had a little of a little: "Yes, and in fact, and in the picture was, and I had been at my elbow and as his pictures, and down the room, I had
Ep 7 (Step 000055): Train loss 2.104, Val loss 6.134
Ep 7 (Step 000060): Train loss 1.882, Val loss 6.233
Every effort moves you know," was one of the picture for nothing--I told Mrs.  "I was no--as! The women had been, in the moment--as Jack himself, as once one had been the donkey, and were, and in his
Ep 8 (Step 000065): Train loss 1.320, Val loss 6.238
Ep 8 (Step 000070): Train loss 0.985, Val loss 6.242
Every effort moves you know," was one of the axioms he had been the tips of a self-confident moustache, I felt to see a smile behind his close grayish beard--as if he had the donkey. "strongest," as his
Ep 9 (Step 000075): Train loss 0.717, Val loss 6.293
Ep 9 (Step 000080): Train loss 0.541, Val loss 6.393
Every effort moves you?"  "Yes--quite insensible to the irony. She wanted him vindicated--and by me!"  He laughed again, and threw back the window-curtains, I had the donkey. "There were days when I
Ep 10 (Step 000085): Train loss 0.391, Val loss 6.452
Every effort moves you know," was one of the axioms he laid down across the Sevres and silver of an exquisitely appointed luncheon-table, when, on a later day, I had again run over from Monte Carlo; and Mrs. Gis</code></pre>
<ul>
<li>Note that you might get slightly different loss values on your computer, which is not a reason for concern if they are roughly similar (a training loss below 1 and a validation loss below 7)</li>
<li>Small differences can often be due to different GPU hardware and CUDA versions or small changes in newer PyTorch versions</li>
<li>Even if you are running the example on a CPU, you may observe slight differences; a possible reason for a discrepancy is the differing behavior of <code>nn.Dropout</code> across operating systems, depending on how PyTorch was compiled, as discussed <a href="https://github.com/pytorch/pytorch/issues/121595">here on the PyTorch issue tracker</a></li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb141"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.ticker <span class="im">import</span> MaxNLocator</span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_losses(epochs_seen, tokens_seen, train_losses, val_losses):</span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a>    fig, ax1 <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">3</span>))</span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot training and validation loss against epochs</span></span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a>    ax1.plot(epochs_seen, train_losses, label<span class="op">=</span><span class="st">"Training loss"</span>)</span>
<span id="cb141-10"><a href="#cb141-10" aria-hidden="true" tabindex="-1"></a>    ax1.plot(epochs_seen, val_losses, linestyle<span class="op">=</span><span class="st">"-."</span>, label<span class="op">=</span><span class="st">"Validation loss"</span>)</span>
<span id="cb141-11"><a href="#cb141-11" aria-hidden="true" tabindex="-1"></a>    ax1.set_xlabel(<span class="st">"Epochs"</span>)</span>
<span id="cb141-12"><a href="#cb141-12" aria-hidden="true" tabindex="-1"></a>    ax1.set_ylabel(<span class="st">"Loss"</span>)</span>
<span id="cb141-13"><a href="#cb141-13" aria-hidden="true" tabindex="-1"></a>    ax1.legend(loc<span class="op">=</span><span class="st">"upper right"</span>)</span>
<span id="cb141-14"><a href="#cb141-14" aria-hidden="true" tabindex="-1"></a>    ax1.xaxis.set_major_locator(MaxNLocator(integer<span class="op">=</span><span class="va">True</span>))  <span class="co"># only show integer labels on x-axis</span></span>
<span id="cb141-15"><a href="#cb141-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-16"><a href="#cb141-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a second x-axis for tokens seen</span></span>
<span id="cb141-17"><a href="#cb141-17" aria-hidden="true" tabindex="-1"></a>    ax2 <span class="op">=</span> ax1.twiny()  <span class="co"># Create a second x-axis that shares the same y-axis</span></span>
<span id="cb141-18"><a href="#cb141-18" aria-hidden="true" tabindex="-1"></a>    ax2.plot(tokens_seen, train_losses, alpha<span class="op">=</span><span class="dv">0</span>)  <span class="co"># Invisible plot for aligning ticks</span></span>
<span id="cb141-19"><a href="#cb141-19" aria-hidden="true" tabindex="-1"></a>    ax2.set_xlabel(<span class="st">"Tokens seen"</span>)</span>
<span id="cb141-20"><a href="#cb141-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-21"><a href="#cb141-21" aria-hidden="true" tabindex="-1"></a>    fig.tight_layout()  <span class="co"># Adjust layout to make room</span></span>
<span id="cb141-22"><a href="#cb141-22" aria-hidden="true" tabindex="-1"></a>    plt.savefig(<span class="st">"loss-plot.pdf"</span>)</span>
<span id="cb141-23"><a href="#cb141-23" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb141-24"><a href="#cb141-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-25"><a href="#cb141-25" aria-hidden="true" tabindex="-1"></a>epochs_tensor <span class="op">=</span> torch.linspace(<span class="dv">0</span>, num_epochs, <span class="bu">len</span>(train_losses))</span>
<span id="cb141-26"><a href="#cb141-26" aria-hidden="true" tabindex="-1"></a>plot_losses(epochs_tensor, tokens_seen, train_losses, val_losses)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="ch05_files/ch05_79_0.png" class="img-fluid figure-img"></p>
<figcaption>png</figcaption>
</figure>
</div>
<ul>
<li>Looking at the results above, we can see that the model starts out generating incomprehensible strings of words, whereas towards the end, it’s able to produce grammatically more or less correct sentences</li>
<li>However, based on the training and validation set losses, we can see that the model starts overfitting</li>
<li>If we were to check a few passages it writes towards the end, we would find that they are contained in the training set verbatim – it simply memorizes the training data</li>
<li>Later, we will cover decoding strategies that can mitigate this memorization by a certain degree</li>
<li>Note that the overfitting here occurs because we have a very, very small training set, and we iterate over it so many times
<ul>
<li>The LLM training here primarily serves educational purposes; we mainly want to see that the model can learn to produce coherent text</li>
<li>Instead of spending weeks or months on training this model on vast amounts of expensive hardware, we load pretrained weights later</li>
</ul></li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch05_compressed/mental-model-2.webp" width="350px"></p>
<p><strong>If you are interested in augmenting this training function with more advanced techniques, such as learning rate warmup, cosine annealing, and gradient clipping, please refer to <a href="../../appendix-D/01_main-chapter-code">Appendix D</a></strong></p>
<p><strong>If you are interested in a larger training dataset and longer training run, see <a href="../03_bonus_pretraining_on_gutenberg">../03_bonus_pretraining_on_gutenberg</a></strong></p>
</section>
<section id="decoding-strategies-to-control-randomness" class="level2">
<h2 class="anchored" data-anchor-id="decoding-strategies-to-control-randomness">5.3 Decoding strategies to control randomness</h2>
<ul>
<li>Inference is relatively cheap with a relatively small LLM as the GPT model we trained above, so there’s no need to use a GPU for it in case you used a GPU for training it above</li>
<li>Using the <code>generate_text_simple</code> function (from the previous chapter) that we used earlier inside the simple training function, we can generate new text one word (or token) at a time</li>
<li>As explained in section 5.1.2, the next generated token is the token corresponding to the largest probability score among all tokens in the vocabulary</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb142"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a>model.to(<span class="st">"cpu"</span>)</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>model.<span class="bu">eval</span>()</span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a>tokenizer <span class="op">=</span> tiktoken.get_encoding(<span class="st">"gpt2"</span>)</span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-6"><a href="#cb142-6" aria-hidden="true" tabindex="-1"></a>token_ids <span class="op">=</span> generate_text_simple(</span>
<span id="cb142-7"><a href="#cb142-7" aria-hidden="true" tabindex="-1"></a>    model<span class="op">=</span>model,</span>
<span id="cb142-8"><a href="#cb142-8" aria-hidden="true" tabindex="-1"></a>    idx<span class="op">=</span>text_to_token_ids(<span class="st">"Every effort moves you"</span>, tokenizer),</span>
<span id="cb142-9"><a href="#cb142-9" aria-hidden="true" tabindex="-1"></a>    max_new_tokens<span class="op">=</span><span class="dv">25</span>,</span>
<span id="cb142-10"><a href="#cb142-10" aria-hidden="true" tabindex="-1"></a>    context_size<span class="op">=</span>GPT_CONFIG_124M[<span class="st">"context_length"</span>]</span>
<span id="cb142-11"><a href="#cb142-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb142-12"><a href="#cb142-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-13"><a href="#cb142-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Output text:</span><span class="ch">\n</span><span class="st">"</span>, token_ids_to_text(token_ids, tokenizer))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>Output text:
 Every effort moves you know," was one of the axioms he laid down across the Sevres and silver of an exquisitely appointed lun</code></pre>
<ul>
<li>Even if we execute the <code>generate_text_simple</code> function above multiple times, the LLM will always generate the same outputs</li>
<li>We now introduce two concepts, so-called decoding strategies, to modify the <code>generate_text_simple</code>: <em>temperature scaling</em> and <em>top-k</em> sampling</li>
<li>These will allow the model to control the randomness and diversity of the generated text</li>
</ul>
<section id="temperature-scaling" class="level3">
<h3 class="anchored" data-anchor-id="temperature-scaling">5.3.1 Temperature scaling</h3>
<ul>
<li><p>Previously, we always sampled the token with the highest probability as the next token using <code>torch.argmax</code></p></li>
<li><p>To add variety, we can sample the next token using The <code>torch.multinomial(probs, num_samples=1)</code>, sampling from a probability distribution</p></li>
<li><p>Here, each index’s chance of being picked corresponds to its probability in the input tensor</p></li>
<li><p>Here’s a little recap of generating the next token, assuming a very small vocabulary for illustration purposes:</p></li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb144"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a>vocab <span class="op">=</span> { </span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"closer"</span>: <span class="dv">0</span>,</span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"every"</span>: <span class="dv">1</span>, </span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"effort"</span>: <span class="dv">2</span>, </span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"forward"</span>: <span class="dv">3</span>,</span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"inches"</span>: <span class="dv">4</span>,</span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"moves"</span>: <span class="dv">5</span>, </span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">"pizza"</span>: <span class="dv">6</span>,</span>
<span id="cb144-9"><a href="#cb144-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">"toward"</span>: <span class="dv">7</span>,</span>
<span id="cb144-10"><a href="#cb144-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">"you"</span>: <span class="dv">8</span>,</span>
<span id="cb144-11"><a href="#cb144-11" aria-hidden="true" tabindex="-1"></a>} </span>
<span id="cb144-12"><a href="#cb144-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-13"><a href="#cb144-13" aria-hidden="true" tabindex="-1"></a>inverse_vocab <span class="op">=</span> {v: k <span class="cf">for</span> k, v <span class="kw">in</span> vocab.items()}</span>
<span id="cb144-14"><a href="#cb144-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-15"><a href="#cb144-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Suppose input is "every effort moves you", and the LLM</span></span>
<span id="cb144-16"><a href="#cb144-16" aria-hidden="true" tabindex="-1"></a><span class="co"># returns the following logits for the next token:</span></span>
<span id="cb144-17"><a href="#cb144-17" aria-hidden="true" tabindex="-1"></a>next_token_logits <span class="op">=</span> torch.tensor(</span>
<span id="cb144-18"><a href="#cb144-18" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">4.51</span>, <span class="fl">0.89</span>, <span class="op">-</span><span class="fl">1.90</span>, <span class="fl">6.75</span>, <span class="fl">1.63</span>, <span class="op">-</span><span class="fl">1.62</span>, <span class="op">-</span><span class="fl">1.89</span>, <span class="fl">6.28</span>, <span class="fl">1.79</span>]</span>
<span id="cb144-19"><a href="#cb144-19" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb144-20"><a href="#cb144-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-21"><a href="#cb144-21" aria-hidden="true" tabindex="-1"></a>probas <span class="op">=</span> torch.softmax(next_token_logits, dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb144-22"><a href="#cb144-22" aria-hidden="true" tabindex="-1"></a>next_token_id <span class="op">=</span> torch.argmax(probas).item()</span>
<span id="cb144-23"><a href="#cb144-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-24"><a href="#cb144-24" aria-hidden="true" tabindex="-1"></a><span class="co"># The next generated token is then as follows:</span></span>
<span id="cb144-25"><a href="#cb144-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(inverse_vocab[next_token_id])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>forward</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb146"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">123</span>)</span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>next_token_id <span class="op">=</span> torch.multinomial(probas, num_samples<span class="op">=</span><span class="dv">1</span>).item()</span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(inverse_vocab[next_token_id])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>forward</code></pre>
<ul>
<li>Instead of determining the most likely token via <code>torch.argmax</code>, we use <code>torch.multinomial(probas, num_samples=1)</code> to determine the most likely token by sampling from the softmax distribution</li>
<li>For illustration purposes, let’s see what happens when we sample the next token 1,000 times using the original softmax probabilities:</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb148"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> print_sampled_tokens(probas):</span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a>    torch.manual_seed(<span class="dv">123</span>) <span class="co"># Manual seed for reproducibility</span></span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a>    sample <span class="op">=</span> [torch.multinomial(probas, num_samples<span class="op">=</span><span class="dv">1</span>).item() <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1_000</span>)]</span>
<span id="cb148-4"><a href="#cb148-4" aria-hidden="true" tabindex="-1"></a>    sampled_ids <span class="op">=</span> torch.bincount(torch.tensor(sample), minlength<span class="op">=</span><span class="bu">len</span>(probas))</span>
<span id="cb148-5"><a href="#cb148-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, freq <span class="kw">in</span> <span class="bu">enumerate</span>(sampled_ids):</span>
<span id="cb148-6"><a href="#cb148-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>freq<span class="sc">}</span><span class="ss"> x </span><span class="sc">{</span>inverse_vocab[i]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb148-7"><a href="#cb148-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-8"><a href="#cb148-8" aria-hidden="true" tabindex="-1"></a>print_sampled_tokens(probas)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>73 x closer
0 x every
0 x effort
582 x forward
2 x inches
0 x moves
0 x pizza
343 x toward
0 x you</code></pre>
<ul>
<li><p>We can control the distribution and selection process via a concept called temperature scaling</p></li>
<li><p>“Temperature scaling” is just a fancy word for dividing the logits by a number greater than 0</p></li>
<li><p>Temperatures greater than 1 will result in more uniformly distributed token probabilities after applying the softmax</p></li>
<li><p>Temperatures smaller than 1 will result in more confident (sharper or more peaky) distributions after applying the softmax</p></li>
<li><p>Note that the resulting dropout outputs may look different depending on your operating system; you can read more about this inconsistency <a href="https://github.com/pytorch/pytorch/issues/121595">here on the PyTorch issue tracker</a></p></li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb150"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> softmax_with_temperature(logits, temperature):</span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>    scaled_logits <span class="op">=</span> logits <span class="op">/</span> temperature</span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> torch.softmax(scaled_logits, dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Temperature values</span></span>
<span id="cb150-6"><a href="#cb150-6" aria-hidden="true" tabindex="-1"></a>temperatures <span class="op">=</span> [<span class="dv">1</span>, <span class="fl">0.1</span>, <span class="dv">5</span>]  <span class="co"># Original, higher confidence, and lower confidence</span></span>
<span id="cb150-7"><a href="#cb150-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-8"><a href="#cb150-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate scaled probabilities</span></span>
<span id="cb150-9"><a href="#cb150-9" aria-hidden="true" tabindex="-1"></a>scaled_probas <span class="op">=</span> [softmax_with_temperature(next_token_logits, T) <span class="cf">for</span> T <span class="kw">in</span> temperatures]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb151"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> torch.arange(<span class="bu">len</span>(vocab))</span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a>bar_width <span class="op">=</span> <span class="fl">0.15</span></span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">3</span>))</span>
<span id="cb151-6"><a href="#cb151-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, T <span class="kw">in</span> <span class="bu">enumerate</span>(temperatures):</span>
<span id="cb151-7"><a href="#cb151-7" aria-hidden="true" tabindex="-1"></a>    rects <span class="op">=</span> ax.bar(x <span class="op">+</span> i <span class="op">*</span> bar_width, scaled_probas[i], bar_width, label<span class="op">=</span><span class="ss">f'Temperature = </span><span class="sc">{</span>T<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb151-8"><a href="#cb151-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-9"><a href="#cb151-9" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Probability'</span>)</span>
<span id="cb151-10"><a href="#cb151-10" aria-hidden="true" tabindex="-1"></a>ax.set_xticks(x)</span>
<span id="cb151-11"><a href="#cb151-11" aria-hidden="true" tabindex="-1"></a>ax.set_xticklabels(vocab.keys(), rotation<span class="op">=</span><span class="dv">90</span>)</span>
<span id="cb151-12"><a href="#cb151-12" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb151-13"><a href="#cb151-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-14"><a href="#cb151-14" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb151-15"><a href="#cb151-15" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">"temperature-plot.pdf"</span>)</span>
<span id="cb151-16"><a href="#cb151-16" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="ch05_files/ch05_98_0.png" class="img-fluid figure-img"></p>
<figcaption>png</figcaption>
</figure>
</div>
<ul>
<li>We can see that the rescaling via temperature 0.1 results in a sharper distribution, approaching <code>torch.argmax</code>, such that the most likely word is almost always selected:</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb152"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a>print_sampled_tokens(scaled_probas[<span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>0 x closer
0 x every
0 x effort
985 x forward
0 x inches
0 x moves
0 x pizza
15 x toward
0 x you</code></pre>
<ul>
<li>The rescaled probabilities via temperature 5 are more uniformly distributed:</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb154"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a>print_sampled_tokens(scaled_probas[<span class="dv">2</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>165 x closer
75 x every
42 x effort
239 x forward
71 x inches
46 x moves
32 x pizza
227 x toward
103 x you</code></pre>
<ul>
<li>Assuming an LLM input “every effort moves you”, using the approach above can sometimes result in nonsensical texts, such as “every effort moves you pizza”, 3.2% of the time (32 out of 1000 times)</li>
</ul>
</section>
<section id="top-k-sampling" class="level3">
<h3 class="anchored" data-anchor-id="top-k-sampling">5.3.2 Top-k sampling</h3>
<ul>
<li>To be able to use higher temperatures to increase output diversity and to reduce the probability of nonsensical sentences, we can restrict the sampled tokens to the top-k most likely tokens:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch05_compressed/topk.webp" width="500px"></p>
<ul>
<li><p>(Please note that the numbers in this figure are truncated to two digits after the decimal point to reduce visual clutter. The values in the Softmax row should add up to 1.0.)</p></li>
<li><p>In code, we can implement this as follows:</p></li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb156"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a>top_k <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a>top_logits, top_pos <span class="op">=</span> torch.topk(next_token_logits, top_k)</span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Top logits:"</span>, top_logits)</span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Top positions:"</span>, top_pos)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>Top logits: tensor([6.7500, 6.2800, 4.5100])
Top positions: tensor([3, 7, 0])</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb158"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a>new_logits <span class="op">=</span> torch.where(</span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a>    condition<span class="op">=</span>next_token_logits <span class="op">&lt;</span> top_logits[<span class="op">-</span><span class="dv">1</span>],</span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">input</span><span class="op">=</span>torch.tensor(<span class="bu">float</span>(<span class="st">"-inf"</span>)), </span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a>    other<span class="op">=</span>next_token_logits</span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb158-6"><a href="#cb158-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-7"><a href="#cb158-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(new_logits)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>tensor([4.5100,   -inf,   -inf, 6.7500,   -inf,   -inf,   -inf, 6.2800,   -inf])</code></pre>
<blockquote class="blockquote">
<p>NOTE:</p>
<p>An alternative, slightly more efficient implementation of the previous code cell is the following:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb160"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a>new_logits <span class="op">=</span> torch.full_like( <span class="co"># create tensor containing -inf values</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a>   next_token_logits, <span class="op">-</span>torch.inf</span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a>)   </span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a>new_logits[top_pos] <span class="op">=</span> next_token_logits[top_pos] <span class="co"># copy top k values into the -inf tensor</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><br> For more details, see https://github.com/rasbt/LLMs-from-scratch/discussions/326</p>
</blockquote>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb161"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a>topk_probas <span class="op">=</span> torch.softmax(new_logits, dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(topk_probas)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>tensor([0.0615, 0.0000, 0.0000, 0.5775, 0.0000, 0.0000, 0.0000, 0.3610, 0.0000])</code></pre>
</section>
<section id="modifying-the-text-generation-function" class="level3">
<h3 class="anchored" data-anchor-id="modifying-the-text-generation-function">5.3.3 Modifying the text generation function</h3>
<ul>
<li>The previous two subsections introduced temperature sampling and top-k sampling</li>
<li>Let’s use these two concepts to modify the <code>generate_simple</code> function we used to generate text via the LLM earlier, creating a new <code>generate</code> function:</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb163"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate(model, idx, max_new_tokens, context_size, temperature<span class="op">=</span><span class="fl">0.0</span>, top_k<span class="op">=</span><span class="va">None</span>, eos_id<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># For-loop is the same as before: Get logits, and only focus on last time step</span></span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_new_tokens):</span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a>        idx_cond <span class="op">=</span> idx[:, <span class="op">-</span>context_size:]</span>
<span id="cb163-6"><a href="#cb163-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> torch.no_grad():</span>
<span id="cb163-7"><a href="#cb163-7" aria-hidden="true" tabindex="-1"></a>            logits <span class="op">=</span> model(idx_cond)</span>
<span id="cb163-8"><a href="#cb163-8" aria-hidden="true" tabindex="-1"></a>        logits <span class="op">=</span> logits[:, <span class="op">-</span><span class="dv">1</span>, :]</span>
<span id="cb163-9"><a href="#cb163-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-10"><a href="#cb163-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># New: Filter logits with top_k sampling</span></span>
<span id="cb163-11"><a href="#cb163-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> top_k <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb163-12"><a href="#cb163-12" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Keep only top_k values</span></span>
<span id="cb163-13"><a href="#cb163-13" aria-hidden="true" tabindex="-1"></a>            top_logits, _ <span class="op">=</span> torch.topk(logits, top_k)</span>
<span id="cb163-14"><a href="#cb163-14" aria-hidden="true" tabindex="-1"></a>            min_val <span class="op">=</span> top_logits[:, <span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb163-15"><a href="#cb163-15" aria-hidden="true" tabindex="-1"></a>            logits <span class="op">=</span> torch.where(logits <span class="op">&lt;</span> min_val, torch.tensor(<span class="bu">float</span>(<span class="st">"-inf"</span>)).to(logits.device), logits)</span>
<span id="cb163-16"><a href="#cb163-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-17"><a href="#cb163-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># New: Apply temperature scaling</span></span>
<span id="cb163-18"><a href="#cb163-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> temperature <span class="op">&gt;</span> <span class="fl">0.0</span>:</span>
<span id="cb163-19"><a href="#cb163-19" aria-hidden="true" tabindex="-1"></a>            logits <span class="op">=</span> logits <span class="op">/</span> temperature</span>
<span id="cb163-20"><a href="#cb163-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-21"><a href="#cb163-21" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Apply softmax to get probabilities</span></span>
<span id="cb163-22"><a href="#cb163-22" aria-hidden="true" tabindex="-1"></a>            probs <span class="op">=</span> torch.softmax(logits, dim<span class="op">=-</span><span class="dv">1</span>)  <span class="co"># (batch_size, context_len)</span></span>
<span id="cb163-23"><a href="#cb163-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-24"><a href="#cb163-24" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Sample from the distribution</span></span>
<span id="cb163-25"><a href="#cb163-25" aria-hidden="true" tabindex="-1"></a>            idx_next <span class="op">=</span> torch.multinomial(probs, num_samples<span class="op">=</span><span class="dv">1</span>)  <span class="co"># (batch_size, 1)</span></span>
<span id="cb163-26"><a href="#cb163-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-27"><a href="#cb163-27" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Otherwise same as before: get idx of the vocab entry with the highest logits value</span></span>
<span id="cb163-28"><a href="#cb163-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb163-29"><a href="#cb163-29" aria-hidden="true" tabindex="-1"></a>            idx_next <span class="op">=</span> torch.argmax(logits, dim<span class="op">=-</span><span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>)  <span class="co"># (batch_size, 1)</span></span>
<span id="cb163-30"><a href="#cb163-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-31"><a href="#cb163-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> idx_next <span class="op">==</span> eos_id:  <span class="co"># Stop generating early if end-of-sequence token is encountered and eos_id is specified</span></span>
<span id="cb163-32"><a href="#cb163-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb163-33"><a href="#cb163-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-34"><a href="#cb163-34" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Same as before: append sampled index to the running sequence</span></span>
<span id="cb163-35"><a href="#cb163-35" aria-hidden="true" tabindex="-1"></a>        idx <span class="op">=</span> torch.cat((idx, idx_next), dim<span class="op">=</span><span class="dv">1</span>)  <span class="co"># (batch_size, num_tokens+1)</span></span>
<span id="cb163-36"><a href="#cb163-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-37"><a href="#cb163-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> idx</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb164"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">123</span>)</span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a>token_ids <span class="op">=</span> generate(</span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a>    model<span class="op">=</span>model,</span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a>    idx<span class="op">=</span>text_to_token_ids(<span class="st">"Every effort moves you"</span>, tokenizer),</span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a>    max_new_tokens<span class="op">=</span><span class="dv">15</span>,</span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a>    context_size<span class="op">=</span>GPT_CONFIG_124M[<span class="st">"context_length"</span>],</span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true" tabindex="-1"></a>    top_k<span class="op">=</span><span class="dv">25</span>,</span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true" tabindex="-1"></a>    temperature<span class="op">=</span><span class="fl">1.4</span></span>
<span id="cb164-10"><a href="#cb164-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb164-11"><a href="#cb164-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-12"><a href="#cb164-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Output text:</span><span class="ch">\n</span><span class="st">"</span>, token_ids_to_text(token_ids, tokenizer))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>Output text:
 Every effort moves you stand to work on surprise, a one of us had gone with random-</code></pre>
</section>
</section>
<section id="loading-and-saving-model-weights-in-pytorch" class="level2">
<h2 class="anchored" data-anchor-id="loading-and-saving-model-weights-in-pytorch">5.4 Loading and saving model weights in PyTorch</h2>
<ul>
<li>Training LLMs is computationally expensive, so it’s crucial to be able to save and load LLM weights</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch05_compressed/mental-model-3.webp" width="400px"></p>
<ul>
<li>The recommended way in PyTorch is to save the model weights, the so-called <code>state_dict</code> via by applying the <code>torch.save</code> function to the <code>.state_dict()</code> method:</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb166"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a>torch.save(model.state_dict(), <span class="st">"model.pth"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ul>
<li>Then we can load the model weights into a new <code>GPTModel</code> model instance as follows:</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb167"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> GPTModel(GPT_CONFIG_124M)</span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">"cuda"</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">"cpu"</span>)</span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a>model.load_state_dict(torch.load(<span class="st">"model.pth"</span>, map_location<span class="op">=</span>device, weights_only<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a>model.<span class="bu">eval</span>()<span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ul>
<li>It’s common to train LLMs with adaptive optimizers like Adam or AdamW instead of regular SGD</li>
<li>These adaptive optimizers store additional parameters for each model weight, so it makes sense to save them as well in case we plan to continue the pretraining later:</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb168"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a>torch.save({</span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"model_state_dict"</span>: model.state_dict(),</span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"optimizer_state_dict"</span>: optimizer.state_dict(),</span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true" tabindex="-1"></a>    }, </span>
<span id="cb168-5"><a href="#cb168-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"model_and_optimizer.pth"</span></span>
<span id="cb168-6"><a href="#cb168-6" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb169"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a>checkpoint <span class="op">=</span> torch.load(<span class="st">"model_and_optimizer.pth"</span>, weights_only<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> GPTModel(GPT_CONFIG_124M)</span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a>model.load_state_dict(checkpoint[<span class="st">"model_state_dict"</span>])</span>
<span id="cb169-5"><a href="#cb169-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-6"><a href="#cb169-6" aria-hidden="true" tabindex="-1"></a>optimizer <span class="op">=</span> torch.optim.AdamW(model.parameters(), lr<span class="op">=</span><span class="fl">0.0005</span>, weight_decay<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb169-7"><a href="#cb169-7" aria-hidden="true" tabindex="-1"></a>optimizer.load_state_dict(checkpoint[<span class="st">"optimizer_state_dict"</span>])</span>
<span id="cb169-8"><a href="#cb169-8" aria-hidden="true" tabindex="-1"></a>model.train()<span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="loading-pretrained-weights-from-openai" class="level2">
<h2 class="anchored" data-anchor-id="loading-pretrained-weights-from-openai">5.5 Loading pretrained weights from OpenAI</h2>
<ul>
<li>Previously, we only trained a small GPT-2 model using a very small short-story book for educational purposes</li>
<li>Interested readers can also find a longer pretraining run on the complete Project Gutenberg book corpus in <a href="../03_bonus_pretraining_on_gutenberg">../03_bonus_pretraining_on_gutenberg</a></li>
<li>Fortunately, we don’t have to spend tens to hundreds of thousands of dollars to pretrain the model on a large pretraining corpus but can load the pretrained weights provided by OpenAI</li>
</ul>
<hr>
<hr>
<p>⚠️ <strong>Note: Some users may encounter issues in this section due to TensorFlow compatibility problems, particularly on certain Windows systems. TensorFlow is required here only to load the original OpenAI GPT-2 weight files, which we then convert to PyTorch. If you’re running into TensorFlow-related issues, you can use the alternative code below instead of the remaining code in this section. This alternative is based on pre-converted PyTorch weights, created using the same conversion process described in the previous section. For details, refer to the notebook: <a href="../02_alternative_weight_loading/weight-loading-pytorch.ipynb">../02_alternative_weight_loading/weight-loading-pytorch.ipynb</a> notebook.</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb170"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a>file_name <span class="op">=</span> <span class="st">"gpt2-small-124M.pth"</span></span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a><span class="co"># file_name = "gpt2-medium-355M.pth"</span></span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a><span class="co"># file_name = "gpt2-large-774M.pth"</span></span>
<span id="cb170-4"><a href="#cb170-4" aria-hidden="true" tabindex="-1"></a><span class="co"># file_name = "gpt2-xl-1558M.pth"</span></span>
<span id="cb170-5"><a href="#cb170-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-6"><a href="#cb170-6" aria-hidden="true" tabindex="-1"></a>url <span class="op">=</span> <span class="ss">f"https://huggingface.co/rasbt/gpt2-from-scratch-pytorch/resolve/main/</span><span class="sc">{</span>file_name<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb170-7"><a href="#cb170-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-8"><a href="#cb170-8" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> os.path.exists(file_name):</span>
<span id="cb170-9"><a href="#cb170-9" aria-hidden="true" tabindex="-1"></a>    urllib.request.urlretrieve(url, file_name)</span>
<span id="cb170-10"><a href="#cb170-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Downloaded to </span><span class="sc">{</span>file_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb170-11"><a href="#cb170-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-12"><a href="#cb170-12" aria-hidden="true" tabindex="-1"></a>gpt <span class="op">=</span> GPTModel(BASE_CONFIG)</span>
<span id="cb170-13"><a href="#cb170-13" aria-hidden="true" tabindex="-1"></a>gpt.load_state_dict(torch.load(file_name, weights_only<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb170-14"><a href="#cb170-14" aria-hidden="true" tabindex="-1"></a>gpt.<span class="bu">eval</span>()</span>
<span id="cb170-15"><a href="#cb170-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-16"><a href="#cb170-16" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">"cuda"</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">"cpu"</span>)</span>
<span id="cb170-17"><a href="#cb170-17" aria-hidden="true" tabindex="-1"></a>gpt.to(device)<span class="op">;</span></span>
<span id="cb170-18"><a href="#cb170-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-19"><a href="#cb170-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-20"><a href="#cb170-20" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">123</span>)</span>
<span id="cb170-21"><a href="#cb170-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-22"><a href="#cb170-22" aria-hidden="true" tabindex="-1"></a>token_ids <span class="op">=</span> generate(</span>
<span id="cb170-23"><a href="#cb170-23" aria-hidden="true" tabindex="-1"></a>    model<span class="op">=</span>gpt,</span>
<span id="cb170-24"><a href="#cb170-24" aria-hidden="true" tabindex="-1"></a>    idx<span class="op">=</span>text_to_token_ids(<span class="st">"Every effort moves you"</span>, tokenizer).to(device),</span>
<span id="cb170-25"><a href="#cb170-25" aria-hidden="true" tabindex="-1"></a>    max_new_tokens<span class="op">=</span><span class="dv">25</span>,</span>
<span id="cb170-26"><a href="#cb170-26" aria-hidden="true" tabindex="-1"></a>    context_size<span class="op">=</span>NEW_CONFIG[<span class="st">"context_length"</span>],</span>
<span id="cb170-27"><a href="#cb170-27" aria-hidden="true" tabindex="-1"></a>    top_k<span class="op">=</span><span class="dv">50</span>,</span>
<span id="cb170-28"><a href="#cb170-28" aria-hidden="true" tabindex="-1"></a>    temperature<span class="op">=</span><span class="fl">1.5</span></span>
<span id="cb170-29"><a href="#cb170-29" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb170-30"><a href="#cb170-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-31"><a href="#cb170-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Output text:</span><span class="ch">\n</span><span class="st">"</span>, token_ids_to_text(token_ids, tokenizer))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<hr>
<hr>
<ul>
<li>First, some boilerplate code to download the files from OpenAI and load the weights into Python</li>
<li>Since OpenAI used <a href="https://www.tensorflow.org/">TensorFlow</a>, we will have to install and use TensorFlow for loading the weights; <a href="https://github.com/tqdm/tqdm">tqdm</a> is a progress bar library</li>
<li>Uncomment and run the next cell to install the required libraries</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb171"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="co"># pip install tensorflow tqdm</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb172"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"TensorFlow version:"</span>, version(<span class="st">"tensorflow"</span>))</span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"tqdm version:"</span>, version(<span class="st">"tqdm"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>TensorFlow version: 2.18.0
tqdm version: 4.67.1</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb174"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Relative import from the gpt_download.py contained in this folder</span></span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> gpt_download <span class="im">import</span> download_and_load_gpt2</span>
<span id="cb174-4"><a href="#cb174-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Alternatively:</span></span>
<span id="cb174-5"><a href="#cb174-5" aria-hidden="true" tabindex="-1"></a><span class="co"># from llms_from_scratch.ch05 import download_and_load_gpt2</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<hr>
<p><strong>Note</strong></p>
<ul>
<li>In very rare cases, the code cell above may result in a <code>zsh: illegal hardware instruction python</code> error, which could be due to a TensorFlow installation issue on your machine</li>
<li>A reader found that installing TensorFlow via <code>conda</code> solved the issue in this specific case, as mentioned <a href="https://github.com/rasbt/LLMs-from-scratch/discussions/273#discussioncomment-12367888">here</a></li>
<li>You can find more instructions in this supplementary <a href="https://github.com/rasbt/LLMs-from-scratch/tree/main/setup/01_optional-python-setup-preferences#option-2-using-conda">Python setup tutorial</a></li>
</ul>
<hr>
<ul>
<li>We can then download the model weights for the 124 million parameter model as follows:</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb175"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a>settings, params <span class="op">=</span> download_and_load_gpt2(model_size<span class="op">=</span><span class="st">"124M"</span>, models_dir<span class="op">=</span><span class="st">"gpt2"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>checkpoint: 100%|████████████████████████████████████████████████████████████████████████████████| 77.0/77.0 [00:00&lt;00:00, 63.1kiB/s]
encoder.json: 100%|████████████████████████████████████████████████████████████████████████████| 1.04M/1.04M [00:00&lt;00:00, 4.69MiB/s]
hparams.json: 100%|██████████████████████████████████████████████████████████████████████████████| 90.0/90.0 [00:00&lt;00:00, 59.7kiB/s]
model.ckpt.data-00000-of-00001: 100%|████████████████████████████████████████████████████████████| 498M/498M [01:09&lt;00:00, 7.15MiB/s]
model.ckpt.index: 100%|████████████████████████████████████████████████████████████████████████| 5.21k/5.21k [00:00&lt;00:00, 2.32MiB/s]
model.ckpt.meta: 100%|███████████████████████████████████████████████████████████████████████████| 471k/471k [00:00&lt;00:00, 2.19MiB/s]
vocab.bpe: 100%|█████████████████████████████████████████████████████████████████████████████████| 456k/456k [00:00&lt;00:00, 3.47MiB/s]</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb177"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Settings:"</span>, settings)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>Settings: {'n_vocab': 50257, 'n_ctx': 1024, 'n_embd': 768, 'n_head': 12, 'n_layer': 12}</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb179"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Parameter dictionary keys:"</span>, params.keys())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>Parameter dictionary keys: dict_keys(['blocks', 'b', 'g', 'wpe', 'wte'])</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb181"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(params[<span class="st">"wte"</span>])</span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Token embedding weight tensor dimensions:"</span>, params[<span class="st">"wte"</span>].shape)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>[[-0.11010301 -0.03926672  0.03310751 ... -0.1363697   0.01506208
   0.04531523]
 [ 0.04034033 -0.04861503  0.04624869 ...  0.08605453  0.00253983
   0.04318958]
 [-0.12746179  0.04793796  0.18410145 ...  0.08991534 -0.12972379
  -0.08785918]
 ...
 [-0.04453601 -0.05483596  0.01225674 ...  0.10435229  0.09783269
  -0.06952604]
 [ 0.1860082   0.01665728  0.04611587 ... -0.09625227  0.07847701
  -0.02245961]
 [ 0.05135201 -0.02768905  0.0499369  ...  0.00704835  0.15519823
   0.12067825]]
Token embedding weight tensor dimensions: (50257, 768)</code></pre>
<ul>
<li>Alternatively, “355M”, “774M”, and “1558M” are also supported <code>model_size</code> arguments</li>
<li>The difference between these differently sized models is summarized in the figure below:</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch05_compressed/gpt-sizes.webp?timestamp=123" width="500px"></p>
<ul>
<li>Above, we loaded the 124M GPT-2 model weights into Python, however we still need to transfer them into our <code>GPTModel</code> instance</li>
<li>First, we initialize a new GPTModel instance</li>
<li>Note that the original GPT model initialized the linear layers for the query, key, and value matrices in the multi-head attention module with bias vectors, which is not required or recommended; however, to be able to load the weights correctly, we have to enable these too by setting <code>qkv_bias</code> to <code>True</code> in our implementation, too</li>
<li>We are also using the <code>1024</code> token context length that was used by the original GPT-2 model(s)</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb183"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define model configurations in a dictionary for compactness</span></span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a>model_configs <span class="op">=</span> {</span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"gpt2-small (124M)"</span>: {<span class="st">"emb_dim"</span>: <span class="dv">768</span>, <span class="st">"n_layers"</span>: <span class="dv">12</span>, <span class="st">"n_heads"</span>: <span class="dv">12</span>},</span>
<span id="cb183-4"><a href="#cb183-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"gpt2-medium (355M)"</span>: {<span class="st">"emb_dim"</span>: <span class="dv">1024</span>, <span class="st">"n_layers"</span>: <span class="dv">24</span>, <span class="st">"n_heads"</span>: <span class="dv">16</span>},</span>
<span id="cb183-5"><a href="#cb183-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"gpt2-large (774M)"</span>: {<span class="st">"emb_dim"</span>: <span class="dv">1280</span>, <span class="st">"n_layers"</span>: <span class="dv">36</span>, <span class="st">"n_heads"</span>: <span class="dv">20</span>},</span>
<span id="cb183-6"><a href="#cb183-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"gpt2-xl (1558M)"</span>: {<span class="st">"emb_dim"</span>: <span class="dv">1600</span>, <span class="st">"n_layers"</span>: <span class="dv">48</span>, <span class="st">"n_heads"</span>: <span class="dv">25</span>},</span>
<span id="cb183-7"><a href="#cb183-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb183-8"><a href="#cb183-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-9"><a href="#cb183-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Copy the base configuration and update with specific model settings</span></span>
<span id="cb183-10"><a href="#cb183-10" aria-hidden="true" tabindex="-1"></a>model_name <span class="op">=</span> <span class="st">"gpt2-small (124M)"</span>  <span class="co"># Example model name</span></span>
<span id="cb183-11"><a href="#cb183-11" aria-hidden="true" tabindex="-1"></a>NEW_CONFIG <span class="op">=</span> GPT_CONFIG_124M.copy()</span>
<span id="cb183-12"><a href="#cb183-12" aria-hidden="true" tabindex="-1"></a>NEW_CONFIG.update(model_configs[model_name])</span>
<span id="cb183-13"><a href="#cb183-13" aria-hidden="true" tabindex="-1"></a>NEW_CONFIG.update({<span class="st">"context_length"</span>: <span class="dv">1024</span>, <span class="st">"qkv_bias"</span>: <span class="va">True</span>})</span>
<span id="cb183-14"><a href="#cb183-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-15"><a href="#cb183-15" aria-hidden="true" tabindex="-1"></a>gpt <span class="op">=</span> GPTModel(NEW_CONFIG)</span>
<span id="cb183-16"><a href="#cb183-16" aria-hidden="true" tabindex="-1"></a>gpt.<span class="bu">eval</span>()<span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ul>
<li>The next task is to assign the OpenAI weights to the corresponding weight tensors in our <code>GPTModel</code> instance</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb184"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> assign(left, right):</span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> left.shape <span class="op">!=</span> right.shape:</span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Shape mismatch. Left: </span><span class="sc">{</span>left<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">, Right: </span><span class="sc">{</span>right<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> torch.nn.Parameter(torch.tensor(right))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb185"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> load_weights_into_gpt(gpt, params):</span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a>    gpt.pos_emb.weight <span class="op">=</span> assign(gpt.pos_emb.weight, params[<span class="st">'wpe'</span>])</span>
<span id="cb185-5"><a href="#cb185-5" aria-hidden="true" tabindex="-1"></a>    gpt.tok_emb.weight <span class="op">=</span> assign(gpt.tok_emb.weight, params[<span class="st">'wte'</span>])</span>
<span id="cb185-6"><a href="#cb185-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb185-7"><a href="#cb185-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> b <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(params[<span class="st">"blocks"</span>])):</span>
<span id="cb185-8"><a href="#cb185-8" aria-hidden="true" tabindex="-1"></a>        q_w, k_w, v_w <span class="op">=</span> np.split(</span>
<span id="cb185-9"><a href="#cb185-9" aria-hidden="true" tabindex="-1"></a>            (params[<span class="st">"blocks"</span>][b][<span class="st">"attn"</span>][<span class="st">"c_attn"</span>])[<span class="st">"w"</span>], <span class="dv">3</span>, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb185-10"><a href="#cb185-10" aria-hidden="true" tabindex="-1"></a>        gpt.trf_blocks[b].att.W_query.weight <span class="op">=</span> assign(</span>
<span id="cb185-11"><a href="#cb185-11" aria-hidden="true" tabindex="-1"></a>            gpt.trf_blocks[b].att.W_query.weight, q_w.T)</span>
<span id="cb185-12"><a href="#cb185-12" aria-hidden="true" tabindex="-1"></a>        gpt.trf_blocks[b].att.W_key.weight <span class="op">=</span> assign(</span>
<span id="cb185-13"><a href="#cb185-13" aria-hidden="true" tabindex="-1"></a>            gpt.trf_blocks[b].att.W_key.weight, k_w.T)</span>
<span id="cb185-14"><a href="#cb185-14" aria-hidden="true" tabindex="-1"></a>        gpt.trf_blocks[b].att.W_value.weight <span class="op">=</span> assign(</span>
<span id="cb185-15"><a href="#cb185-15" aria-hidden="true" tabindex="-1"></a>            gpt.trf_blocks[b].att.W_value.weight, v_w.T)</span>
<span id="cb185-16"><a href="#cb185-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-17"><a href="#cb185-17" aria-hidden="true" tabindex="-1"></a>        q_b, k_b, v_b <span class="op">=</span> np.split(</span>
<span id="cb185-18"><a href="#cb185-18" aria-hidden="true" tabindex="-1"></a>            (params[<span class="st">"blocks"</span>][b][<span class="st">"attn"</span>][<span class="st">"c_attn"</span>])[<span class="st">"b"</span>], <span class="dv">3</span>, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb185-19"><a href="#cb185-19" aria-hidden="true" tabindex="-1"></a>        gpt.trf_blocks[b].att.W_query.bias <span class="op">=</span> assign(</span>
<span id="cb185-20"><a href="#cb185-20" aria-hidden="true" tabindex="-1"></a>            gpt.trf_blocks[b].att.W_query.bias, q_b)</span>
<span id="cb185-21"><a href="#cb185-21" aria-hidden="true" tabindex="-1"></a>        gpt.trf_blocks[b].att.W_key.bias <span class="op">=</span> assign(</span>
<span id="cb185-22"><a href="#cb185-22" aria-hidden="true" tabindex="-1"></a>            gpt.trf_blocks[b].att.W_key.bias, k_b)</span>
<span id="cb185-23"><a href="#cb185-23" aria-hidden="true" tabindex="-1"></a>        gpt.trf_blocks[b].att.W_value.bias <span class="op">=</span> assign(</span>
<span id="cb185-24"><a href="#cb185-24" aria-hidden="true" tabindex="-1"></a>            gpt.trf_blocks[b].att.W_value.bias, v_b)</span>
<span id="cb185-25"><a href="#cb185-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-26"><a href="#cb185-26" aria-hidden="true" tabindex="-1"></a>        gpt.trf_blocks[b].att.out_proj.weight <span class="op">=</span> assign(</span>
<span id="cb185-27"><a href="#cb185-27" aria-hidden="true" tabindex="-1"></a>            gpt.trf_blocks[b].att.out_proj.weight, </span>
<span id="cb185-28"><a href="#cb185-28" aria-hidden="true" tabindex="-1"></a>            params[<span class="st">"blocks"</span>][b][<span class="st">"attn"</span>][<span class="st">"c_proj"</span>][<span class="st">"w"</span>].T)</span>
<span id="cb185-29"><a href="#cb185-29" aria-hidden="true" tabindex="-1"></a>        gpt.trf_blocks[b].att.out_proj.bias <span class="op">=</span> assign(</span>
<span id="cb185-30"><a href="#cb185-30" aria-hidden="true" tabindex="-1"></a>            gpt.trf_blocks[b].att.out_proj.bias, </span>
<span id="cb185-31"><a href="#cb185-31" aria-hidden="true" tabindex="-1"></a>            params[<span class="st">"blocks"</span>][b][<span class="st">"attn"</span>][<span class="st">"c_proj"</span>][<span class="st">"b"</span>])</span>
<span id="cb185-32"><a href="#cb185-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-33"><a href="#cb185-33" aria-hidden="true" tabindex="-1"></a>        gpt.trf_blocks[b].ff.layers[<span class="dv">0</span>].weight <span class="op">=</span> assign(</span>
<span id="cb185-34"><a href="#cb185-34" aria-hidden="true" tabindex="-1"></a>            gpt.trf_blocks[b].ff.layers[<span class="dv">0</span>].weight, </span>
<span id="cb185-35"><a href="#cb185-35" aria-hidden="true" tabindex="-1"></a>            params[<span class="st">"blocks"</span>][b][<span class="st">"mlp"</span>][<span class="st">"c_fc"</span>][<span class="st">"w"</span>].T)</span>
<span id="cb185-36"><a href="#cb185-36" aria-hidden="true" tabindex="-1"></a>        gpt.trf_blocks[b].ff.layers[<span class="dv">0</span>].bias <span class="op">=</span> assign(</span>
<span id="cb185-37"><a href="#cb185-37" aria-hidden="true" tabindex="-1"></a>            gpt.trf_blocks[b].ff.layers[<span class="dv">0</span>].bias, </span>
<span id="cb185-38"><a href="#cb185-38" aria-hidden="true" tabindex="-1"></a>            params[<span class="st">"blocks"</span>][b][<span class="st">"mlp"</span>][<span class="st">"c_fc"</span>][<span class="st">"b"</span>])</span>
<span id="cb185-39"><a href="#cb185-39" aria-hidden="true" tabindex="-1"></a>        gpt.trf_blocks[b].ff.layers[<span class="dv">2</span>].weight <span class="op">=</span> assign(</span>
<span id="cb185-40"><a href="#cb185-40" aria-hidden="true" tabindex="-1"></a>            gpt.trf_blocks[b].ff.layers[<span class="dv">2</span>].weight, </span>
<span id="cb185-41"><a href="#cb185-41" aria-hidden="true" tabindex="-1"></a>            params[<span class="st">"blocks"</span>][b][<span class="st">"mlp"</span>][<span class="st">"c_proj"</span>][<span class="st">"w"</span>].T)</span>
<span id="cb185-42"><a href="#cb185-42" aria-hidden="true" tabindex="-1"></a>        gpt.trf_blocks[b].ff.layers[<span class="dv">2</span>].bias <span class="op">=</span> assign(</span>
<span id="cb185-43"><a href="#cb185-43" aria-hidden="true" tabindex="-1"></a>            gpt.trf_blocks[b].ff.layers[<span class="dv">2</span>].bias, </span>
<span id="cb185-44"><a href="#cb185-44" aria-hidden="true" tabindex="-1"></a>            params[<span class="st">"blocks"</span>][b][<span class="st">"mlp"</span>][<span class="st">"c_proj"</span>][<span class="st">"b"</span>])</span>
<span id="cb185-45"><a href="#cb185-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-46"><a href="#cb185-46" aria-hidden="true" tabindex="-1"></a>        gpt.trf_blocks[b].norm1.scale <span class="op">=</span> assign(</span>
<span id="cb185-47"><a href="#cb185-47" aria-hidden="true" tabindex="-1"></a>            gpt.trf_blocks[b].norm1.scale, </span>
<span id="cb185-48"><a href="#cb185-48" aria-hidden="true" tabindex="-1"></a>            params[<span class="st">"blocks"</span>][b][<span class="st">"ln_1"</span>][<span class="st">"g"</span>])</span>
<span id="cb185-49"><a href="#cb185-49" aria-hidden="true" tabindex="-1"></a>        gpt.trf_blocks[b].norm1.shift <span class="op">=</span> assign(</span>
<span id="cb185-50"><a href="#cb185-50" aria-hidden="true" tabindex="-1"></a>            gpt.trf_blocks[b].norm1.shift, </span>
<span id="cb185-51"><a href="#cb185-51" aria-hidden="true" tabindex="-1"></a>            params[<span class="st">"blocks"</span>][b][<span class="st">"ln_1"</span>][<span class="st">"b"</span>])</span>
<span id="cb185-52"><a href="#cb185-52" aria-hidden="true" tabindex="-1"></a>        gpt.trf_blocks[b].norm2.scale <span class="op">=</span> assign(</span>
<span id="cb185-53"><a href="#cb185-53" aria-hidden="true" tabindex="-1"></a>            gpt.trf_blocks[b].norm2.scale, </span>
<span id="cb185-54"><a href="#cb185-54" aria-hidden="true" tabindex="-1"></a>            params[<span class="st">"blocks"</span>][b][<span class="st">"ln_2"</span>][<span class="st">"g"</span>])</span>
<span id="cb185-55"><a href="#cb185-55" aria-hidden="true" tabindex="-1"></a>        gpt.trf_blocks[b].norm2.shift <span class="op">=</span> assign(</span>
<span id="cb185-56"><a href="#cb185-56" aria-hidden="true" tabindex="-1"></a>            gpt.trf_blocks[b].norm2.shift, </span>
<span id="cb185-57"><a href="#cb185-57" aria-hidden="true" tabindex="-1"></a>            params[<span class="st">"blocks"</span>][b][<span class="st">"ln_2"</span>][<span class="st">"b"</span>])</span>
<span id="cb185-58"><a href="#cb185-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-59"><a href="#cb185-59" aria-hidden="true" tabindex="-1"></a>    gpt.final_norm.scale <span class="op">=</span> assign(gpt.final_norm.scale, params[<span class="st">"g"</span>])</span>
<span id="cb185-60"><a href="#cb185-60" aria-hidden="true" tabindex="-1"></a>    gpt.final_norm.shift <span class="op">=</span> assign(gpt.final_norm.shift, params[<span class="st">"b"</span>])</span>
<span id="cb185-61"><a href="#cb185-61" aria-hidden="true" tabindex="-1"></a>    gpt.out_head.weight <span class="op">=</span> assign(gpt.out_head.weight, params[<span class="st">"wte"</span>])</span>
<span id="cb185-62"><a href="#cb185-62" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb185-63"><a href="#cb185-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb185-64"><a href="#cb185-64" aria-hidden="true" tabindex="-1"></a>load_weights_into_gpt(gpt, params)</span>
<span id="cb185-65"><a href="#cb185-65" aria-hidden="true" tabindex="-1"></a>gpt.to(device)<span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ul>
<li>If the model is loaded correctly, we can use it to generate new text using our previous <code>generate</code> function:</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb186"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">123</span>)</span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a>token_ids <span class="op">=</span> generate(</span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a>    model<span class="op">=</span>gpt,</span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a>    idx<span class="op">=</span>text_to_token_ids(<span class="st">"Every effort moves you"</span>, tokenizer).to(device),</span>
<span id="cb186-6"><a href="#cb186-6" aria-hidden="true" tabindex="-1"></a>    max_new_tokens<span class="op">=</span><span class="dv">25</span>,</span>
<span id="cb186-7"><a href="#cb186-7" aria-hidden="true" tabindex="-1"></a>    context_size<span class="op">=</span>NEW_CONFIG[<span class="st">"context_length"</span>],</span>
<span id="cb186-8"><a href="#cb186-8" aria-hidden="true" tabindex="-1"></a>    top_k<span class="op">=</span><span class="dv">50</span>,</span>
<span id="cb186-9"><a href="#cb186-9" aria-hidden="true" tabindex="-1"></a>    temperature<span class="op">=</span><span class="fl">1.5</span></span>
<span id="cb186-10"><a href="#cb186-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb186-11"><a href="#cb186-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-12"><a href="#cb186-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Output text:</span><span class="ch">\n</span><span class="st">"</span>, token_ids_to_text(token_ids, tokenizer))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>Output text:
 Every effort moves you toward finding an ideal new way to practice something!

What makes us want to be on top of that?</code></pre>
<ul>
<li><p>We know that we loaded the model weights correctly because the model can generate coherent text; if we made even a small mistake, the model would not be able to do that</p></li>
<li><p>For an alternative way to load the weights from the Hugging Face Hub, see <a href="../02_alternative_weight_loading">../02_alternative_weight_loading</a></p></li>
<li><p>If you are interested in seeing how the GPT architecture compares to the Llama architecture (a popular LLM developed by Meta AI), see the bonus content at <a href="../07_gpt_to_llama">../07_gpt_to_llama</a></p></li>
</ul>
</section>
<section id="summary-and-takeaways-3" class="level2">
<h2 class="anchored" data-anchor-id="summary-and-takeaways-3">Summary and takeaways</h2>
<ul>
<li>See the <a href="./gpt_train.py">./gpt_train.py</a> script, a self-contained script for training</li>
<li>The <a href="./gpt_generate.py">./gpt_generate.py</a> script loads pretrained weights from OpenAI and generates text based on a prompt</li>
<li>You can find the exercise solutions in <a href="./exercise-solutions.ipynb">./exercise-solutions.ipynb</a></li>
</ul>
</section>
</section>
<section id="finetuning-for-text-classification" class="level1">
<h1>6. Finetuning for Text Classification</h1>
<div class="quarto-embed-nb-cell">
<div id="5b7e01c2-1c84-4f2a-bb51-2e0b74abda90" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="9495f150-9d79-4910-d6e7-6c0d9aae4a41" data-execution_count="1">
<div class="cell-output cell-output-stdout">
<pre><code>matplotlib version: 3.10.0
numpy version: 2.0.2
tiktoken version: 0.9.0
torch version: 2.6.0
tensorflow version: 2.18.0
pandas version: 2.2.3</code></pre>
</div>
</div>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch06_compressed/chapter-overview.webp" width="500px"></p>
<section id="different-categories-of-finetuning" class="level2">
<h2 class="anchored" data-anchor-id="different-categories-of-finetuning">6.1 Different categories of finetuning</h2>
<ul>
<li><p>No code in this section</p></li>
<li><p>The most common ways to finetune language models are instruction-finetuning and classification finetuning</p></li>
<li><p>Instruction-finetuning, depicted below, is the topic of the next chapter</p></li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch06_compressed/instructions.webp" width="500px"></p>
<ul>
<li>Classification finetuning, the topic of this chapter, is a procedure you may already be familiar with if you have a background in machine learning – it’s similar to training a convolutional network to classify handwritten digits, for example</li>
<li>In classification finetuning, we have a specific number of class labels (for example, “spam” and “not spam”) that the model can output</li>
<li>A classification finetuned model can only predict classes it has seen during training (for example, “spam” or “not spam”), whereas an instruction-finetuned model can usually perform many tasks</li>
<li>We can think of a classification-finetuned model as a very specialized model; in practice, it is much easier to create a specialized model than a generalist model that performs well on many different tasks</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch06_compressed/spam-non-spam.webp" width="500px"></p>
</section>
<section id="preparing-the-dataset" class="level2">
<h2 class="anchored" data-anchor-id="preparing-the-dataset">6.2 Preparing the dataset</h2>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch06_compressed/overview-1.webp" width="500px"></p>
<ul>
<li>This section prepares the dataset we use for classification finetuning</li>
<li>We use a dataset consisting of spam and non-spam text messages to finetune the LLM to classify them</li>
<li>First, we download and unzip the dataset</li>
</ul>
<div id="def7c09b-af9c-4216-90ce-5e67aed1065c" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="424e4423-f623-443c-ab9e-656f9e867559" data-execution_count="2">
<div class="cell-output cell-output-stdout">
<pre><code>File downloaded and saved as sms_spam_collection/SMSSpamCollection.tsv</code></pre>
</div>
</div>
<ul>
<li>The dataset is saved as a tab-separated text file, which we can load into a pandas DataFrame</li>
</ul>
<div id="da0ed4da-ac31-4e4d-8bdd-2153be4656a4" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:423}}" data-outputid="a16c5cde-d341-4887-a93f-baa9bec542ab" data-execution_count="4">
<div class="cell-output cell-output-display" data-execution_count="4">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Label</th>
<th data-quarto-table-cell-role="th">Text</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">0</th>
<td>ham</td>
<td>Go until jurong point, crazy.. Available only ...</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">1</th>
<td>ham</td>
<td>Ok lar... Joking wif u oni...</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">2</th>
<td>spam</td>
<td>Free entry in 2 a wkly comp to win FA Cup fina...</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">3</th>
<td>ham</td>
<td>U dun say so early hor... U c already then say...</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">4</th>
<td>ham</td>
<td>Nah I don't think he goes to usf, he lives aro...</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">...</th>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">5567</th>
<td>spam</td>
<td>This is the 2nd time we have tried 2 contact u...</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">5568</th>
<td>ham</td>
<td>Will ü b going to esplanade fr home?</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">5569</th>
<td>ham</td>
<td>Pity, * was in mood for that. So...any other s...</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">5570</th>
<td>ham</td>
<td>The guy did some bitching but I acted like i'd...</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">5571</th>
<td>ham</td>
<td>Rofl. Its true to its name</td>
</tr>
</tbody>
</table>

<p>5572 rows × 2 columns</p>
</div>
</div>
</div>
<ul>
<li>When we check the class distribution, we see that the data contains “ham” (i.e., “not spam”) much more frequently than “spam”</li>
</ul>
<div id="495a5280-9d7c-41d4-9719-64ab99056d4c" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="761e0482-43ba-4f46-f4b7-6774dae51b38" data-execution_count="5">
<div class="cell-output cell-output-stdout">
<pre><code>Label
ham     4825
spam     747
Name: count, dtype: int64</code></pre>
</div>
</div>
<ul>
<li>For simplicity, and because we prefer a small dataset for educational purposes anyway (it will make it possible to finetune the LLM faster), we subsample (undersample) the dataset so that it contains 747 instances from each class</li>
<li>(Next to undersampling, there are several other ways to deal with class balances, but they are out of the scope of a book on LLMs; you can find examples and more information in the <a href="https://imbalanced-learn.org/stable/user_guide.html"><code>imbalanced-learn</code> user guide</a>)</li>
</ul>
<div id="7be4a0a2-9704-4a96-b38f-240339818688" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="396dc415-cb71-4a88-e85d-d88201c6d73f" data-execution_count="6">
<div class="cell-output cell-output-stdout">
<pre><code>Label
ham     747
spam    747
Name: count, dtype: int64</code></pre>
</div>
</div>
<ul>
<li>Next, we change the string class labels “ham” and “spam” into integer class labels 0 and 1:</li>
</ul>
<div id="e6f7f062-ef4e-4020-8275-71990cab4414" class="cell" data-execution_count="8">
<div class="cell-output cell-output-display" data-execution_count="8">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Label</th>
<th data-quarto-table-cell-role="th">Text</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">4307</th>
<td>0</td>
<td>Awww dat is sweet! We can think of something t...</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">4138</th>
<td>0</td>
<td>Just got to &amp;lt;#&amp;gt;</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">4831</th>
<td>0</td>
<td>The word "Checkmate" in chess comes from the P...</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">4461</th>
<td>0</td>
<td>This is wishing you a great day. Moji told me ...</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">5440</th>
<td>0</td>
<td>Thank you. do you generally date the brothas?</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">...</th>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">5537</th>
<td>1</td>
<td>Want explicit SEX in 30 secs? Ring 02073162414...</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">5540</th>
<td>1</td>
<td>ASKED 3MOBILE IF 0870 CHATLINES INCLU IN FREE ...</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">5547</th>
<td>1</td>
<td>Had your contract mobile 11 Mnths? Latest Moto...</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">5566</th>
<td>1</td>
<td>REMINDER FROM O2: To get 2.50 pounds free call...</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">5567</th>
<td>1</td>
<td>This is the 2nd time we have tried 2 contact u...</td>
</tr>
</tbody>
</table>

<p>1494 rows × 2 columns</p>
</div>
</div>
</div>
<ul>
<li>Let’s now define a function that randomly divides the dataset into training, validation, and test subsets</li>
</ul>
</section>
<section id="creating-data-loaders" class="level2">
<h2 class="anchored" data-anchor-id="creating-data-loaders">6.3 Creating data loaders</h2>
<ul>
<li>Note that the text messages have different lengths; if we want to combine multiple training examples in a batch, we have to either
<ol type="1">
<li>truncate all messages to the length of the shortest message in the dataset or batch</li>
<li>pad all messages to the length of the longest message in the dataset or batch</li>
</ol></li>
<li>We choose option 2 and pad all messages to the longest message in the dataset</li>
<li>For that, we use <code>&lt;|endoftext|&gt;</code> as a padding token, as discussed in chapter 2</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch06_compressed/pad-input-sequences.webp?123" width="500px"></p>
<div id="74c3c463-8763-4cc0-9320-41c7eaad8ab7" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="b5b48439-32c8-4b37-cca2-c9dc8fa86563" data-execution_count="10">
<div class="cell-output cell-output-stdout">
<pre><code>[50256]</code></pre>
</div>
</div>
<ul>
<li>The <code>SpamDataset</code> class below identifies the longest sequence in the training dataset and adds the padding token to the others to match that sequence length</li>
</ul>
<div id="uzj85f8ou82h" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="d08f1cf0-c24d-445f-a3f8-793532c3716f" data-execution_count="12">
<div class="cell-output cell-output-stdout">
<pre><code>120</code></pre>
</div>
</div>
<ul>
<li><p>We also pad the validation and test set to the longest training sequence</p></li>
<li><p>Note that validation and test set samples that are longer than the longest training example are being truncated via <code>encoded_text[:self.max_length]</code> in the <code>SpamDataset</code> code</p></li>
<li><p>This behavior is entirely optional, and it would also work well if we set <code>max_length=None</code> in both the validation and test set cases</p></li>
<li><p>Next, we use the dataset to instantiate the data loaders, which is similar to creating the data loaders in previous chapters</p></li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch06_compressed/batch.webp" width="500px"></p>
<ul>
<li>As a verification step, we iterate through the data loaders and ensure that the batches contain 8 training examples each, where each training example consists of 120 tokens</li>
</ul>
<div id="4dee6882-4c3a-4964-af15-fa31f86ad047" class="cell" data-execution_count="15">
<div class="cell-output cell-output-stdout">
<pre><code>Train loader:
Input batch dimensions: torch.Size([8, 120])
Label batch dimensions torch.Size([8])</code></pre>
</div>
</div>
<ul>
<li>Lastly, let’s print the total number of batches in each dataset</li>
</ul>
<div id="IZfw-TYD2zTj" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="6934bbf2-9797-4fbe-d26b-1a246e18c2fb" data-execution_count="16">
<div class="cell-output cell-output-stdout">
<pre><code>130 training batches
19 validation batches
38 test batches</code></pre>
</div>
</div>
</section>
<section id="initializing-a-model-with-pretrained-weights" class="level2">
<h2 class="anchored" data-anchor-id="initializing-a-model-with-pretrained-weights">6.4 Initializing a model with pretrained weights</h2>
<ul>
<li>In this section, we initialize the pretrained model we worked with in the previous chapter</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch06_compressed/overview-2.webp" width="500px"></p>
<div id="022a649a-44f5-466c-8a8e-326c063384f5" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="7091e401-8442-4f47-a1d9-ecb42a1ef930" data-execution_count="18">
<div class="cell-output cell-output-stdout">
<pre><code>File already exists and is up-to-date: gpt2/124M/checkpoint
File already exists and is up-to-date: gpt2/124M/encoder.json
File already exists and is up-to-date: gpt2/124M/hparams.json
File already exists and is up-to-date: gpt2/124M/model.ckpt.data-00000-of-00001
File already exists and is up-to-date: gpt2/124M/model.ckpt.index
File already exists and is up-to-date: gpt2/124M/model.ckpt.meta
File already exists and is up-to-date: gpt2/124M/vocab.bpe</code></pre>
</div>
</div>
<ul>
<li>To ensure that the model was loaded correctly, let’s double-check that it generates coherent text</li>
</ul>
<div id="d8ac25ff-74b1-4149-8dc5-4c429d464330" class="cell" data-execution_count="19">
<div class="cell-output cell-output-stdout">
<pre><code>Every effort moves you forward.

The first step is to understand the importance of your work</code></pre>
</div>
</div>
<ul>
<li>Before we finetune the model as a classifier, let’s see if the model can perhaps already classify spam messages via prompting</li>
</ul>
<div id="94224aa9-c95a-4f8a-a420-76d01e3a800c" class="cell" data-execution_count="20">
<div class="cell-output cell-output-stdout">
<pre><code>Is the following text 'spam'? Answer with 'yes' or 'no': 'You are a winner you have been specially selected to receive $1000 cash or a $2000 award.'

The following text 'spam'? Answer with 'yes' or 'no': 'You are a winner</code></pre>
</div>
</div>
<ul>
<li>As we can see, the model is not very good at following instructions</li>
<li>This is expected, since it has only been pretrained and not instruction-finetuned (instruction finetuning will be covered in the next chapter)</li>
</ul>
</section>
<section id="adding-a-classification-head" class="level2">
<h2 class="anchored" data-anchor-id="adding-a-classification-head">6.5 Adding a classification head</h2>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch06_compressed/lm-head.webp" width="500px"></p>
<ul>
<li>In this section, we are modifying the pretrained LLM to make it ready for classification finetuning</li>
<li>Let’s take a look at the model architecture first</li>
</ul>
<div id="b23aff91-6bd0-48da-88f6-353657e6c981" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="b6a5b9b5-a92f-498f-d7cb-b58dd99e4497" data-execution_count="21">
<div class="cell-output cell-output-stdout">
<pre><code>GPTModel(
  (tok_emb): Embedding(50257, 768)
  (pos_emb): Embedding(1024, 768)
  (drop_emb): Dropout(p=0.0, inplace=False)
  (trf_blocks): Sequential(
    (0): TransformerBlock(
      (att): MultiHeadAttention(
        (W_query): Linear(in_features=768, out_features=768, bias=True)
        (W_key): Linear(in_features=768, out_features=768, bias=True)
        (W_value): Linear(in_features=768, out_features=768, bias=True)
        (out_proj): Linear(in_features=768, out_features=768, bias=True)
        (dropout): Dropout(p=0.0, inplace=False)
      )
      (ff): FeedForward(
        (layers): Sequential(
          (0): Linear(in_features=768, out_features=3072, bias=True)
          (1): GELU()
          (2): Linear(in_features=3072, out_features=768, bias=True)
        )
      )
      (norm1): LayerNorm()
      (norm2): LayerNorm()
      (drop_resid): Dropout(p=0.0, inplace=False)
    )
    (1): TransformerBlock(
      (att): MultiHeadAttention(
        (W_query): Linear(in_features=768, out_features=768, bias=True)
        (W_key): Linear(in_features=768, out_features=768, bias=True)
        (W_value): Linear(in_features=768, out_features=768, bias=True)
        (out_proj): Linear(in_features=768, out_features=768, bias=True)
        (dropout): Dropout(p=0.0, inplace=False)
      )
      (ff): FeedForward(
        (layers): Sequential(
          (0): Linear(in_features=768, out_features=3072, bias=True)
          (1): GELU()
          (2): Linear(in_features=3072, out_features=768, bias=True)
        )
      )
      (norm1): LayerNorm()
      (norm2): LayerNorm()
      (drop_resid): Dropout(p=0.0, inplace=False)
    )
    (2): TransformerBlock(
      (att): MultiHeadAttention(
        (W_query): Linear(in_features=768, out_features=768, bias=True)
        (W_key): Linear(in_features=768, out_features=768, bias=True)
        (W_value): Linear(in_features=768, out_features=768, bias=True)
        (out_proj): Linear(in_features=768, out_features=768, bias=True)
        (dropout): Dropout(p=0.0, inplace=False)
      )
      (ff): FeedForward(
        (layers): Sequential(
          (0): Linear(in_features=768, out_features=3072, bias=True)
          (1): GELU()
          (2): Linear(in_features=3072, out_features=768, bias=True)
        )
      )
      (norm1): LayerNorm()
      (norm2): LayerNorm()
      (drop_resid): Dropout(p=0.0, inplace=False)
    )
    (3): TransformerBlock(
      (att): MultiHeadAttention(
        (W_query): Linear(in_features=768, out_features=768, bias=True)
        (W_key): Linear(in_features=768, out_features=768, bias=True)
        (W_value): Linear(in_features=768, out_features=768, bias=True)
        (out_proj): Linear(in_features=768, out_features=768, bias=True)
        (dropout): Dropout(p=0.0, inplace=False)
      )
      (ff): FeedForward(
        (layers): Sequential(
          (0): Linear(in_features=768, out_features=3072, bias=True)
          (1): GELU()
          (2): Linear(in_features=3072, out_features=768, bias=True)
        )
      )
      (norm1): LayerNorm()
      (norm2): LayerNorm()
      (drop_resid): Dropout(p=0.0, inplace=False)
    )
    (4): TransformerBlock(
      (att): MultiHeadAttention(
        (W_query): Linear(in_features=768, out_features=768, bias=True)
        (W_key): Linear(in_features=768, out_features=768, bias=True)
        (W_value): Linear(in_features=768, out_features=768, bias=True)
        (out_proj): Linear(in_features=768, out_features=768, bias=True)
        (dropout): Dropout(p=0.0, inplace=False)
      )
      (ff): FeedForward(
        (layers): Sequential(
          (0): Linear(in_features=768, out_features=3072, bias=True)
          (1): GELU()
          (2): Linear(in_features=3072, out_features=768, bias=True)
        )
      )
      (norm1): LayerNorm()
      (norm2): LayerNorm()
      (drop_resid): Dropout(p=0.0, inplace=False)
    )
    (5): TransformerBlock(
      (att): MultiHeadAttention(
        (W_query): Linear(in_features=768, out_features=768, bias=True)
        (W_key): Linear(in_features=768, out_features=768, bias=True)
        (W_value): Linear(in_features=768, out_features=768, bias=True)
        (out_proj): Linear(in_features=768, out_features=768, bias=True)
        (dropout): Dropout(p=0.0, inplace=False)
      )
      (ff): FeedForward(
        (layers): Sequential(
          (0): Linear(in_features=768, out_features=3072, bias=True)
          (1): GELU()
          (2): Linear(in_features=3072, out_features=768, bias=True)
        )
      )
      (norm1): LayerNorm()
      (norm2): LayerNorm()
      (drop_resid): Dropout(p=0.0, inplace=False)
    )
    (6): TransformerBlock(
      (att): MultiHeadAttention(
        (W_query): Linear(in_features=768, out_features=768, bias=True)
        (W_key): Linear(in_features=768, out_features=768, bias=True)
        (W_value): Linear(in_features=768, out_features=768, bias=True)
        (out_proj): Linear(in_features=768, out_features=768, bias=True)
        (dropout): Dropout(p=0.0, inplace=False)
      )
      (ff): FeedForward(
        (layers): Sequential(
          (0): Linear(in_features=768, out_features=3072, bias=True)
          (1): GELU()
          (2): Linear(in_features=3072, out_features=768, bias=True)
        )
      )
      (norm1): LayerNorm()
      (norm2): LayerNorm()
      (drop_resid): Dropout(p=0.0, inplace=False)
    )
    (7): TransformerBlock(
      (att): MultiHeadAttention(
        (W_query): Linear(in_features=768, out_features=768, bias=True)
        (W_key): Linear(in_features=768, out_features=768, bias=True)
        (W_value): Linear(in_features=768, out_features=768, bias=True)
        (out_proj): Linear(in_features=768, out_features=768, bias=True)
        (dropout): Dropout(p=0.0, inplace=False)
      )
      (ff): FeedForward(
        (layers): Sequential(
          (0): Linear(in_features=768, out_features=3072, bias=True)
          (1): GELU()
          (2): Linear(in_features=3072, out_features=768, bias=True)
        )
      )
      (norm1): LayerNorm()
      (norm2): LayerNorm()
      (drop_resid): Dropout(p=0.0, inplace=False)
    )
    (8): TransformerBlock(
      (att): MultiHeadAttention(
        (W_query): Linear(in_features=768, out_features=768, bias=True)
        (W_key): Linear(in_features=768, out_features=768, bias=True)
        (W_value): Linear(in_features=768, out_features=768, bias=True)
        (out_proj): Linear(in_features=768, out_features=768, bias=True)
        (dropout): Dropout(p=0.0, inplace=False)
      )
      (ff): FeedForward(
        (layers): Sequential(
          (0): Linear(in_features=768, out_features=3072, bias=True)
          (1): GELU()
          (2): Linear(in_features=3072, out_features=768, bias=True)
        )
      )
      (norm1): LayerNorm()
      (norm2): LayerNorm()
      (drop_resid): Dropout(p=0.0, inplace=False)
    )
    (9): TransformerBlock(
      (att): MultiHeadAttention(
        (W_query): Linear(in_features=768, out_features=768, bias=True)
        (W_key): Linear(in_features=768, out_features=768, bias=True)
        (W_value): Linear(in_features=768, out_features=768, bias=True)
        (out_proj): Linear(in_features=768, out_features=768, bias=True)
        (dropout): Dropout(p=0.0, inplace=False)
      )
      (ff): FeedForward(
        (layers): Sequential(
          (0): Linear(in_features=768, out_features=3072, bias=True)
          (1): GELU()
          (2): Linear(in_features=3072, out_features=768, bias=True)
        )
      )
      (norm1): LayerNorm()
      (norm2): LayerNorm()
      (drop_resid): Dropout(p=0.0, inplace=False)
    )
    (10): TransformerBlock(
      (att): MultiHeadAttention(
        (W_query): Linear(in_features=768, out_features=768, bias=True)
        (W_key): Linear(in_features=768, out_features=768, bias=True)
        (W_value): Linear(in_features=768, out_features=768, bias=True)
        (out_proj): Linear(in_features=768, out_features=768, bias=True)
        (dropout): Dropout(p=0.0, inplace=False)
      )
      (ff): FeedForward(
        (layers): Sequential(
          (0): Linear(in_features=768, out_features=3072, bias=True)
          (1): GELU()
          (2): Linear(in_features=3072, out_features=768, bias=True)
        )
      )
      (norm1): LayerNorm()
      (norm2): LayerNorm()
      (drop_resid): Dropout(p=0.0, inplace=False)
    )
    (11): TransformerBlock(
      (att): MultiHeadAttention(
        (W_query): Linear(in_features=768, out_features=768, bias=True)
        (W_key): Linear(in_features=768, out_features=768, bias=True)
        (W_value): Linear(in_features=768, out_features=768, bias=True)
        (out_proj): Linear(in_features=768, out_features=768, bias=True)
        (dropout): Dropout(p=0.0, inplace=False)
      )
      (ff): FeedForward(
        (layers): Sequential(
          (0): Linear(in_features=768, out_features=3072, bias=True)
          (1): GELU()
          (2): Linear(in_features=3072, out_features=768, bias=True)
        )
      )
      (norm1): LayerNorm()
      (norm2): LayerNorm()
      (drop_resid): Dropout(p=0.0, inplace=False)
    )
  )
  (final_norm): LayerNorm()
  (out_head): Linear(in_features=768, out_features=50257, bias=False)
)</code></pre>
</div>
</div>
<ul>
<li><p>Above, we can see the architecture we implemented in chapter 4 neatly laid out</p></li>
<li><p>The goal is to replace and finetune the output layer</p></li>
<li><p>To achieve this, we first freeze the model, meaning that we make all layers non-trainable</p></li>
<li><p>Then, we replace the output layer (<code>model.out_head</code>), which originally maps the layer inputs to 50,257 dimensions (the size of the vocabulary)</p></li>
<li><p>Since we finetune the model for binary classification (predicting 2 classes, “spam” and “not spam”), we can replace the output layer as shown below, which will be trainable by default</p></li>
<li><p>Note that we use <code>BASE_CONFIG["emb_dim"]</code> (which is equal to 768 in the <code>"gpt2-small (124M)"</code> model) to keep the code below more general</p></li>
<li><p>Technically, it’s sufficient to only train the output layer</p></li>
<li><p>However, as I found in <a href="https://magazine.sebastianraschka.com/p/finetuning-large-language-models">Finetuning Large Language Models</a>, experiments show that finetuning additional layers can noticeably improve the performance</p></li>
<li><p>So, we are also making the last transformer block and the final <code>LayerNorm</code> module connecting the last transformer block to the output layer trainable</p></li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch06_compressed/trainable.webp" width="500px"></p>
<ul>
<li>We can still use this model similar to before in previous chapters</li>
<li>For example, let’s feed it some text input</li>
</ul>
<div id="f645c06a-7df6-451c-ad3f-eafb18224ebc" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="27e041b1-d731-48a1-cf60-f22d4565304e" data-execution_count="25">
<div class="cell-output cell-output-stdout">
<pre><code>Inputs: tensor([[5211,  345,  423,  640]])
Inputs dimensions: torch.Size([1, 4])</code></pre>
</div>
</div>
<ul>
<li>What’s different compared to previous chapters is that it now has two output dimensions instead of 50,257</li>
</ul>
<div id="48dc84f1-85cc-4609-9cee-94ff539f00f4" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="9cae7448-253d-4776-973e-0af190b06354" data-execution_count="26">
<div class="cell-output cell-output-stdout">
<pre><code>Outputs:
 tensor([[[-1.5854,  0.9904],
         [-3.7235,  7.4548],
         [-2.2661,  6.6049],
         [-3.5983,  3.9902]]])
Outputs dimensions: torch.Size([1, 4, 2])</code></pre>
</div>
</div>
<ul>
<li>As discussed in previous chapters, for each input token, there’s one output vector</li>
<li>Since we fed the model a text sample with 4 input tokens, the output consists of 4 2-dimensional output vectors above</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch06_compressed/input-and-output.webp" width="500px"></p>
<ul>
<li>In chapter 3, we discussed the attention mechanism, which connects each input token to each other input token</li>
<li>In chapter 3, we then also introduced the causal attention mask that is used in GPT-like models; this causal mask lets a current token only attend to the current and previous token positions</li>
<li>Based on this causal attention mechanism, the 4th (last) token contains the most information among all tokens because it’s the only token that includes information about all other tokens</li>
<li>Hence, we are particularly interested in this last token, which we will finetune for the spam classification task</li>
</ul>
<div id="49383a8c-41d5-4dab-98f1-238bca0c2ed7" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="e79eb155-fa1f-46ed-ff8c-d828c3a3fabd" data-execution_count="27">
<div class="cell-output cell-output-stdout">
<pre><code>Last output token: tensor([[-3.5983,  3.9902]])</code></pre>
</div>
</div>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch06_compressed/attention-mask.webp" width="200px"></p>
</section>
<section id="calculating-the-classification-loss-and-accuracy" class="level2">
<h2 class="anchored" data-anchor-id="calculating-the-classification-loss-and-accuracy">6.6 Calculating the classification loss and accuracy</h2>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch06_compressed/overview-3.webp?1" width="500px"></p>
<ul>
<li>Before explaining the loss calculation, let’s have a brief look at how the model outputs are turned into class labels</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch06_compressed/class-argmax.webp" width="600px"></p>
<div id="c77faab1-3461-4118-866a-6171f2b89aa0" class="cell" data-execution_count="28">
<div class="cell-output cell-output-stdout">
<pre><code>Last output token: tensor([[-3.5983,  3.9902]])</code></pre>
</div>
</div>
<ul>
<li>Similar to chapter 5, we convert the outputs (logits) into probability scores via the <code>softmax</code> function and then obtain the index position of the largest probability value via the <code>argmax</code> function</li>
</ul>
<div id="b81efa92-9be1-4b9e-8790-ce1fc7b17f01" class="cell" data-execution_count="29">
<div class="cell-output cell-output-stdout">
<pre><code>Class label: 1</code></pre>
</div>
</div>
<ul>
<li>Note that the softmax function is optional here, as explained in chapter 5, because the largest outputs correspond to the largest probability scores</li>
</ul>
<div id="f9f9ad66-4969-4501-8239-3ccdb37e71a2" class="cell" data-execution_count="30">
<div class="cell-output cell-output-stdout">
<pre><code>Class label: 1</code></pre>
</div>
</div>
<ul>
<li><p>We can apply this concept to calculate the so-called classification accuracy, which computes the percentage of correct predictions in a given dataset</p></li>
<li><p>To calculate the classification accuracy, we can apply the preceding <code>argmax</code>-based prediction code to all examples in a dataset and calculate the fraction of correct predictions as follows:</p></li>
<li><p>Let’s apply the function to calculate the classification accuracies for the different datasets:</p></li>
</ul>
<div id="390e5255-8427-488c-adef-e1c10ab4fb26" class="cell" data-execution_count="32">
<div class="cell-output cell-output-stdout">
<pre><code>Training accuracy: 46.25%
Validation accuracy: 45.00%
Test accuracy: 48.75%</code></pre>
</div>
</div>
<ul>
<li><p>As we can see, the prediction accuracies are not very good, since we haven’t finetuned the model, yet</p></li>
<li><p>Before we can start finetuning (/training), we first have to define the loss function we want to optimize during training</p></li>
<li><p>The goal is to maximize the spam classification accuracy of the model; however, classification accuracy is not a differentiable function</p></li>
<li><p>Hence, instead, we minimize the cross-entropy loss as a proxy for maximizing the classification accuracy (you can learn more about this topic in lecture 8 of my freely available <a href="https://sebastianraschka.com/blog/2021/dl-course.html#l08-multinomial-logistic-regression--softmax-regression">Introduction to Deep Learning</a> class)</p></li>
<li><p>The <code>calc_loss_batch</code> function is the same here as in chapter 5, except that we are only interested in optimizing the last token <code>model(input_batch)[:, -1, :]</code> instead of all tokens <code>model(input_batch)</code></p></li>
</ul>
<p>The <code>calc_loss_loader</code> is exactly the same as in chapter 5</p>
<ul>
<li>Using the <code>calc_closs_loader</code>, we compute the initial training, validation, and test set losses before we start training</li>
</ul>
<div id="f6f00e53-5beb-4e64-b147-f26fd481c6ff" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="49df8648-9e38-4314-854d-9faacd1b2e89" data-execution_count="35">
<div class="cell-output cell-output-stdout">
<pre><code>Training loss: 2.453
Validation loss: 2.583
Test loss: 2.322</code></pre>
</div>
</div>
<ul>
<li>In the next section, we train the model to improve the loss values and consequently the classification accuracy</li>
</ul>
</section>
<section id="finetuning-the-model-on-supervised-data" class="level2">
<h2 class="anchored" data-anchor-id="finetuning-the-model-on-supervised-data">6.7 Finetuning the model on supervised data</h2>
<ul>
<li>In this section, we define and use the training function to improve the classification accuracy of the model</li>
<li>The <code>train_classifier_simple</code> function below is practically the same as the <code>train_model_simple</code> function we used for pretraining the model in chapter 5</li>
<li>The only two differences are that we now
<ol type="1">
<li>track the number of training examples seen (<code>examples_seen</code>) instead of the number of tokens seen</li>
<li>calculate the accuracy after each epoch instead of printing a sample text after each epoch</li>
</ol></li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch06_compressed/training-loop.webp?1" width="500px"></p>
<ul>
<li><p>The <code>evaluate_model</code> function used in the <code>train_classifier_simple</code> is the same as the one we used in chapter 5</p></li>
<li><p>The training takes about 5 minutes on a M3 MacBook Air laptop computer and less than half a minute on a V100 or A100 GPU</p></li>
</ul>
<div id="X7kU3aAj7vTJ" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="504a033e-2bf8-41b5-a037-468309845513" data-execution_count="38">
<div class="cell-output cell-output-stdout">
<pre><code>Ep 1 (Step 000000): Train loss 2.153, Val loss 2.392
Ep 1 (Step 000050): Train loss 0.617, Val loss 0.637
Ep 1 (Step 000100): Train loss 0.523, Val loss 0.557
Training accuracy: 70.00% | Validation accuracy: 72.50%
Ep 2 (Step 000150): Train loss 0.561, Val loss 0.489
Ep 2 (Step 000200): Train loss 0.419, Val loss 0.397
Ep 2 (Step 000250): Train loss 0.409, Val loss 0.353
Training accuracy: 82.50% | Validation accuracy: 85.00%
Ep 3 (Step 000300): Train loss 0.333, Val loss 0.320
Ep 3 (Step 000350): Train loss 0.340, Val loss 0.306
Training accuracy: 90.00% | Validation accuracy: 90.00%
Ep 4 (Step 000400): Train loss 0.136, Val loss 0.200
Ep 4 (Step 000450): Train loss 0.153, Val loss 0.132
Ep 4 (Step 000500): Train loss 0.222, Val loss 0.137
Training accuracy: 100.00% | Validation accuracy: 97.50%
Ep 5 (Step 000550): Train loss 0.207, Val loss 0.143
Ep 5 (Step 000600): Train loss 0.083, Val loss 0.074
Training accuracy: 100.00% | Validation accuracy: 97.50%
Training completed in 5.31 minutes.</code></pre>
</div>
</div>
<ul>
<li>Similar to chapter 5, we use matplotlib to plot the loss function for the training and validation set</li>
</ul>
<div id="OIqRt466DiGk" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:307}}" data-outputid="b16987cf-0001-4652-ddaf-02f7cffc34db" data-execution_count="40">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/chapters-ch06-cell-40-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<ul>
<li>Above, based on the downward slope, we see that the model learns well</li>
<li>Furthermore, the fact that the training and validation loss are very close indicates that the model does not tend to overfit the training data</li>
<li>Similarly, we can plot the accuracy below</li>
</ul>
<div id="yz8BIsaF0TUo" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:307}}" data-outputid="3a7ed967-1f2a-4c6d-f4a3-0cc8cc9d6c5f" data-execution_count="41">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/chapters-ch06-cell-41-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<ul>
<li>Based on the accuracy plot above, we can see that the model achieves a relatively high training and validation accuracy after epochs 4 and 5</li>
<li>However, we have to keep in mind that we specified <code>eval_iter=5</code> in the training function earlier, which means that we only estimated the training and validation set performances</li>
<li>We can compute the training, validation, and test set performances over the complete dataset as follows below</li>
</ul>
<div id="UHWaJFrjY0zW" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="e111e6e6-b147-4159-eb9d-19d4e809ed34" data-execution_count="42">
<div class="cell-output cell-output-stdout">
<pre><code>Training accuracy: 97.21%
Validation accuracy: 97.32%
Test accuracy: 95.67%</code></pre>
</div>
</div>
<ul>
<li>We can see that the training and validation set performances are practically identical</li>
<li>However, based on the slightly lower test set performance, we can see that the model overfits the training data to a very small degree, as well as the validation data that has been used for tweaking some of the hyperparameters, such as the learning rate</li>
<li>This is normal, however, and this gap could potentially be further reduced by increasing the model’s dropout rate (<code>drop_rate</code>) or the <code>weight_decay</code> in the optimizer setting</li>
</ul>
</section>
<section id="using-the-llm-as-a-spam-classifier" class="level2">
<h2 class="anchored" data-anchor-id="using-the-llm-as-a-spam-classifier">6.8 Using the LLM as a spam classifier</h2>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch06_compressed/overview-4.webp" width="500px"></p>
<ul>
<li><p>Finally, let’s use the finetuned GPT model in action</p></li>
<li><p>The <code>classify_review</code> function below implements the data preprocessing steps similar to the <code>SpamDataset</code> we implemented earlier</p></li>
<li><p>Then, the function returns the predicted integer class label from the model and returns the corresponding class name</p></li>
<li><p>Let’s try it out on a few examples below</p></li>
</ul>
<div id="apU_pf51AWSV" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="d0fde0a5-e7a3-4dbe-d9c5-0567dbab7e62" data-execution_count="44">
<div class="cell-output cell-output-stdout">
<pre><code>spam</code></pre>
</div>
</div>
<div id="1g5VTOo_Ajs5" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="659b08eb-b6a9-4a8a-9af7-d94c757e93c2" data-execution_count="45">
<div class="cell-output cell-output-stdout">
<pre><code>not spam</code></pre>
</div>
</div>
<ul>
<li><p>Finally, let’s save the model in case we want to reuse the model later without having to train it again</p></li>
<li><p>Then, in a new session, we could load the model as follows</p></li>
</ul>
<div id="cc4e68a5-d492-493b-87ef-45c475f353f5" class="cell" data-execution_count="47">
<div class="cell-output cell-output-display" data-execution_count="47">
<pre><code>&lt;All keys matched successfully&gt;</code></pre>
</div>
</div>
</section>
<section id="summary-and-takeaways-4" class="level2">
<h2 class="anchored" data-anchor-id="summary-and-takeaways-4">Summary and takeaways</h2>
<ul>
<li>See the <a href="./gpt_class_finetune.py">./gpt_class_finetune.py</a> script, a self-contained script for classification finetuning</li>
<li>You can find the exercise solutions in <a href="./exercise-solutions.ipynb">./exercise-solutions.ipynb</a></li>
<li>In addition, interested readers can find an introduction to parameter-efficient training with low-rank adaptation (LoRA) in <a href="../../appendix-E">appendix E</a></li>
</ul>
</section>
<a class="quarto-notebook-link" id="nblink-4" href="chapters/ch06-preview.html#5b7e01c2-1c84-4f2a-bb51-2e0b74abda90">Source: 6.1 Different categories of finetuning</a></div>
</section>
<section id="finetuning-to-follow-instruction" class="level1">
<h1>7. Finetuning to Follow Instruction</h1>
<div class="quarto-embed-nb-cell">
<div id="4e19327b-6c02-4881-ad02-9b6d3ec0b1b4" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="bcdfe2cb-d084-4920-d703-503131aabec3" data-execution_count="1">
<div class="cell-output cell-output-stdout">
<pre><code>numpy version: 2.0.2
matplotlib version: 3.10.0
tiktoken version: 0.8.0
torch version: 2.5.1+cu124
tqdm version: 4.67.1
tensorflow version: 2.18.0</code></pre>
</div>
</div>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/overview.webp?1" width="500px"></p>
<section id="introduction-to-instruction-finetuning" class="level2">
<h2 class="anchored" data-anchor-id="introduction-to-instruction-finetuning">7.1 Introduction to instruction finetuning</h2>
<ul>
<li>In chapter 5, we saw that pretraining an LLM involves a training procedure where it learns to generate one word at a time</li>
<li>Hence, a pretrained LLM is good at text completion, but it is not good at following instructions</li>
<li>In this chapter, we teach the LLM to follow instructions better</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/instruction-following.webp" width="500px"></p>
<ul>
<li>The topics covered in this chapter are summarized in the figure below</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/chapter-overview-1.webp?1" width="500px"></p>
</section>
<section id="preparing-a-dataset-for-supervised-instruction-finetuning" class="level2">
<h2 class="anchored" data-anchor-id="preparing-a-dataset-for-supervised-instruction-finetuning">7.2 Preparing a dataset for supervised instruction finetuning</h2>
<ul>
<li>We will work with an instruction dataset I prepared for this chapter</li>
</ul>
<div id="0G3axLw6kY1N" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="07e1e4f9-026c-48c1-8a06-f2bfb1fb354e" data-execution_count="2">
<div class="cell-output cell-output-stdout">
<pre><code>Number of entries: 1100</code></pre>
</div>
</div>
<ul>
<li>Each item in the <code>data</code> list we loaded from the JSON file above is a dictionary in the following form</li>
</ul>
<div id="-LiuBMsHkzQV" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="a4ee5c2d-db53-4a80-e5ee-0bbcf6fe0450" data-execution_count="3">
<div class="cell-output cell-output-stdout">
<pre><code>Example entry:
 {'instruction': 'Identify the correct spelling of the following word.', 'input': 'Ocassion', 'output': "The correct spelling is 'Occasion.'"}</code></pre>
</div>
</div>
<ul>
<li>Note that the <code>'input'</code> field can be empty:</li>
</ul>
<div id="uFInFxDDk2Je" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="b4f84027-bb9e-4e51-b79e-1329c8bff093" data-execution_count="4">
<div class="cell-output cell-output-stdout">
<pre><code>Another example entry:
 {'instruction': "What is an antonym of 'complicated'?", 'input': '', 'output': "An antonym of 'complicated' is 'simple'."}</code></pre>
</div>
</div>
<ul>
<li>Instruction finetuning is often referred to as “supervised instruction finetuning” because it involves training a model on a dataset where the input-output pairs are explicitly provided</li>
<li>There are different ways to format the entries as inputs to the LLM; the figure below illustrates two example formats that were used for training the Alpaca (https://crfm.stanford.edu/2023/03/13/alpaca.html) and Phi-3 (https://arxiv.org/abs/2404.14219) LLMs, respectively</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/prompt-style.webp?1" width="500px"></p>
<ul>
<li><p>In this chapter, we use Alpaca-style prompt formatting, which was the original prompt template for instruction finetuning</p></li>
<li><p>Below, we format the input that we will pass as input to the LLM</p></li>
<li><p>A formatted response with input field looks like as shown below</p></li>
</ul>
<div id="F9UQRfjzo4Js" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="7b615d35-2a5f-474d-9292-a69bc3850e16" data-execution_count="6">
<div class="cell-output cell-output-stdout">
<pre><code>Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
Identify the correct spelling of the following word.

### Input:
Ocassion

### Response:
The correct spelling is 'Occasion.'</code></pre>
</div>
</div>
<ul>
<li>Below is a formatted response without an input field</li>
</ul>
<div id="a3891fa9-f738-41cd-946c-80ef9a99c346" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="2142c5a4-b594-49c5-affe-2d963a7bd46b" data-execution_count="7">
<div class="cell-output cell-output-stdout">
<pre><code>Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
What is an antonym of 'complicated'?

### Response:
An antonym of 'complicated' is 'simple'.</code></pre>
</div>
</div>
<ul>
<li>Lastly, before we prepare the PyTorch data loaders in the next section, we divide the dataset into a training, validation, and test set</li>
</ul>
<div id="-zf6oht6bIUQ" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="657ec5c6-4caa-4d1a-ba2e-23acd755ab07" data-execution_count="9">
<div class="cell-output cell-output-stdout">
<pre><code>Training set length: 935
Validation set length: 55
Test set length: 110</code></pre>
</div>
</div>
</section>
<section id="organizing-data-into-training-batches" class="level2">
<h2 class="anchored" data-anchor-id="organizing-data-into-training-batches">7.3 Organizing data into training batches</h2>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/chapter-overview-2.webp?1" width="500px"></p>
<ul>
<li>We tackle this dataset batching in several steps, as summarized in the figure below</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/detailed-batching.webp?1" width="500px"></p>
<ul>
<li>First, we implement an <code>InstructionDataset</code> class that pre-tokenizes all inputs in the dataset, similar to the <code>SpamDataset</code> in chapter 6</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/pretokenizing.webp" width="500px"></p>
<ul>
<li>Similar to chapter 6, we want to collect multiple training examples in a batch to accelerate training; this requires padding all inputs to a similar length</li>
<li>Also similar to the previous chapter, we use the <code>&lt;|endoftext|&gt;</code> token as a padding token</li>
</ul>
<div id="ff24fe1a-5746-461c-ad3d-b6d84a1a7c96" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="ac44227b-9ec2-4131-9df8-89caa6e879ca" data-execution_count="11">
<div class="cell-output cell-output-stdout">
<pre><code>[50256]</code></pre>
</div>
</div>
<ul>
<li>In chapter 6, we padded all examples in a dataset to the same length
<ul>
<li>Here, we take a more sophisticated approach and develop a custom “collate” function that we can pass to the data loader</li>
<li>This custom collate function pads the training examples in each batch to have the same length (but different batches can have different lengths)</li>
</ul></li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/padding.webp" width="500px"></p>
<div id="8fb02373-59b3-4f3a-b1d1-8181a2432645" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="93d987b9-e3ca-4857-9b28-b67d515a94d8" data-execution_count="13">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[    0,     1,     2,     3,     4],
        [    5,     6, 50256, 50256, 50256],
        [    7,     8,     9, 50256, 50256]])</code></pre>
</div>
</div>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/batching-step-4.webp?1" width="500px"></p>
<ul>
<li>Above, we only returned the inputs to the LLM; however, for LLM training, we also need the target values</li>
<li>Similar to pretraining an LLM, the targets are the inputs shifted by 1 position to the right, so the LLM learns to predict the next token</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/inputs-targets.webp?1" width="400px"></p>
<div id="6eb2bce3-28a7-4f39-9d4b-5e972d69066c" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="3d104439-c328-431b-ef7c-2639d86c2135" data-execution_count="15">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[    0,     1,     2,     3,     4],
        [    5,     6, 50256, 50256, 50256],
        [    7,     8,     9, 50256, 50256]])
tensor([[    1,     2,     3,     4, 50256],
        [    6, 50256, 50256, 50256, 50256],
        [    8,     9, 50256, 50256, 50256]])</code></pre>
</div>
</div>
<ul>
<li>Next, we introduce an <code>ignore_index</code> value to replace all padding token IDs with a new value; the purpose of this <code>ignore_index</code> is that we can ignore padding values in the loss function (more on that later)</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/batching-step-5.webp?1" width="500px"></p>
<ul>
<li>Concretely, this means that we replace the token IDs corresponding to <code>50256</code> with <code>-100</code> as illustrated below</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/ignore-index.webp?1" width="500px"></p>
<ul>
<li>(In addition, we also introduce the <code>allowed_max_length</code> in case we want to limit the length of the samples; this will be useful if you plan to work with your own datasets that are longer than the 1024 token context size supported by the GPT-2 model)</li>
</ul>
<div id="cdf5eec4-9ebe-4be0-9fca-9a47bee88fdc" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="e8f709b9-f4c5-428a-a6ac-2a4c1b9358ba" data-execution_count="17">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([[    0,     1,     2,     3,     4],
        [    5,     6, 50256, 50256, 50256],
        [    7,     8,     9, 50256, 50256]])
tensor([[    1,     2,     3,     4, 50256],
        [    6, 50256,  -100,  -100,  -100],
        [    8,     9, 50256,  -100,  -100]])</code></pre>
</div>
</div>
<ul>
<li>Let’s see what this replacement by -100 accomplishes</li>
<li>For illustration purposes, let’s assume we have a small classification task with 2 class labels, 0 and 1, similar to chapter 6</li>
<li>If we have the following logits values (outputs of the last layer of the model), we calculate the following loss</li>
</ul>
<div id="W2jvh-OP9MFV" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="ccb3a703-59a7-4258-8841-57959a016e31" data-execution_count="18">
<div class="cell-output cell-output-stdout">
<pre><code>tensor(1.1269)</code></pre>
</div>
</div>
<ul>
<li>Now, adding one more training example will, as expected, influence the loss</li>
</ul>
<div id="nvVMuil89v9N" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="6d4683d4-5bfc-4a8c-de2a-95ecb2e716b9" data-execution_count="19">
<div class="cell-output cell-output-stdout">
<pre><code>tensor(0.7936)</code></pre>
</div>
</div>
<ul>
<li>Let’s see what happens if we replace the class label of one of the examples with -100</li>
</ul>
<div id="RTyB1vah9p56" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="da05302e-3fe0-439e-d1ed-82066bceb122" data-execution_count="20">
<div class="cell-output cell-output-stdout">
<pre><code>tensor(1.1269)
loss_1 == loss_3: tensor(True)</code></pre>
</div>
</div>
<ul>
<li><p>As we can see, the resulting loss on these 3 training examples is the same as the loss we calculated from the 2 training examples, which means that the cross-entropy loss function ignored the training example with the -100 label</p></li>
<li><p>By default, PyTorch has the <code>cross_entropy(..., ignore_index=-100)</code> setting to ignore examples corresponding to the label -100</p></li>
<li><p>Using this -100 <code>ignore_index</code>, we can ignore the additional end-of-text (padding) tokens in the batches that we used to pad the training examples to equal length</p></li>
<li><p>However, we don’t want to ignore the first instance of the end-of-text (padding) token (50256) because it can help signal to the LLM when the response is complete</p></li>
<li><p>In practice, it is also common to mask out the target token IDs that correspond to the instruction, as illustrated in the figure below (this is a recommended reader exercise after completing the chapter)</p></li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/mask-instructions.webp?1" width="600px"></p>
</section>
<section id="creating-data-loaders-for-an-instruction-dataset" class="level2">
<h2 class="anchored" data-anchor-id="creating-data-loaders-for-an-instruction-dataset">7.4 Creating data loaders for an instruction dataset</h2>
<ul>
<li>In this section, we use the <code>InstructionDataset</code> class and <code>custom_collate_fn</code> function to instantiate the training, validation, and test data loaders</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/chapter-overview-3.webp?1" width="500px"></p>
<ul>
<li>Another additional detail of the previous <code>custom_collate_fn</code> function is that we now directly move the data to the target device (e.g., GPU) instead of doing it in the main training loop, which improves efficiency because it can be carried out as a background process when we use the <code>custom_collate_fn</code> as part of the data loader</li>
<li>Using the <code>partial</code> function from Python’s <code>functools</code> standard library, we create a new function with the <code>device</code> argument of the original function pre-filled</li>
</ul>
<div id="etpqqWh8phKc" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="b4391c33-1a89-455b-faaa-5f874b6eb409" data-execution_count="21">
<div class="cell-output cell-output-stdout">
<pre><code>Device: cuda</code></pre>
</div>
</div>
<ul>
<li><p>Next, we instantiate the data loaders similar to previous chapters, except that we now provide our own collate function for the batching process</p></li>
<li><p>Let’s see what the dimensions of the resulting input and target batches look like</p></li>
</ul>
<div id="GGs1AI3vHpnX" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="f6a74c8b-1af3-4bc1-b48c-eda64b0200d1" data-execution_count="25">
<div class="cell-output cell-output-stdout">
<pre><code>Train loader:
torch.Size([8, 61]) torch.Size([8, 61])
torch.Size([8, 76]) torch.Size([8, 76])
torch.Size([8, 73]) torch.Size([8, 73])
torch.Size([8, 68]) torch.Size([8, 68])
torch.Size([8, 65]) torch.Size([8, 65])
torch.Size([8, 72]) torch.Size([8, 72])
torch.Size([8, 80]) torch.Size([8, 80])
torch.Size([8, 67]) torch.Size([8, 67])
torch.Size([8, 62]) torch.Size([8, 62])
torch.Size([8, 75]) torch.Size([8, 75])
torch.Size([8, 62]) torch.Size([8, 62])
torch.Size([8, 68]) torch.Size([8, 68])
torch.Size([8, 67]) torch.Size([8, 67])
torch.Size([8, 77]) torch.Size([8, 77])
torch.Size([8, 69]) torch.Size([8, 69])
torch.Size([8, 79]) torch.Size([8, 79])
torch.Size([8, 71]) torch.Size([8, 71])
torch.Size([8, 66]) torch.Size([8, 66])
torch.Size([8, 83]) torch.Size([8, 83])
torch.Size([8, 68]) torch.Size([8, 68])
torch.Size([8, 80]) torch.Size([8, 80])
torch.Size([8, 71]) torch.Size([8, 71])
torch.Size([8, 69]) torch.Size([8, 69])
torch.Size([8, 65]) torch.Size([8, 65])
torch.Size([8, 68]) torch.Size([8, 68])
torch.Size([8, 60]) torch.Size([8, 60])
torch.Size([8, 59]) torch.Size([8, 59])
torch.Size([8, 69]) torch.Size([8, 69])
torch.Size([8, 63]) torch.Size([8, 63])
torch.Size([8, 65]) torch.Size([8, 65])
torch.Size([8, 76]) torch.Size([8, 76])
torch.Size([8, 66]) torch.Size([8, 66])
torch.Size([8, 71]) torch.Size([8, 71])
torch.Size([8, 91]) torch.Size([8, 91])
torch.Size([8, 65]) torch.Size([8, 65])
torch.Size([8, 64]) torch.Size([8, 64])
torch.Size([8, 67]) torch.Size([8, 67])
torch.Size([8, 66]) torch.Size([8, 66])
torch.Size([8, 64]) torch.Size([8, 64])
torch.Size([8, 65]) torch.Size([8, 65])
torch.Size([8, 75]) torch.Size([8, 75])
torch.Size([8, 89]) torch.Size([8, 89])
torch.Size([8, 59]) torch.Size([8, 59])
torch.Size([8, 88]) torch.Size([8, 88])
torch.Size([8, 83]) torch.Size([8, 83])
torch.Size([8, 83]) torch.Size([8, 83])
torch.Size([8, 70]) torch.Size([8, 70])
torch.Size([8, 65]) torch.Size([8, 65])
torch.Size([8, 74]) torch.Size([8, 74])
torch.Size([8, 76]) torch.Size([8, 76])
torch.Size([8, 67]) torch.Size([8, 67])
torch.Size([8, 75]) torch.Size([8, 75])
torch.Size([8, 83]) torch.Size([8, 83])
torch.Size([8, 69]) torch.Size([8, 69])
torch.Size([8, 67]) torch.Size([8, 67])
torch.Size([8, 60]) torch.Size([8, 60])
torch.Size([8, 60]) torch.Size([8, 60])
torch.Size([8, 66]) torch.Size([8, 66])
torch.Size([8, 80]) torch.Size([8, 80])
torch.Size([8, 71]) torch.Size([8, 71])
torch.Size([8, 61]) torch.Size([8, 61])
torch.Size([8, 58]) torch.Size([8, 58])
torch.Size([8, 71]) torch.Size([8, 71])
torch.Size([8, 67]) torch.Size([8, 67])
torch.Size([8, 68]) torch.Size([8, 68])
torch.Size([8, 63]) torch.Size([8, 63])
torch.Size([8, 87]) torch.Size([8, 87])
torch.Size([8, 68]) torch.Size([8, 68])
torch.Size([8, 64]) torch.Size([8, 64])
torch.Size([8, 68]) torch.Size([8, 68])
torch.Size([8, 71]) torch.Size([8, 71])
torch.Size([8, 68]) torch.Size([8, 68])
torch.Size([8, 71]) torch.Size([8, 71])
torch.Size([8, 61]) torch.Size([8, 61])
torch.Size([8, 65]) torch.Size([8, 65])
torch.Size([8, 67]) torch.Size([8, 67])
torch.Size([8, 65]) torch.Size([8, 65])
torch.Size([8, 64]) torch.Size([8, 64])
torch.Size([8, 60]) torch.Size([8, 60])
torch.Size([8, 72]) torch.Size([8, 72])
torch.Size([8, 64]) torch.Size([8, 64])
torch.Size([8, 70]) torch.Size([8, 70])
torch.Size([8, 57]) torch.Size([8, 57])
torch.Size([8, 72]) torch.Size([8, 72])
torch.Size([8, 64]) torch.Size([8, 64])
torch.Size([8, 68]) torch.Size([8, 68])
torch.Size([8, 62]) torch.Size([8, 62])
torch.Size([8, 74]) torch.Size([8, 74])
torch.Size([8, 80]) torch.Size([8, 80])
torch.Size([8, 68]) torch.Size([8, 68])
torch.Size([8, 70]) torch.Size([8, 70])
torch.Size([8, 91]) torch.Size([8, 91])
torch.Size([8, 61]) torch.Size([8, 61])
torch.Size([8, 66]) torch.Size([8, 66])
torch.Size([8, 80]) torch.Size([8, 80])
torch.Size([8, 81]) torch.Size([8, 81])
torch.Size([8, 74]) torch.Size([8, 74])
torch.Size([8, 82]) torch.Size([8, 82])
torch.Size([8, 63]) torch.Size([8, 63])
torch.Size([8, 83]) torch.Size([8, 83])
torch.Size([8, 68]) torch.Size([8, 68])
torch.Size([8, 67]) torch.Size([8, 67])
torch.Size([8, 77]) torch.Size([8, 77])
torch.Size([8, 91]) torch.Size([8, 91])
torch.Size([8, 64]) torch.Size([8, 64])
torch.Size([8, 61]) torch.Size([8, 61])
torch.Size([8, 75]) torch.Size([8, 75])
torch.Size([8, 64]) torch.Size([8, 64])
torch.Size([8, 66]) torch.Size([8, 66])
torch.Size([8, 78]) torch.Size([8, 78])
torch.Size([8, 66]) torch.Size([8, 66])
torch.Size([8, 64]) torch.Size([8, 64])
torch.Size([8, 83]) torch.Size([8, 83])
torch.Size([8, 66]) torch.Size([8, 66])
torch.Size([8, 74]) torch.Size([8, 74])
torch.Size([8, 69]) torch.Size([8, 69])</code></pre>
</div>
</div>
<ul>
<li>As we can see based on the output above, all batches have a batch size of 8 but a different length, as expected</li>
<li>Let’s also double-check that the inputs contain the <code>&lt;|endoftext|&gt;</code> padding tokens corresponding to token ID 50256 by printing the contents of the first training example in the <code>inputs</code> batch</li>
</ul>
<div id="21b8fd02-014f-4481-9b71-5bfee8f9dfcd" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="1b8ad342-2b5b-4f12-ad1a-3cb2a6c712ff" data-execution_count="26">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([21106,   318,   281, 12064,   326,  8477,   257,  4876,    13, 19430,
          257,  2882,   326, 20431, 32543,   262,  2581,    13,   198,   198,
        21017, 46486,    25,   198, 30003,  6525,   262,  6827,  1262,   257,
          985,   576,    13,   198,   198, 21017, 23412,    25,   198,   464,
         5156,   318,   845, 13779,    13,   198,   198, 21017, 18261,    25,
          198,   464,  5156,   318,   355, 13779,   355,   257,  4936,    13,
        50256, 50256, 50256, 50256, 50256, 50256, 50256, 50256, 50256],
       device='cuda:0')</code></pre>
</div>
</div>
<ul>
<li>Similarly, we visually double-check that the targets contain the -100 placeholder tokens</li>
</ul>
<div id="51649ab4-1a7e-4a9e-92c5-950a24fde211" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="5e8c23f8-6a05-4c13-9f92-373b75b57ea6" data-execution_count="27">
<div class="cell-output cell-output-stdout">
<pre><code>tensor([  318,   281, 12064,   326,  8477,   257,  4876,    13, 19430,   257,
         2882,   326, 20431, 32543,   262,  2581,    13,   198,   198, 21017,
        46486,    25,   198, 30003,  6525,   262,  6827,  1262,   257,   985,
          576,    13,   198,   198, 21017, 23412,    25,   198,   464,  5156,
          318,   845, 13779,    13,   198,   198, 21017, 18261,    25,   198,
          464,  5156,   318,   355, 13779,   355,   257,  4936,    13, 50256,
         -100,  -100,  -100,  -100,  -100,  -100,  -100,  -100,  -100],
       device='cuda:0')</code></pre>
</div>
</div>
</section>
<section id="loading-a-pretrained-llm" class="level2">
<h2 class="anchored" data-anchor-id="loading-a-pretrained-llm">7.5 Loading a pretrained LLM</h2>
<ul>
<li>In this section, we load a pretrained GPT model using the same code that we used in section 5.5 of chapter 5 and section 6.4 in chapter 6</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/chapter-overview-4.webp?1" width="500px"></p>
<ul>
<li><p>However, instead of loading the smallest 124 million parameter model, we load the medium version with 355 million parameters since the 124 million model is too small for achieving qualitatively reasonable results via instruction finetuning</p></li>
<li><p>Before we start finetuning the model in the next section, let’s see how it performs on one of the validation tasks</p></li>
</ul>
<div id="7bd32b7c-5b44-4d25-a09f-46836802ca74" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="c1276a91-e7da-495b-be0f-70a96872dbe6" data-execution_count="29">
<div class="cell-output cell-output-stdout">
<pre><code>Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
Convert the active sentence to passive: 'The chef cooks the meal every day.'</code></pre>
</div>
</div>
<ul>
<li>Note that the <code>generate</code> function we used in previous chapters returns the combined input and output text, which was convenient in the previous section for creating legible text</li>
<li>To isolate the response, we can subtract the length of the instruction from the start of the <code>generated_text</code></li>
</ul>
<div id="ba4a55bf-a245-48d8-beda-2838a58fb5ba" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="3e231f03-c5dc-4397-8778-4995731176a3" data-execution_count="31">
<div class="cell-output cell-output-stdout">
<pre><code>The chef cooks the meal every day.

### Instruction:

Convert the active sentence to passive: 'The chef cooks the</code></pre>
</div>
</div>
<ul>
<li>As we can see, the model is not capable of following the instructions, yet; it creates a “Response” section but it simply repeats the original input sentence as well as the instruction</li>
</ul>
</section>
<section id="finetuning-the-llm-on-instruction-data" class="level2">
<h2 class="anchored" data-anchor-id="finetuning-the-llm-on-instruction-data">7.6 Finetuning the LLM on instruction data</h2>
<ul>
<li>In this section, we finetune the model</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/chapter-overview-5.webp?1" width="500px"></p>
<ul>
<li><p>Note that we can reuse all the loss calculation and training functions that we used in previous chapters</p></li>
<li><p>Let’s calculate the initial training and validation set loss before we start training (as in previous chapters, the goal is to minimize the loss)</p></li>
</ul>
<div id="d99fc6f8-63b2-43da-adbb-a7b6b92c8dd5" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="a3f5e1b0-093a-4c51-e7fc-c9cac48c2ea2" data-execution_count="33">
<div class="cell-output cell-output-stdout">
<pre><code>Training loss: 3.8259087562561036
Validation loss: 3.761933708190918</code></pre>
</div>
</div>
<ul>
<li>Note that the training is a bit more expensive than in previous chapters since we are using a larger model (355 million instead of 124 million parameters)</li>
<li>The runtimes for various devices are shown for reference below (running this notebook on a compatible GPU device requires no changes to the code)</li>
</ul>
<div style="text-align: left;">
<table class="caption-top table">
<thead>
<tr class="header">
<th>Model</th>
<th>Device</th>
<th>Runtime for 2 Epochs</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>gpt2-medium (355M)</td>
<td>CPU (M3 MacBook Air)</td>
<td>15.78 minutes</td>
</tr>
<tr class="even">
<td>gpt2-medium (355M)</td>
<td>GPU (M3 MacBook Air)</td>
<td>10.77 minutes</td>
</tr>
<tr class="odd">
<td>gpt2-medium (355M)</td>
<td>GPU (L4)</td>
<td>1.83 minutes</td>
</tr>
<tr class="even">
<td>gpt2-medium (355M)</td>
<td>GPU (A100)</td>
<td>0.86 minutes</td>
</tr>
<tr class="odd">
<td>gpt2-small (124M)</td>
<td>CPU (M3 MacBook Air)</td>
<td>5.74 minutes</td>
</tr>
<tr class="even">
<td>gpt2-small (124M)</td>
<td>GPU (M3 MacBook Air)</td>
<td>3.73 minutes</td>
</tr>
<tr class="odd">
<td>gpt2-small (124M)</td>
<td>GPU (L4)</td>
<td>0.69 minutes</td>
</tr>
<tr class="even">
<td>gpt2-small (124M)</td>
<td>GPU (A100)</td>
<td>0.39 minutes</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>I ran this notebook using the <code>"gpt2-medium (355M)"</code> model</li>
</ul>
<div id="78bcf83a-1fff-4540-97c1-765c4016d5e3" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="ecb9a3dd-97c0-492d-8a51-fbd175bb139b" data-execution_count="34">
<div class="cell-output cell-output-stdout">
<pre><code>Ep 1 (Step 000000): Train loss 2.637, Val loss 2.626
Ep 1 (Step 000005): Train loss 1.174, Val loss 1.103
Ep 1 (Step 000010): Train loss 0.872, Val loss 0.944
Ep 1 (Step 000015): Train loss 0.857, Val loss 0.906
Ep 1 (Step 000020): Train loss 0.776, Val loss 0.881
Ep 1 (Step 000025): Train loss 0.754, Val loss 0.859
Ep 1 (Step 000030): Train loss 0.800, Val loss 0.836
Ep 1 (Step 000035): Train loss 0.714, Val loss 0.809
Ep 1 (Step 000040): Train loss 0.672, Val loss 0.806
Ep 1 (Step 000045): Train loss 0.633, Val loss 0.789
Ep 1 (Step 000050): Train loss 0.663, Val loss 0.782
Ep 1 (Step 000055): Train loss 0.760, Val loss 0.763
Ep 1 (Step 000060): Train loss 0.719, Val loss 0.743
Ep 1 (Step 000065): Train loss 0.653, Val loss 0.735
Ep 1 (Step 000070): Train loss 0.536, Val loss 0.732
Ep 1 (Step 000075): Train loss 0.569, Val loss 0.739
Ep 1 (Step 000080): Train loss 0.603, Val loss 0.734
Ep 1 (Step 000085): Train loss 0.518, Val loss 0.717
Ep 1 (Step 000090): Train loss 0.575, Val loss 0.699
Ep 1 (Step 000095): Train loss 0.505, Val loss 0.689
Ep 1 (Step 000100): Train loss 0.507, Val loss 0.683
Ep 1 (Step 000105): Train loss 0.570, Val loss 0.676
Ep 1 (Step 000110): Train loss 0.564, Val loss 0.671
Ep 1 (Step 000115): Train loss 0.522, Val loss 0.666
Below is an instruction that describes a task. Write a response that appropriately completes the request.  ### Instruction: Convert the active sentence to passive: 'The chef cooks the meal every day.'  ### Response: The meal is prepared every day by the chef.&lt;|endoftext|&gt;The following is an instruction that describes a task. Write a response that appropriately completes the request.  ### Instruction: Convert the active sentence to passive:
Ep 2 (Step 000120): Train loss 0.439, Val loss 0.671
Ep 2 (Step 000125): Train loss 0.454, Val loss 0.685
Ep 2 (Step 000130): Train loss 0.448, Val loss 0.681
Ep 2 (Step 000135): Train loss 0.406, Val loss 0.678
Ep 2 (Step 000140): Train loss 0.412, Val loss 0.678
Ep 2 (Step 000145): Train loss 0.372, Val loss 0.680
Ep 2 (Step 000150): Train loss 0.381, Val loss 0.674
Ep 2 (Step 000155): Train loss 0.419, Val loss 0.672
Ep 2 (Step 000160): Train loss 0.417, Val loss 0.680
Ep 2 (Step 000165): Train loss 0.383, Val loss 0.683
Ep 2 (Step 000170): Train loss 0.328, Val loss 0.679
Ep 2 (Step 000175): Train loss 0.334, Val loss 0.668
Ep 2 (Step 000180): Train loss 0.391, Val loss 0.656
Ep 2 (Step 000185): Train loss 0.418, Val loss 0.657
Ep 2 (Step 000190): Train loss 0.341, Val loss 0.648
Ep 2 (Step 000195): Train loss 0.330, Val loss 0.633
Ep 2 (Step 000200): Train loss 0.313, Val loss 0.631
Ep 2 (Step 000205): Train loss 0.354, Val loss 0.628
Ep 2 (Step 000210): Train loss 0.365, Val loss 0.629
Ep 2 (Step 000215): Train loss 0.394, Val loss 0.634
Ep 2 (Step 000220): Train loss 0.301, Val loss 0.647
Ep 2 (Step 000225): Train loss 0.347, Val loss 0.661
Ep 2 (Step 000230): Train loss 0.297, Val loss 0.659
Below is an instruction that describes a task. Write a response that appropriately completes the request.  ### Instruction: Convert the active sentence to passive: 'The chef cooks the meal every day.'  ### Response: The meal is cooked every day by the chef.&lt;|endoftext|&gt;The following is an instruction that describes a task. Write a response that appropriately completes the request.  ### Instruction: What is the capital of the United Kingdom
Training completed in 0.93 minutes.</code></pre>
</div>
</div>
<ul>
<li>As we can see based on the outputs above, the model trains well, as we can tell based on the decreasing training loss and validation loss values</li>
<li>Furthermore, based on the response text printed after each epoch, we can see that the model correctly follows the instruction to convert the input sentence <code>'The chef cooks the meal every day.'</code> into passive voice <code>'The meal is cooked every day by the chef.'</code> (We will properly format and evaluate the responses in a later section)</li>
<li>Finally, let’s take a look at the training and validation loss curves</li>
</ul>
<div id="4acd368b-1403-4807-a218-9102e35bfdbb" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:306}}" data-outputid="2f5c99e0-7ed0-4f42-d67c-e07c375e6158" data-execution_count="35">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/chapters-ch07-cell-36-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<ul>
<li>As we can see, the loss decreases sharply at the beginning of the first epoch, which means the model starts learning quickly</li>
<li>We can see that slight overfitting sets in at around 1 training epoch</li>
</ul>
</section>
<section id="extracting-and-saving-responses" class="level2">
<h2 class="anchored" data-anchor-id="extracting-and-saving-responses">7.7 Extracting and saving responses</h2>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/chapter-overview-6.webp?1" width="500px"></p>
<ul>
<li>In this section, we save the test set responses for scoring in the next section</li>
<li>We also save a copy of the model for future use</li>
<li>But first, let’s take a brief look at the responses generated by the finetuned model</li>
</ul>
<div id="VQ2NZMbfucAc" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="066c56ff-b52a-4ee6-eae7-1bddfc74d0c1" data-execution_count="36">
<div class="cell-output cell-output-stdout">
<pre><code>Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
Rewrite the sentence using a simile.

### Input:
The car is very fast.

Correct response:
&gt;&gt; The car is as fast as lightning.

Model response:
&gt;&gt; The car is as fast as a bullet.
-------------------------------------
Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
What type of cloud is typically associated with thunderstorms?

Correct response:
&gt;&gt; The type of cloud typically associated with thunderstorms is cumulonimbus.

Model response:
&gt;&gt; The type of cloud associated with thunderstorms is a cumulus cloud.
-------------------------------------
Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
Name the author of 'Pride and Prejudice'.

Correct response:
&gt;&gt; Jane Austen.

Model response:
&gt;&gt; The author of 'Pride and Prejudice' is Jane Austen.
-------------------------------------</code></pre>
</div>
</div>
<ul>
<li><p>As we can see based on the test set instructions, given responses, and the model’s responses, the model performs relatively well</p></li>
<li><p>The answers to the first and last instructions are clearly correct</p></li>
<li><p>The second answer is close; the model answers with “cumulus cloud” instead of “cumulonimbus” (however, note that cumulus clouds can develop into cumulonimbus clouds, which are capable of producing thunderstorms)</p></li>
<li><p>Most importantly, we can see that model evaluation is not as straightforward as in the previous chapter, where we just had to calculate the percentage of correct spam/non-spam class labels to obtain the classification accuracy</p></li>
<li><p>In practice, instruction-finetuned LLMs such as chatbots are evaluated via multiple approaches</p>
<ul>
<li>short-answer and multiple choice benchmarks such as MMLU (“Measuring Massive Multitask Language Understanding”, <a href="https://arxiv.org/abs/2009.03300">https://arxiv.org/abs/2009.03300</a>), which test the knowledge of a model</li>
<li>human preference comparison to other LLMs, such as LMSYS chatbot arena (<a href="https://arena.lmsys.org">https://arena.lmsys.org</a>)</li>
<li>automated conversational benchmarks, where another LLM like GPT-4 is used to evaluate the responses, such as AlpacaEval (<a href="https://tatsu-lab.github.io/alpaca_eval/">https://tatsu-lab.github.io/alpaca_eval/</a>)</li>
</ul></li>
<li><p>In the next section, we will use an approach similar to AlpacaEval and use another LLM to evaluate the responses of our model; however, we will use our own test set instead of using a publicly available benchmark dataset</p></li>
<li><p>For this, we add the model response to the <code>test_data</code> dictionary and save it as a <code>"instruction-data-with-response.json"</code> file for record-keeping so that we can load and analyze it in separate Python sessions if needed</p></li>
<li><p>Let’s double-check one of the entries to see whether the responses have been added to the <code>test_data</code> dictionary correctly</p></li>
</ul>
<div id="u-AvCCMTnPSE" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="7bcd9600-1446-4829-b773-5259b13d256a" data-execution_count="38">
<div class="cell-output cell-output-stdout">
<pre><code>{'instruction': 'Rewrite the sentence using a simile.', 'input': 'The car is very fast.', 'output': 'The car is as fast as lightning.', 'model_response': 'The car is as fast as a bullet.'}</code></pre>
</div>
</div>
<ul>
<li>Finally, we also save the model in case we want to reuse it in the future</li>
</ul>
<div id="8cBU0iHmVfOI" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="135849ed-9acd-43a2-f438-053d07dae9b2" data-scrolled="true" data-execution_count="39">
<div class="cell-output cell-output-stdout">
<pre><code>Model saved as gpt2-medium355M-sft.pth</code></pre>
</div>
</div>
</section>
<section id="evaluating-the-finetuned-llm" class="level2">
<h2 class="anchored" data-anchor-id="evaluating-the-finetuned-llm">7.8 Evaluating the finetuned LLM</h2>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/chapter-overview-7.webp?1" width="500px"></p>
<ul>
<li><p>In this section, we automate the response evaluation of the finetuned LLM using another, larger LLM</p></li>
<li><p>In particular, we use an instruction-finetuned 8-billion-parameter Llama 3 model by Meta AI that can be run locally via ollama (<a href="https://ollama.com">https://ollama.com</a>)</p></li>
<li><p>(Alternatively, if you prefer using a more capable LLM like GPT-4 via the OpenAI API, please see the <a href="../03_model-evaluation/llm-instruction-eval-openai.ipynb">llm-instruction-eval-openai.ipynb</a> notebook)</p></li>
<li><p>Ollama is an application to run LLMs efficiently</p></li>
<li><p>It is a wrapper around llama.cpp (<a href="https://github.com/ggerganov/llama.cpp">https://github.com/ggerganov/llama.cpp</a>), which implements LLMs in pure C/C++ to maximize efficiency</p></li>
<li><p>Note that it is a tool for using LLMs to generate text (inference), not training or finetuning LLMs</p></li>
<li><p>Before running the code below, install ollama by visiting <a href="https://ollama.com">https://ollama.com</a> and following the instructions (for instance, clicking on the “Download” button and downloading the ollama application for your operating system)</p></li>
<li><p>For macOS and Windows users, click on the ollama application you downloaded; if it prompts you to install the command line usage, say “yes”</p></li>
<li><p>Linux users can use the installation command provided on the ollama website</p></li>
<li><p>In general, before we can use ollama from the command line, we have to either start the ollama application or run <code>ollama serve</code> in a separate terminal</p></li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/ollama-run.webp?1" width="700px"></p>
<ul>
<li>With the ollama application or <code>ollama serve</code> running in a different terminal, on the command line, execute the following command to try out the 8-billion-parameter Llama 3 model (the model, which takes up 4.7 GB of storage space, will be automatically downloaded the first time you execute this command)</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb238"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb238-1"><a href="#cb238-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 8B model</span></span>
<span id="cb238-2"><a href="#cb238-2" aria-hidden="true" tabindex="-1"></a><span class="ex">ollama</span> run llama3</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The output looks like as follows</p>
<pre><code>$ ollama run llama3
pulling manifest
pulling 6a0746a1ec1a... 100% ▕████████████████▏ 4.7 GB
pulling 4fa551d4f938... 100% ▕████████████████▏&nbsp; 12 KB
pulling 8ab4849b038c... 100% ▕████████████████▏&nbsp; 254 B
pulling 577073ffcc6c... 100% ▕████████████████▏&nbsp; 110 B
pulling 3f8eb4da87fa... 100% ▕████████████████▏&nbsp; 485 B
verifying sha256 digest
writing manifest
removing any unused layers
success</code></pre>
<ul>
<li><p>Note that <code>llama3</code> refers to the instruction finetuned 8-billion-parameter Llama 3 model</p></li>
<li><p>Using ollama with the <code>"llama3"</code> model (a 8B parameter model) requires 16 GB of RAM; if this is not supported by your machine, you can try the smaller model, such as the 3.8B parameter phi-3 model by setting <code>model = "phi-3"</code>, which only requires 8 GB of RAM</p></li>
<li><p>Alternatively, you can also use the larger 70-billion-parameter Llama 3 model, if your machine supports it, by replacing <code>llama3</code> with <code>llama3:70b</code></p></li>
<li><p>After the download has been completed, you will see a command line prompt that allows you to chat with the model</p></li>
<li><p>Try a prompt like “What do llamas eat?”, which should return an output similar to the following</p></li>
</ul>
<pre><code>&gt;&gt;&gt; What do llamas eat?
Llamas are ruminant animals, which means they have a four-chambered
stomach and eat plants that are high in fiber. In the wild, llamas
typically feed on:
1. Grasses: They love to graze on various types of grasses, including tall
grasses, wheat, oats, and barley.</code></pre>
<ul>
<li><p>You can end this session using the input <code>/bye</code></p></li>
<li><p>The following code checks whether the ollama session is running correctly before proceeding to use ollama to evaluate the test set responses we generated in the previous section</p></li>
</ul>
<div id="026e8570-071e-48a2-aa38-64d7be35f288" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:193}}" data-outputid="e30d3533-e1f5-4aa9-b24f-33273fc7b30e">
<div class="cell-output cell-output-stdout">
<pre><code>Ollama running: True</code></pre>
</div>
</div>
<ul>
<li>Now, an alternative way to the <code>ollama run</code> command we used earlier to interact with the model is via its REST API in Python via the following function</li>
<li>Before you run the next cells in this notebook, make sure that ollama is still running (the previous code cells should print <code>"Ollama running: True"</code>)</li>
<li>Next, run the following code cell to query the model</li>
</ul>
<div id="e3ae0e10-2b28-42ce-8ea2-d9366a58088f" class="cell" data-outputid="cc43acb3-8216-43cf-c77d-71d4089dc96c">
<div class="cell-output cell-output-stdout">
<pre><code>Llamas are herbivores, which means they primarily feed on plant-based foods. Their diet typically consists of:

1. Grasses: Llamas love to graze on various types of grasses, including tall grasses, short grasses, and even weeds.
2. Hay: High-quality hay, such as alfalfa or timothy hay, is a staple in a llama's diet. They enjoy the sweet taste and texture of fresh hay.
3. Grains: Llamas may receive grains like oats, barley, or corn as part of their daily ration. However, it's essential to provide these grains in moderation, as they can be high in calories.
4. Fruits and vegetables: Llamas enjoy a variety of fruits and veggies, such as apples, carrots, sweet potatoes, and leafy greens like kale or spinach.
5. Minerals: Llamas require access to mineral supplements, which help maintain their overall health and well-being.

In the wild, llamas might also eat:

1. Leaves: They'll munch on leaves from trees and shrubs, including plants like willow, alder, and birch.
2. Bark: In some cases, llamas may eat the bark of certain trees, like aspen or cottonwood.
3. Mosses and lichens: These non-vascular plants can be a tasty snack for llamas.

In captivity, llama owners typically provide a balanced diet that includes a mix of hay, grains, and fruits/vegetables. It's essential to consult with a veterinarian or experienced llama breeder to determine the best feeding plan for your llama.</code></pre>
</div>
</div>
<ul>
<li>Now, using the <code>query_model</code> function we defined above, we can evaluate the responses of our finetuned model; let’s try it out on the first 3 test set responses we looked at in a previous section</li>
</ul>
<div id="86b839d4-064d-4178-b2d7-01691b452e5e" class="cell" data-outputid="1c755ee1-bded-4450-9b84-1466724f389a">
<div class="cell-output cell-output-stdout">
<pre><code>
Dataset response:
&gt;&gt; The car is as fast as lightning.

Model response:
&gt;&gt; The car is as fast as a bullet.

Score:
&gt;&gt; I'd rate the model response "The car is as fast as a bullet." an 85 out of 100.

Here's why:

* The response uses a simile correctly, comparing the speed of the car to something else (in this case, a bullet).
* The comparison is relevant and makes sense, as bullets are known for their high velocity.
* The phrase "as fast as" is used correctly to introduce the simile.

The only reason I wouldn't give it a perfect score is that some people might find the comparison slightly less vivid or evocative than others. For example, comparing something to lightning (as in the original response) can be more dramatic and attention-grabbing. However, "as fast as a bullet" is still a strong and effective simile that effectively conveys the idea of the car's speed.

Overall, I think the model did a great job!

-------------------------

Dataset response:
&gt;&gt; The type of cloud typically associated with thunderstorms is cumulonimbus.

Model response:
&gt;&gt; The type of cloud associated with thunderstorms is a cumulus cloud.

Score:
&gt;&gt; I'd score this model response as 40 out of 100.

Here's why:

* The model correctly identifies that thunderstorms are related to clouds (correctly identifying the type of phenomenon).
* However, it incorrectly specifies the type of cloud associated with thunderstorms. Cumulus clouds are not typically associated with thunderstorms; cumulonimbus clouds are.
* The response lacks precision and accuracy in its description.

Overall, while the model attempts to address the instruction, it provides an incorrect answer, which is a significant error.

-------------------------

Dataset response:
&gt;&gt; Jane Austen.

Model response:
&gt;&gt; The author of 'Pride and Prejudice' is Jane Austen.

Score:
&gt;&gt; I'd rate my own response as 95 out of 100. Here's why:

* The response accurately answers the question by naming the author of 'Pride and Prejudice' as Jane Austen.
* The response is concise and clear, making it easy to understand.
* There are no grammatical errors or ambiguities that could lead to confusion.

The only reason I wouldn't give myself a perfect score is that the response is slightly redundant - it's not necessary to rephrase the question in the answer. A more concise response would be simply "Jane Austen."

-------------------------</code></pre>
</div>
</div>
<hr>
<p><strong>Note: Better evaluation prompt</strong></p>
<ul>
<li><a href="https://github.com/rasbt/LLMs-from-scratch/discussions/449">A reader (Ayoosh Kathuria) suggested</a> a longer, improved prompt that evaluates responses on a scale of 1–5 (instead of 1 to 100) and employs a grading rubric, resulting in more accurate and less noisy evaluations:</li>
</ul>
<pre><code>prompt = """
You are a fair judge assistant tasked with providing clear, objective feedback based on specific criteria, ensuring each assessment reflects the absolute standards set for performance.
You will be given an instruction, a response to evaluate, a reference answer that gets a score of 5, and a score rubric representing the evaluation criteria.
Write a detailed feedback that assess the quality of the response strictly based on the given score rubric, not evaluating in general.
Please do not generate any other opening, closing, and explanations.

Here is the rubric you should use to build your answer:
1: The response fails to address the instructions, providing irrelevant, incorrect, or excessively verbose information that detracts from the user's request.
2: The response partially addresses the instructions but includes significant inaccuracies, irrelevant details, or excessive elaboration that detracts from the main task.
3: The response follows the instructions with some minor inaccuracies or omissions. It is generally relevant and clear, but may include some unnecessary details or could be more concise.
4: The response adheres to the instructions, offering clear, accurate, and relevant information in a concise manner, with only occasional, minor instances of excessive detail or slight lack of clarity.
5: The response fully adheres to the instructions, providing a clear, accurate, and relevant answer in a concise and efficient manner. It addresses all aspects of the request without unnecessary details or elaboration

Provide your feedback as follows:

Feedback:::
Evaluation: (your rationale for the rating, as a text)
Total rating: (your rating, as a number between 1 and 5)

You MUST provide values for 'Evaluation:' and 'Total rating:' in your answer.

Now here is the instruction, the reference answer, and the response.

Instruction: {instruction}
Reference Answer: {reference}
Answer: {answer}


Provide your feedback. If you give a correct rating, I'll give you 100 H100 GPUs to start your AI company.
Feedback:::
Evaluation: """</code></pre>
<ul>
<li>For more context and information, see <a href="https://github.com/rasbt/LLMs-from-scratch/discussions/449">this</a> GitHub discussion</li>
</ul>
<hr>
<ul>
<li>As we can see, the Llama 3 model provides a reasonable evaluation and also gives partial points if a model is not entirely correct, as we can see based on the “cumulus cloud” answer</li>
<li>Note that the previous prompt returns very verbose evaluations; we can tweak the prompt to generate integer responses in the range between 0 and 100 (where 100 is best) to calculate an average score for our model</li>
<li>The evaluation of the 110 entries in the test set takes about 1 minute on an M3 MacBook Air laptop</li>
</ul>
<div id="9d7bca69-97c4-47a5-9aa0-32f116fa37eb" class="cell" data-outputid="110223c0-90ca-481d-b2d2-f6ac46d3c4f0">
<div class="cell-output cell-output-stdout">
<pre><code>Number of scores: 110 of 110
Average score: 50.32
</code></pre>
</div>
</div>
<ul>
<li><p>Our model achieves an average score of above 50, which we can use as a reference point to compare the model to other models or to try out other training settings that may improve the model</p></li>
<li><p>Note that ollama is not fully deterministic across operating systems (as of this writing), so the numbers you are getting might slightly differ from the ones shown above</p></li>
<li><p>For reference, the original</p>
<ul>
<li>Llama 3 8B base model achieves a score of 58.51</li>
<li>Llama 3 8B instruct model achieves a score of 82.65</li>
</ul></li>
</ul>
</section>
<section id="conclusions" class="level2">
<h2 class="anchored" data-anchor-id="conclusions">7.9 Conclusions</h2>
<section id="whats-next" class="level3">
<h3 class="anchored" data-anchor-id="whats-next">7.9.1 What’s next</h3>
<ul>
<li>This marks the final chapter of this book</li>
<li>We covered the major steps of the LLM development cycle: implementing an LLM architecture, pretraining an LLM, and finetuning it</li>
</ul>
<p><img src="https://sebastianraschka.com/images/LLMs-from-scratch-images/ch07_compressed/final-overview.webp?1" width="500px"></p>
<ul>
<li><p>An optional step that is sometimes followed after instruction finetuning, as described in this chapter, is preference finetuning</p></li>
<li><p>Preference finetuning process can be particularly useful for customizing a model to better align with specific user preferences; see the <a href="../04_preference-tuning-with-dpo">../04_preference-tuning-with-dpo</a> folder if you are interested in this</p></li>
<li><p>This GitHub repository also contains a large selection of additional bonus material you may enjoy; for more information, please see the <a href="https://github.com/rasbt/LLMs-from-scratch?tab=readme-ov-file#bonus-material">Bonus Material</a> section on this repository’s README page</p></li>
</ul>
</section>
<section id="staying-up-to-date-in-a-fast-moving-field" class="level3">
<h3 class="anchored" data-anchor-id="staying-up-to-date-in-a-fast-moving-field">7.9.2 Staying up to date in a fast-moving field</h3>
<ul>
<li>No code in this section</li>
</ul>
</section>
<section id="final-words" class="level3">
<h3 class="anchored" data-anchor-id="final-words">7.9.3 Final words</h3>
<ul>
<li>I hope you enjoyed this journey of implementing an LLM from the ground up and coding the pretraining and finetuning functions</li>
<li>In my opinion, implementing an LLM from scratch is the best way to understand how LLMs work; I hope you gained a better understanding through this approach</li>
<li>While this book serves educational purposes, you may be interested in using different and more powerful LLMs for real-world applications
<ul>
<li>For this, you may consider popular tools such as axolotl (<a href="https://github.com/OpenAccess-AI-Collective/axolotl">https://github.com/OpenAccess-AI-Collective/axolotl</a>) or LitGPT (<a href="https://github.com/Lightning-AI/litgpt">https://github.com/Lightning-AI/litgpt</a>), which I help developing</li>
</ul></li>
</ul>
</section>
</section>
<section id="summary-and-takeaways-5" class="level2">
<h2 class="anchored" data-anchor-id="summary-and-takeaways-5">Summary and takeaways</h2>
<ul>
<li>See the <a href="./gpt_instruction_finetuning.py">./gpt_instruction_finetuning.py</a> script, a self-contained script for instruction finetuning</li>
<li><a href="./ollama_evaluate.py">./ollama_evaluate.py</a> is a standalone script based on section 7.8 that evaluates a JSON file containing “output” and “response” keys via Ollama and Llama 3</li>
<li>The <a href="./load-finetuned-model.ipynb">./load-finetuned-model.ipynb</a> notebook illustrates how to load the finetuned model in a new session</li>
<li>You can find the exercise solutions in <a href="./exercise-solutions.ipynb">./exercise-solutions.ipynb</a></li>
</ul>
</section>
<section id="whats-next-1" class="level2">
<h2 class="anchored" data-anchor-id="whats-next-1">What’s next?</h2>
<ul>
<li>Congrats on completing the book; in case you are looking for additional resources, I added several bonus sections to this GitHub repository that you might find interesting</li>
<li>The complete list of bonus materials can be viewed in the main README’s <a href="https://github.com/rasbt/LLMs-from-scratch?tab=readme-ov-file#bonus-material">Bonus Material</a> section</li>
<li>To highlight a few of my favorites:
<ol type="1">
<li><a href="../04_preference-tuning-with-dpo/dpo-from-scratch.ipynb">Direct Preference Optimization (DPO) for LLM Alignment (From Scratch)</a> implements a popular preference tuning mechanism to align the model from this chapter more closely with human preferences</li>
<li><a href="../../ch05/07_gpt_to_llama/standalone-llama32.ipynb">Llama 3.2 From Scratch (A Standalone Notebook)</a>, a from-scratch implementation of Meta AI’s popular Llama 3.2, including loading the official pretrained weights; if you are up to some additional experiments, you can replace the <code>GPTModel</code> model in each of the chapters with the <code>Llama3Model</code> class (it should work as a 1:1 replacement)</li>
<li><a href="../../ch05/07_gpt_to_llama">Converting GPT to Llama</a> contains code with step-by-step guides that explain the differences between GPT-2 and the various Llama models</li>
<li><a href="../../ch02/03_bonus_embedding-vs-matmul/embeddings-and-linear-layers.ipynb">Understanding the Difference Between Embedding Layers and Linear Layers</a> is a conceptual explanation illustrating that the <code>Embedding</code> layer in PyTorch, which we use at the input stage of an LLM, is mathematically equivalent to a linear layer applied to one-hot encoded data</li>
</ol></li>
<li>Happy further reading!</li>
</ul>
</section>
<a class="quarto-notebook-link" id="nblink-5" href="chapters/ch07-preview.html#4e19327b-6c02-4881-ad02-9b6d3ec0b1b4">Source: 7.1 Introduction to instruction finetuning</a></div>
</section>
<section id="deployment-in-hf-hub-using-gradio" class="level1">
<h1>8. Deployment in HF-Hub using Gradio</h1>
<div id="154bbaaa" class="cell" data-code-copy="true" data-execution_count="2">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb246"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb246-1"><a href="#cb246-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb246-2"><a href="#cb246-2"></a><span class="im">import</span> sys</span>
<span id="cb246-3"><a href="#cb246-3"></a></span>
<span id="cb246-4"><a href="#cb246-4"></a><span class="im">import</span> tiktoken</span>
<span id="cb246-5"><a href="#cb246-5"></a><span class="im">import</span> torch</span>
<span id="cb246-6"><a href="#cb246-6"></a><span class="im">import</span> gradio <span class="im">as</span> gr</span>
<span id="cb246-7"><a href="#cb246-7"></a></span>
<span id="cb246-8"><a href="#cb246-8"></a><span class="co"># For llms_from_scratch installation instructions, see:</span></span>
<span id="cb246-9"><a href="#cb246-9"></a><span class="co"># https://github.com/rasbt/LLMs-from-scratch/tree/main/pkg</span></span>
<span id="cb246-10"><a href="#cb246-10"></a><span class="im">from</span> previous_chapters <span class="im">import</span> GPTModel</span>
<span id="cb246-11"><a href="#cb246-11"></a></span>
<span id="cb246-12"><a href="#cb246-12"></a><span class="im">from</span> previous_chapters <span class="im">import</span> (</span>
<span id="cb246-13"><a href="#cb246-13"></a>    generate,</span>
<span id="cb246-14"><a href="#cb246-14"></a>    text_to_token_ids,</span>
<span id="cb246-15"><a href="#cb246-15"></a>    token_ids_to_text,</span>
<span id="cb246-16"><a href="#cb246-16"></a>)</span>
<span id="cb246-17"><a href="#cb246-17"></a></span>
<span id="cb246-18"><a href="#cb246-18"></a>device <span class="op">=</span> torch.device(<span class="st">"cuda"</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">"cpu"</span>)</span>
<span id="cb246-19"><a href="#cb246-19"></a></span>
<span id="cb246-20"><a href="#cb246-20"></a></span>
<span id="cb246-21"><a href="#cb246-21"></a><span class="kw">def</span> get_model_and_tokenizer():</span>
<span id="cb246-22"><a href="#cb246-22"></a>    <span class="co">"""</span></span>
<span id="cb246-23"><a href="#cb246-23"></a><span class="co">    Code to load a GPT-2 model with finetuned weights generated in chapter 7.</span></span>
<span id="cb246-24"><a href="#cb246-24"></a><span class="co">    This requires that you run the code in chapter 7 first, which generates the necessary gpt2-medium355M-sft.pth file.</span></span>
<span id="cb246-25"><a href="#cb246-25"></a><span class="co">    """</span></span>
<span id="cb246-26"><a href="#cb246-26"></a></span>
<span id="cb246-27"><a href="#cb246-27"></a>    GPT_CONFIG_355M <span class="op">=</span> {</span>
<span id="cb246-28"><a href="#cb246-28"></a>        <span class="st">"vocab_size"</span>: <span class="dv">50257</span>,     <span class="co"># Vocabulary size</span></span>
<span id="cb246-29"><a href="#cb246-29"></a>        <span class="st">"context_length"</span>: <span class="dv">1024</span>,  <span class="co"># Shortened context length (orig: 1024)</span></span>
<span id="cb246-30"><a href="#cb246-30"></a>        <span class="st">"emb_dim"</span>: <span class="dv">768</span>,         <span class="co"># Embedding dimension</span></span>
<span id="cb246-31"><a href="#cb246-31"></a>        <span class="st">"n_heads"</span>: <span class="dv">12</span>,           <span class="co"># Number of attention heads</span></span>
<span id="cb246-32"><a href="#cb246-32"></a>        <span class="st">"n_layers"</span>: <span class="dv">12</span>,          <span class="co"># Number of layers</span></span>
<span id="cb246-33"><a href="#cb246-33"></a>        <span class="st">"drop_rate"</span>: <span class="fl">0.0</span>,        <span class="co"># Dropout rate</span></span>
<span id="cb246-34"><a href="#cb246-34"></a>        <span class="st">"qkv_bias"</span>: <span class="va">True</span>         <span class="co"># Query-key-value bias</span></span>
<span id="cb246-35"><a href="#cb246-35"></a>    }</span>
<span id="cb246-36"><a href="#cb246-36"></a></span>
<span id="cb246-37"><a href="#cb246-37"></a>    tokenizer <span class="op">=</span> tiktoken.get_encoding(<span class="st">"gpt2"</span>)</span>
<span id="cb246-38"><a href="#cb246-38"></a></span>
<span id="cb246-39"><a href="#cb246-39"></a>    <span class="co"># For local development</span></span>
<span id="cb246-40"><a href="#cb246-40"></a>    model_path <span class="op">=</span> Path(<span class="st">"gpt2-small124M-sft.pth"</span>)</span>
<span id="cb246-41"><a href="#cb246-41"></a>    </span>
<span id="cb246-42"><a href="#cb246-42"></a>    <span class="co"># For Hugging Face deployment</span></span>
<span id="cb246-43"><a href="#cb246-43"></a>    hf_model_path <span class="op">=</span> Path(<span class="st">"gpt2-small124M-sft.pth"</span>)</span>
<span id="cb246-44"><a href="#cb246-44"></a>    </span>
<span id="cb246-45"><a href="#cb246-45"></a>    <span class="co"># Try loading from the Hugging Face model path first, then fall back to local</span></span>
<span id="cb246-46"><a href="#cb246-46"></a>    <span class="cf">if</span> hf_model_path.exists():</span>
<span id="cb246-47"><a href="#cb246-47"></a>        model_path <span class="op">=</span> hf_model_path</span>
<span id="cb246-48"><a href="#cb246-48"></a>    <span class="cf">elif</span> <span class="kw">not</span> model_path.exists():</span>
<span id="cb246-49"><a href="#cb246-49"></a>        <span class="bu">print</span>(</span>
<span id="cb246-50"><a href="#cb246-50"></a>            <span class="ss">f"Could not find the model file. Please run the chapter 7 code "</span></span>
<span id="cb246-51"><a href="#cb246-51"></a>            <span class="st">"to generate the gpt2-medium355M-sft.pth file or upload it to this directory."</span></span>
<span id="cb246-52"><a href="#cb246-52"></a>        )</span>
<span id="cb246-53"><a href="#cb246-53"></a>        sys.exit()</span>
<span id="cb246-54"><a href="#cb246-54"></a></span>
<span id="cb246-55"><a href="#cb246-55"></a>    checkpoint <span class="op">=</span> torch.load(model_path, weights_only<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb246-56"><a href="#cb246-56"></a>    model <span class="op">=</span> GPTModel(GPT_CONFIG_355M)</span>
<span id="cb246-57"><a href="#cb246-57"></a>    model.load_state_dict(checkpoint)</span>
<span id="cb246-58"><a href="#cb246-58"></a>    model.to(device)</span>
<span id="cb246-59"><a href="#cb246-59"></a>    model.<span class="bu">eval</span>()  <span class="co"># Set to evaluation mode</span></span>
<span id="cb246-60"><a href="#cb246-60"></a></span>
<span id="cb246-61"><a href="#cb246-61"></a>    <span class="cf">return</span> tokenizer, model, GPT_CONFIG_355M</span>
<span id="cb246-62"><a href="#cb246-62"></a></span>
<span id="cb246-63"><a href="#cb246-63"></a></span>
<span id="cb246-64"><a href="#cb246-64"></a><span class="kw">def</span> extract_response(response_text, input_text):</span>
<span id="cb246-65"><a href="#cb246-65"></a>    <span class="cf">return</span> response_text[<span class="bu">len</span>(input_text):].replace(<span class="st">"### Response:"</span>, <span class="st">""</span>).strip()</span>
<span id="cb246-66"><a href="#cb246-66"></a></span>
<span id="cb246-67"><a href="#cb246-67"></a></span>
<span id="cb246-68"><a href="#cb246-68"></a><span class="co"># Load model and tokenizer</span></span>
<span id="cb246-69"><a href="#cb246-69"></a>tokenizer, model, model_config <span class="op">=</span> get_model_and_tokenizer()</span>
<span id="cb246-70"><a href="#cb246-70"></a></span>
<span id="cb246-71"><a href="#cb246-71"></a></span>
<span id="cb246-72"><a href="#cb246-72"></a><span class="kw">def</span> generate_response(message, max_new_tokens<span class="op">=</span><span class="dv">100</span>):</span>
<span id="cb246-73"><a href="#cb246-73"></a>    <span class="co">"""Generate a response using the fine-tuned GPT model"""</span></span>
<span id="cb246-74"><a href="#cb246-74"></a>    torch.manual_seed(<span class="dv">123</span>)</span>
<span id="cb246-75"><a href="#cb246-75"></a>    </span>
<span id="cb246-76"><a href="#cb246-76"></a>    prompt <span class="op">=</span> <span class="ss">f"""Below is an instruction that describes a task. Write a response</span></span>
<span id="cb246-77"><a href="#cb246-77"></a><span class="ss">    that appropriately completes the request.</span></span>
<span id="cb246-78"><a href="#cb246-78"></a></span>
<span id="cb246-79"><a href="#cb246-79"></a><span class="ss">    ### Instruction:</span></span>
<span id="cb246-80"><a href="#cb246-80"></a><span class="ss">    </span><span class="sc">{</span>message<span class="sc">}</span></span>
<span id="cb246-81"><a href="#cb246-81"></a><span class="ss">    """</span></span>
<span id="cb246-82"><a href="#cb246-82"></a>    </span>
<span id="cb246-83"><a href="#cb246-83"></a>    <span class="cf">with</span> torch.no_grad():  <span class="co"># Ensure no gradients are computed during inference</span></span>
<span id="cb246-84"><a href="#cb246-84"></a>        token_ids <span class="op">=</span> generate(</span>
<span id="cb246-85"><a href="#cb246-85"></a>            model<span class="op">=</span>model,</span>
<span id="cb246-86"><a href="#cb246-86"></a>            idx<span class="op">=</span>text_to_token_ids(prompt, tokenizer).to(device),</span>
<span id="cb246-87"><a href="#cb246-87"></a>            max_new_tokens<span class="op">=</span>max_new_tokens,</span>
<span id="cb246-88"><a href="#cb246-88"></a>            context_size<span class="op">=</span>model_config[<span class="st">"context_length"</span>],</span>
<span id="cb246-89"><a href="#cb246-89"></a>            eos_id<span class="op">=</span><span class="dv">50256</span></span>
<span id="cb246-90"><a href="#cb246-90"></a>        )</span>
<span id="cb246-91"><a href="#cb246-91"></a></span>
<span id="cb246-92"><a href="#cb246-92"></a>    text <span class="op">=</span> token_ids_to_text(token_ids, tokenizer)</span>
<span id="cb246-93"><a href="#cb246-93"></a>    response <span class="op">=</span> extract_response(text, prompt)</span>
<span id="cb246-94"><a href="#cb246-94"></a>    </span>
<span id="cb246-95"><a href="#cb246-95"></a>    <span class="cf">return</span> response</span>
<span id="cb246-96"><a href="#cb246-96"></a></span>
<span id="cb246-97"><a href="#cb246-97"></a></span>
<span id="cb246-98"><a href="#cb246-98"></a><span class="co"># Create a custom chat interface without using ChatInterface class</span></span>
<span id="cb246-99"><a href="#cb246-99"></a><span class="kw">def</span> respond(message, chat_history):</span>
<span id="cb246-100"><a href="#cb246-100"></a>    bot_message <span class="op">=</span> generate_response(message)</span>
<span id="cb246-101"><a href="#cb246-101"></a>    chat_history.append((message, bot_message))</span>
<span id="cb246-102"><a href="#cb246-102"></a>    <span class="cf">return</span> <span class="st">""</span>, chat_history</span>
<span id="cb246-103"><a href="#cb246-103"></a></span>
<span id="cb246-104"><a href="#cb246-104"></a></span>
<span id="cb246-105"><a href="#cb246-105"></a><span class="cf">with</span> gr.Blocks(theme<span class="op">=</span><span class="st">"soft"</span>) <span class="im">as</span> demo:</span>
<span id="cb246-106"><a href="#cb246-106"></a>    gr.Markdown(<span class="st">"# Fine-tuned GPT Model Chat"</span>)</span>
<span id="cb246-107"><a href="#cb246-107"></a>    gr.Markdown(<span class="st">"Chat with a fine-tuned GPT model from 'Build a Large Language Model From Scratch' by Sebastian Raschka"</span>)</span>
<span id="cb246-108"><a href="#cb246-108"></a>    </span>
<span id="cb246-109"><a href="#cb246-109"></a>    chatbot <span class="op">=</span> gr.Chatbot(height<span class="op">=</span><span class="dv">600</span>)</span>
<span id="cb246-110"><a href="#cb246-110"></a>    msg <span class="op">=</span> gr.Textbox(placeholder<span class="op">=</span><span class="st">"Ask me something..."</span>, container<span class="op">=</span><span class="va">False</span>, scale<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb246-111"><a href="#cb246-111"></a>    clear <span class="op">=</span> gr.Button(<span class="st">"Clear"</span>)</span>
<span id="cb246-112"><a href="#cb246-112"></a>    </span>
<span id="cb246-113"><a href="#cb246-113"></a>    msg.submit(respond, [msg, chatbot], [msg, chatbot])</span>
<span id="cb246-114"><a href="#cb246-114"></a>    clear.click(<span class="kw">lambda</span>: [], <span class="va">None</span>, chatbot)</span>
<span id="cb246-115"><a href="#cb246-115"></a>    </span>
<span id="cb246-116"><a href="#cb246-116"></a>    gr.Examples(</span>
<span id="cb246-117"><a href="#cb246-117"></a>        examples<span class="op">=</span>[</span>
<span id="cb246-118"><a href="#cb246-118"></a>            <span class="st">"What is the capital of France?"</span>,</span>
<span id="cb246-119"><a href="#cb246-119"></a>            <span class="st">"What is the opposite of 'wet'?"</span>,</span>
<span id="cb246-120"><a href="#cb246-120"></a>            <span class="st">"what is the capital of USA?"</span></span>
<span id="cb246-121"><a href="#cb246-121"></a>        ],</span>
<span id="cb246-122"><a href="#cb246-122"></a>        inputs<span class="op">=</span>msg</span>
<span id="cb246-123"><a href="#cb246-123"></a>    )</span>
<span id="cb246-124"><a href="#cb246-124"></a></span>
<span id="cb246-125"><a href="#cb246-125"></a></span>
<span id="cb246-126"><a href="#cb246-126"></a><span class="co"># Launch the interface</span></span>
<span id="cb246-127"><a href="#cb246-127"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb246-128"><a href="#cb246-128"></a>    demo.launch(share<span class="op">=</span><span class="va">True</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<section id="fine-tuned-gpt-model-demo" class="level2">
<h2 class="anchored" data-anchor-id="fine-tuned-gpt-model-demo">Fine-tuned GPT Model Demo</h2>
<p>This interactive demo showcases a GPT model fine-tuned using techniques from “Build a Large Language Model From Scratch” by Sebastian Raschka. Try asking questions or giving it instructions to see the model in action.</p>
<div class="gradio-embed-container">
  <!-- Fallback image that displays if iframe fails to load -->
  <div id="fallback-container" style="display: none; text-align: center; margin: 20px 0;">
  <p style="color: #d32f2f; font-weight: bold;">Interactive demo could not be loaded</p>
  <img src="chapters/HF_GPT2.png" alt="Screenshot of the Fine-tuned GPT Model interface" style="max-width: 100%; border-radius: 8px; border: 1px solid #e0e0e0; box-shadow: 0 0 10px rgba(0,0,0,0.1); margin-bottom: 15px;">
  <p>
    <a href="https://huggingface.co/spaces/doggdad/InstructGPTFinetuned" target="_blank" style="display: inline-block; background-color: #2196F3; color: white; padding: 10px 15px; text-decoration: none; border-radius: 4px; font-weight: bold;">
      Open the demo in Hugging Face Spaces
    </a>
  </p>
</div>
  <!-- Main iframe for the Gradio app -->
  <iframe id="gradio-iframe" src="https://doggdad-instructgptfinetuned.hf.space/?__theme=light" frameborder="0" width="100%" height="800px" style="border: 1px solid #e0e0e0; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1);" allow="camera; microphone; clipboard-read; clipboard-write; fullscreen" loading="lazy" title="Fine-tuned GPT Model Interactive Demo" onload="document.getElementById('loading-container').style.display = 'none';" onerror="handleIframeError();"></iframe>
  
  <!-- Loading indicator -->
  <div id="loading-container" style="text-align: center; padding: 40px; background-color: #f5f5f5; border-radius: 10px; margin-bottom: 20px;">
    <div class="loading-spinner"></div>
    <p style="margin-top: 20px; color: #333;">Loading interactive demo...</p>
  </div>

  <!-- Notes and instructions -->
  <div class="gradio-notes">
    <p>
      <strong>Tips for using the model:</strong> 
      Try asking questions, requesting creative content, or giving specific instructions.
    </p>
    <div class="example-prompts">
      <button class="example-button" onclick="copyToInput('What is the capital of France?')">What is the capital of France?</button>
      <button class="example-button" onclick="copyToInput('What is the opposite of wet?')">What is the opposite of wet?</button>
      <button class="example-button" onclick="copyToInput('What is the capital of USA?')">What is the capital of USA?</button>
    </div>
  </div>
</div>

<style>
  .gradio-embed-container {
    margin: 2rem 0;
    padding: 0;
    background-color: #ffffff;
    border-radius: 12px;
    position: relative;
  }
  
  .gradio-notes {
    margin-top: 15px;
    padding: 15px;
    background-color: #f8f9fa;
    border-radius: 8px;
    border-left: 4px solid #2196F3;
    font-size: 0.9rem;
  }
  
  .example-prompts {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 10px;
  }
  
  .example-button {
    background-color: #e8eaf6;
    border: 1px solid #c5cae9;
    border-radius: 20px;
    padding: 6px 12px;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .example-button:hover {
    background-color: #c5cae9;
  }
  
  /* Loading spinner */
  .loading-spinner {
    border: 5px solid #f3f3f3;
    border-radius: 50%;
    border-top: 5px solid #2196F3;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
    margin: 0 auto;
  }
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  /* Responsive adjustments */
  @media (max-width: 768px) {
    .example-prompts {
      flex-direction: column;
    }
    
    .example-button {
      width: 100%;
      margin-bottom: 5px;
    }
    
    #gradio-iframe {
      height: 600px;
    }
  }
</style>

<script>
  // Wait for document to be fully loaded
  document.addEventListener('DOMContentLoaded', function() {
    // Set a timeout to check if iframe loaded successfully
    setTimeout(function() {
      checkIframeLoaded();
    }, 10000); // 10 seconds timeout
  });
  
  // Function to check if iframe loaded
  function checkIframeLoaded() {
    const iframe = document.getElementById('gradio-iframe');
    const loadingContainer = document.getElementById('loading-container');
    
    // If loading container is still visible after timeout, show fallback
    if (loadingContainer.style.display !== 'none') {
      handleIframeError();
    }
  }
  
  // Handle iframe loading error
  function handleIframeError() {
    document.getElementById('gradio-iframe').style.display = 'none';
    document.getElementById('loading-container').style.display = 'none';
    document.getElementById('fallback-container').style.display = 'block';
  }
  
  // Function to copy example prompts to input (this won't work directly with iframe,
  // but is included in case you want to implement message passing to the iframe later)
  function copyToInput(text) {
    // This is a placeholder - it won't actually work with the iframe
    // unless you implement message passing using postMessage
    alert("Example selected: " + text + "\n\nPlease copy and paste this into the input field in the demo.");
    
    // Attempt to copy to clipboard
    navigator.clipboard.writeText(text).then(function() {
      console.log("Text copied to clipboard");
    }).catch(function(err) {
      console.error("Could not copy text: ", err);
    });
  }
</script>
<section id="try-the-demo-above-or-visit-the-full-hugging-face-space-for-the-best-experience." class="level3">
<h3 class="anchored" data-anchor-id="try-the-demo-above-or-visit-the-full-hugging-face-space-for-the-best-experience.">Try the demo above or visit the <a href="https://huggingface.co/spaces/doggdad/InstructGPTFinetuned">full Hugging Face Space</a> for the best experience.</h3>
</section>
</section>
</section>
<section id="key-technical-achievements" class="level1">
<h1>9. Key Technical Achievements</h1>
<ol type="1">
<li><strong>Complete GPT Implementation</strong>: Full transformer architecture with multi-head attention, layer normalization, and residual connections</li>
<li><strong>From-Scratch Components</strong>: Custom tokenizer, attention mechanisms, and training loops</li>
<li><strong>Weight Transfer</strong>: Successfully loading OpenAI GPT-2 pretrained weights (124M-1558M parameters)</li>
<li><strong>Two Finetuning Approaches</strong>: Classification (spam detection) and instruction-following</li>
<li><strong>Advanced Sampling</strong>: Temperature scaling and top-k sampling for controlled generation</li>
<li><strong>Automated Evaluation</strong>: LLM-based evaluation using local Ollama models</li>
<li><strong>Laptop-Scale Training</strong>: All code designed to run on conventional laptops without specialized hardware</li>
</ol>
</section>
<section id="references" class="level1">
<h1>References</h1>
<ul>
<li><strong>Book</strong>: <em>Build a Large Language Model (From Scratch)</em> by Sebastian Raschka</li>
<li><strong>Publisher</strong>: Manning Publications</li>
<li><strong>ISBN</strong>: 9781633437166</li>
<li><strong>GitHub</strong>: https://github.com/rasbt/LLMs-from-scratch</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/your-website-url\.example\.com");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>